(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.ANSWERS = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  /** @module SearchStates */

  /**
   * SearchStates is an ENUM for the various stages of searching,
   * used to show different templates
   * @enum {string}
   */
  var SearchStates = {
    PRE_SEARCH: 'pre-search',
    SEARCH_LOADING: 'search-loading',
    SEARCH_COMPLETE: 'search-complete'
  };

  /** @module Result */
  var Result = function Result() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Result);

    /**
     * The raw profile data
     * @type {Object}
     * @private
     */
    this._raw = data.raw || null;
    /**
     * The formatted profile data
     * @type {Object}
     * @private
     */

    this._formatted = data.formatted;
    /**
     * The highlighted profile data with highlights applied to applicable fields
     * @type {Object}
     * @private
     */

    this._highlighted = data.highlighted;
    /**
     * The index number of the result
     * @type {Number}
     */

    this.ordinal = data.ordinal || null;
    /**
     * The title of the result card
     * @type {string|null}
     */

    this.title = data.title || null;
    /**
     * The body of the details section of the result card, can contain HTML
     * @type {string| null}
     */

    this.details = data.details || null;
    /**
     * The destination link for the title of the result card
     * @type {string|null}
     */

    this.link = data.link || null;
    /**
     * The Entity ID, or other unique identifier, used for to power interactivity
     * @type {string|null}
     */

    this.id = data.id || null;
    /**
     * The subtitle on the result card
     * @type {string|null}
     */

    this.subtitle = data.subtitle || null;
    /**
     * The class modifier, usually derived from the vertical configuration ID
     * Used to apply different styling to different result card types
     * @type {string|null}
     */

    this.modifier = data.modifier || null;
    /**
     * A large date, of the format { month: 'Jan', day: '01' }
     * @type {Object|null}
     */

    this.bigDate = data.bigDate || null;
    /**
     * An image profile object, expected to have a url property
     * @type {Object|null}
     */

    this.image = data.image || null;
    /**
     * An array of calls to action, of the format:
     * { icon: '', url: '', text: '', eventType: '', eventOptions: {}}
     * @type {Array}
     */

    this.callsToAction = data.callsToAction || [];
    /**
     * Determines if an accordian result should be collapsed by default
     * @type {boolean}
     */

    this.collapsed = data.collapsed || true;
  };

  /** @module HighlightedValue */

  /**
   * Model representing a highlighted value.
   */
  var HighlightedValue =
  /*#__PURE__*/
  function () {
    function HighlightedValue() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HighlightedValue);

      this.value = data.value || data.shortValue || '';
      this.matchedSubstrings = data.matchedSubstrings || [];
    }
    /**
     * get highlighted value string
     * @returns {string}
     */


    _createClass(HighlightedValue, [{
      key: "get",
      value: function get() {
        this._sortMatchedSubstrings();

        return this.buildHighlightedValue(this.value, this.matchedSubstrings);
      }
      /**
       * get inverted highlighted value string
       * @returns {string}
       */

    }, {
      key: "getInverted",
      value: function getInverted() {
        this._sortMatchedSubstrings();

        var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

        return this.buildHighlightedValue(this.value, invertedSubstrings);
      }
      /**
       * introduces highlighting to input data according to highlighting specifiers
       *
       * @param {Object} val input object to apply highlighting to
       *
       *  example object :
       *  {
       *    name: 'ATM',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 ATMs'
       *    }
       *  }
       *
       * @param {Object} highlightedSubstrings highlighting specifiers to apply to input object
       *
       *  example object :
       *  {
       *    name: {
       *      matchedSubstrings: [{
       *        length: 3,
       *        offset: 0
       *      }],
       *      value: 'ATM'
       *    },
       *    featuredMessage: {
       *      description: {
       *        matchedSubstrings: [{
       *          length: 4,
       *          offset: 45
       *        }],
       *        value: 'Save time & bank on your terms at over 1,800 ATMs'
       *      }
       *    }
       *  }
       *
       * @returns {string} copy of input value with highlighting applied
       *
       *  example object :
       *  {
       *    name: '<strong>ATM</strong>',
       *    featuredMessage: {
       *      description: 'Save time & bank on your terms at over 1,800 <strong>ATMs</strong>'
       *    }
       *  }
       *
       */

    }, {
      key: "buildHighlightedValue",
      value: function buildHighlightedValue(val, highlightedSubstrings) {
        var highlightedValue = '';
        var nextStart = 0;

        if (highlightedSubstrings.length === 0) {
          return val;
        }

        for (var j = 0; j < highlightedSubstrings.length; j++) {
          var start = Number(highlightedSubstrings[j].offset);
          var end = start + highlightedSubstrings[j].length;
          highlightedValue += [val.slice(nextStart, start), '<strong>', val.slice(start, end), '</strong>'].join('');

          if (j === highlightedSubstrings.length - 1 && end < val.length) {
            highlightedValue += val.slice(end);
          }

          nextStart = end;
        }

        return highlightedValue;
      }
    }, {
      key: "_sortMatchedSubstrings",
      value: function _sortMatchedSubstrings() {
        this.matchedSubstrings.sort(function (a, b) {
          if (a.offset < b.offset) {
            return -1;
          }

          if (a.offset > b.offset) {
            return 1;
          }

          return 0;
        });
      }
    }, {
      key: "_getInvertedSubstrings",
      value: function _getInvertedSubstrings(matchedSubstrings, valueLength) {
        var invertedSubstrings = [];

        for (var i = 0; i < matchedSubstrings.length; i++) {
          var substring = matchedSubstrings[i];
          var nextOffset = substring.offset + substring.length;

          if (i === 0 && substring.offset !== 0) {
            invertedSubstrings.push({
              offset: 0,
              length: substring.offset
            });
          }

          if (valueLength > nextOffset) {
            invertedSubstrings.push({
              offset: nextOffset,
              length: i < matchedSubstrings.length - 1 ? matchedSubstrings[i + 1].offset - nextOffset : valueLength - nextOffset
            });
          }
        }

        return invertedSubstrings;
      }
    }]);

    return HighlightedValue;
  }();

  /** @module Errors */

  /**
   * AnswersBaseError is an extension of the base Error object.
   * This is the object that is used to when reporting to the server.
   * @extends Error
   *
   * Error codes fall into one of four categories:
   * 1XX errors: Basic errors
   * 2XX errors: UI errors
   * 3XX errors: Endpoint errors
   * 4XX errors: Core errors
   */
  var AnswersBaseError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(AnswersBaseError, _Error);

    function AnswersBaseError(errorCode, message, boundary, causedBy) {
      var _this;

      _classCallCheck(this, AnswersBaseError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnswersBaseError).call(this, message));
      _this.errorCode = errorCode;
      _this.errorMessage = message;
      _this.boundary = boundary;
      _this.reported = false;

      if (causedBy) {
        _this.causedBy = causedBy instanceof AnswersBaseError ? causedBy : AnswersBaseError.from(causedBy);
      }

      return _this;
    }

    _createClass(AnswersBaseError, [{
      key: "toJson",
      value: function toJson() {
        return JSON.stringify(this);
      }
    }, {
      key: "toString",
      value: function toString() {
        var string = "".concat(this.errorMessage, " (").concat(this.boundary, ")");

        if (this.causedBy) {
          string += "\n  Caused By: ".concat(this.causedBy.toString());
        }

        return string;
      }
    }], [{
      key: "from",
      value: function from(builtinError, boundary) {
        var error = new AnswersBasicError(builtinError.message, boundary);
        error.stack = builtinError.stack;
        return error;
      }
    }]);

    return AnswersBaseError;
  }(_wrapNativeSuper(Error));
  /**
   * AnswersBasicError is a wrapper around all the built-in errors
   * e.g. undefined variables, incorrect syntax, types, missing methods, etc.
   * @extends AnswersBaseError
   */

  var AnswersBasicError =
  /*#__PURE__*/
  function (_AnswersBaseError) {
    _inherits(AnswersBasicError, _AnswersBaseError);

    function AnswersBasicError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersBasicError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersBasicError).call(this, 100, message, boundary, causedBy));
    }

    return AnswersBasicError;
  }(AnswersBaseError);
  /**
   * AnswersUiError used for things like DOM errors.
   * @extends AnswersBaseError
   */

  var AnswersConfigError =
  /*#__PURE__*/
  function (_AnswersBaseError2) {
    _inherits(AnswersConfigError, _AnswersBaseError2);

    function AnswersConfigError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersConfigError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersConfigError).call(this, 101, message, boundary, causedBy));
    }

    return AnswersConfigError;
  }(AnswersBaseError);
  /**
   * AnswersComponentError is used for Component oriented errors
   * e.g. failure to render, or catching unknowns.
   * @extends AnswersBaseError
   */

  var AnswersComponentError =
  /*#__PURE__*/
  function (_AnswersBaseError4) {
    _inherits(AnswersComponentError, _AnswersBaseError4);

    function AnswersComponentError(message, component, causedBy) {
      _classCallCheck(this, AnswersComponentError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersComponentError).call(this, 201, message, component, causedBy));
    }

    return AnswersComponentError;
  }(AnswersBaseError);
  /**
   * AnswersEndpointError represents all network related errors.
   * @extends AnswersBaseError
   */

  var AnswersEndpointError =
  /*#__PURE__*/
  function (_AnswersBaseError5) {
    _inherits(AnswersEndpointError, _AnswersBaseError5);

    function AnswersEndpointError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersEndpointError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersEndpointError).call(this, 300, message, boundary, causedBy));
    }

    return AnswersEndpointError;
  }(AnswersBaseError);
  /**
   * AnswersCoreError represents errors for precondition failures in the core library
   * @extends AnswersBaseError
   */

  var AnswersCoreError =
  /*#__PURE__*/
  function (_AnswersBaseError6) {
    _inherits(AnswersCoreError, _AnswersBaseError6);

    function AnswersCoreError(message, boundary, causedBy) {
      _classCallCheck(this, AnswersCoreError);

      return _possibleConstructorReturn(this, _getPrototypeOf(AnswersCoreError).call(this, 400, message, boundary, causedBy));
    }

    return AnswersCoreError;
  }(AnswersBaseError);
  /**
   * AnswersStorageError represents storage related errors
   * @extends AnswersBaseError
   */

  var AnswersStorageError =
  /*#__PURE__*/
  function (_AnswersBaseError7) {
    _inherits(AnswersStorageError, _AnswersBaseError7);

    function AnswersStorageError(message, storageKey, data, causedBy) {
      var _this2;

      _classCallCheck(this, AnswersStorageError);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersStorageError).call(this, 401, message, 'Storage', causedBy));
      _this2.storageKey = storageKey;
      _this2.data = data;
      return _this2;
    }

    return AnswersStorageError;
  }(AnswersBaseError);
  /**
   * AnswersAnalyticsError is used for errors when reporting analytics
   * @extends AnswersBaseError
   */

  var AnswersAnalyticsError =
  /*#__PURE__*/
  function (_AnswersBaseError8) {
    _inherits(AnswersAnalyticsError, _AnswersBaseError8);

    function AnswersAnalyticsError(message, event, causedBy) {
      var _this3;

      _classCallCheck(this, AnswersAnalyticsError);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(AnswersAnalyticsError).call(this, 402, message, 'Analytics', causedBy));
      _this3.event = event;
      return _this3;
    }

    return AnswersAnalyticsError;
  }(AnswersBaseError);

  var ResultFactory =
  /*#__PURE__*/
  function () {
    function ResultFactory() {
      _classCallCheck(this, ResultFactory);
    }

    _createClass(ResultFactory, null, [{
      key: "from",

      /**
       * Converts an API result object into a Result view model.
       * Includes default mappings of GoogleCustomSearchEngine results to
       * the fields exposed by the template.
       * @param resultsData  {Array} expected format: { data: { ... }, highlightedFields: { ... }}
       * @param {Object.<string, function>} formatters The formatters to apply to the result
       * @param {string} verticalId The vertical of these results
       * @param {string} source Backend source of these results
       * @returns {Result[]}
       */
      value: function from(resultsData, formatters, verticalId, source) {
        var results = [];

        for (var i = 0; i < resultsData.length; i++) {
          var data = resultsData[i].data || resultsData[i];

          switch (source) {
            case 'GOOGLE_CSE':
              results.push(ResultFactory.fromGoogleCustomSearchEngine(data));
              break;

            case 'BING_CSE':
              results.push(ResultFactory.fromBingCustomSearchEngine(data));
              break;

            case 'ZENDESK':
              results.push(ResultFactory.fromZendeskSearchEngine(data));
              break;

            case 'ALGOLIA':
              results.push(ResultFactory.fromAlgoliaSearchEngine(data));
              break;

            case 'KNOWLEDGE_MANAGER':
              var highlightedFields = resultsData[i].highlightedFields || {};
              results.push(ResultFactory.fromKnowledgeManager(data, formatters, verticalId, highlightedFields, i));
              break;

            default:
              results.push(ResultFactory.fromGeneric(data, i));
          }
        }

        return results;
      }
      /**
       * Applies field formatters to Knowledge Manager Entity Profile Data
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} formatters Developer specified Field Formatters
       * @param {string} verticalId Identifier for Vertical
       * @param {Object} highlightedEntityProfileData Subset of Entity Profile Data with highlighting applied
       * @returns {Object} Subset of Entity Profile Data Fields with field formatters applied
       */

    }, {
      key: "computeFormattedData",
      value: function computeFormattedData(entityProfileData, formatters, verticalId, highlightedEntityProfileData) {
        // if no field formatters specified, nothing to format
        if (Object.keys(formatters).length === 0) {
          return {};
        }

        var formattedData = {};
        Object.entries(entityProfileData).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              fieldName = _ref2[0],
              fieldVal = _ref2[1];

          // check if a field formatter exists for the current entity profile field
          if (formatters[fieldName] === undefined) {
            return;
          } // verify the field formatter provided is a formatter function as expected


          if (typeof formatters[fieldName] !== 'function') {
            throw new AnswersCoreError('Field formatter is not of expected type function', 'ResultFactory');
          } // if highlighted version of field value is available, make it available to field formatter


          var highlightedFieldVal = null;

          if (highlightedEntityProfileData && highlightedEntityProfileData[fieldName]) {
            highlightedFieldVal = highlightedEntityProfileData[fieldName];
          } // call formatter function associated with the field name
          // the input object defines the interface that field formatter functions work with


          formattedData[fieldName] = formatters[fieldName]({
            entityProfileData: entityProfileData,
            entityFieldValue: fieldVal,
            highlightedEntityFieldValue: highlightedFieldVal,
            verticalId: verticalId,
            isDirectAnswer: false
          });
        });
        return formattedData;
      }
      /**
       * Applies highlighting to substrings within Knowledge Manager Entity Field Values
       * according to highlighting specifiers returned from the Knowledge Manager Search Backend
       *
       * @param {Object} entityProfileData Entity Profile Data
       * @param {Object} highlightedFields KM specified highlighting instructions to highlight certain Fields
       * @returns {Object} Subset of Entity Profile Data Fields with highlighting applied
       */

    }, {
      key: "computeHighlightedData",
      value: function computeHighlightedData(entityProfileData, highlightedFields) {
        // if no highlighted fields specified, nothing to highlight
        if (Object.keys(highlightedFields).length === 0) {
          return {};
        }

        var highlightedData = {}; // iterate through entity fields that have highlighting instructions

        Object.entries(highlightedFields).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 1),
              highlightedFieldName = _ref4[0];

          // verify that the highlighted field name corresponds to an existing entity profile field
          if (entityProfileData[highlightedFieldName] === undefined) {
            throw new AnswersCoreError('Highlighted Field Name does not exist in Entity Profile', 'ResultFactory');
          }

          var highlightedField = highlightedFields[highlightedFieldName]; // check for nested fields

          if (_typeof(highlightedField) === 'object' && Object.keys(highlightedField).length > 0 && highlightedField['matchedSubstrings'] === undefined) {
            // recurse to children fields
            highlightedData[highlightedFieldName] = ResultFactory.computeHighlightedData(entityProfileData[highlightedFieldName], highlightedFields[highlightedFieldName]);
          } else {
            var highlightedDataValue = new HighlightedValue(entityProfileData).buildHighlightedValue(highlightedField.value, highlightedField.matchedSubstrings);
            highlightedData[highlightedFieldName] = highlightedDataValue;
          }
        });
        return highlightedData;
      }
      /**
       * Converts an API result object into a generic result view model.
       * @param {Object} data
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromGeneric",
      value: function fromGeneric(data, index) {
        return new Result({
          raw: data,
          title: data.name,
          details: this.truncate(data.description),
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a Knowledge Manager result view model.
       * @param {Object} data
       * @param {Object} formatters
       * @param {string} verticalId
       * @param {Object} highlightedFields
       * @param {number} index
       * @returns {Result}
       */

    }, {
      key: "fromKnowledgeManager",
      value: function fromKnowledgeManager(data, formatters, verticalId, highlightedFields, index) {
        // compute highlighted entity profile data
        var highlightedEntityProfileData = ResultFactory.computeHighlightedData(data, highlightedFields); // compute formatted entity profile data

        var formattedEntityProfileData = ResultFactory.computeFormattedData(data, formatters, verticalId, highlightedEntityProfileData); // set result details checking the following in order of priority : formatted, highlighted, raw

        var resultDetails = null;

        if (formattedEntityProfileData.description !== undefined) {
          resultDetails = formattedEntityProfileData.description;
        } else if (highlightedEntityProfileData.description !== undefined) {
          resultDetails = this.truncate(highlightedEntityProfileData.description);
        } else {
          resultDetails = this.truncate(data.description);
        }

        return new Result({
          raw: data,
          formatted: formattedEntityProfileData,
          highlighted: highlightedEntityProfileData,
          title: formattedEntityProfileData.name || data.name,
          details: resultDetails,
          link: data.website,
          id: data.id,
          ordinal: index + 1
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Google Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromGoogleCustomSearchEngine",
      value: function fromGoogleCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.htmlTitle.replace(/(<([^>]+)>)/ig, ''),
          details: data.htmlSnippet,
          link: data.link
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Bing Custom Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromBingCustomSearchEngine",
      value: function fromBingCustomSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.name,
          details: data.snippet,
          link: data.url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Zendesk Search Engine object.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromZendeskSearchEngine",
      value: function fromZendeskSearchEngine(data) {
        return new Result({
          raw: data,
          title: data.title,
          details: data.snippet,
          link: data.html_url
        });
      }
      /**
       * Converts an API result object into a result view model.
       * Maps view model fields based on the API data for a Algolia Search Engine object.
       * Details field is set to objectID since response has only one general field objectID.
       * @param {Object} data
       * @returns {Result}
       */

    }, {
      key: "fromAlgoliaSearchEngine",
      value: function fromAlgoliaSearchEngine(data) {
        return new Result({
          raw: data,
          details: data.objectID,
          id: data.objectID
        });
      }
      /**
       * Truncates strings to 250 characters, attempting to preserve whole words
       * @param str {string} the string to truncate
       * @param limit {Number} the maximum character length to return
       * @param trailing {string} a trailing string to denote truncation, e.g. '...'
       * @param sep {string} the word separator
       * @returns {string}
       */

    }, {
      key: "truncate",
      value: function truncate(str) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
        var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';
        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';

        if (!str || str.length <= limit) {
          return str;
        } // TODO (bmcginnis): split punctuation too so we don't end up with "foo,..."


        var words = str.split(sep);
        var max = limit - trailing.length;
        var truncated = '';

        for (var i = 0; i < words.length; i++) {
          var word = words[i];

          if (truncated.length + word.length > max || i !== 0 && truncated.length + word.length + sep.length > max) {
            truncated += trailing;
            break;
          }

          truncated += i === 0 ? word : sep + word;
        }

        return truncated;
      }
    }]);

    return ResultFactory;
  }();

  var Section =
  /*#__PURE__*/
  function () {
    function Section(data, url, formatters) {
      _classCallCheck(this, Section);

      this.searchState = SearchStates.SEARCH_COMPLETE;
      this.verticalConfigId = data.verticalConfigId || null;
      this.resultsCount = data.resultsCount || 0;
      this.encodedState = data.encodedState || '';
      this.appliedQueryFilters = AppliedQueryFilter.from(data.appliedQueryFilters);
      this.facets = data.facets || null;
      this.results = ResultFactory.from(data.results, formatters, this.verticalConfigId, data.source);
      this.map = Section.parseMap(data.results);
      this.verticalURL = url || null;
    }

    _createClass(Section, null, [{
      key: "parseMap",
      value: function parseMap(results) {
        var mapMarkers = [];
        var centerCoordinates = {};

        for (var j = 0; j < results.length; j++) {
          // TODO(billy) Remove legacy fallback from all data format
          var result = results[j].data || results[j];

          if (result && result.yextDisplayCoordinate) {
            if (!centerCoordinates.latitude) {
              centerCoordinates = {
                latitude: result.yextDisplayCoordinate.latitude,
                longitude: result.yextDisplayCoordinate.longitude
              };
            }

            mapMarkers.push({
              item: result,
              label: mapMarkers.length + 1,
              latitude: result.yextDisplayCoordinate.latitude,
              longitude: result.yextDisplayCoordinate.longitude
            });
          }
        }

        return {
          'mapCenter': centerCoordinates,
          'mapMarkers': mapMarkers
        };
      }
      /**
       * Create a section from the provided data
       * @param {Object|Array} modules The result modules
       * @param {Object} urls The tab urls
       * @param {Object.<string, function>} formatters Field formatters for results
       */

    }, {
      key: "from",
      value: function from(modules, urls, formatters) {
        var sections = [];

        if (!modules) {
          return sections;
        }

        if (!Array.isArray(modules)) {
          return new Section(modules, null, formatters);
        } // Our sections should contain a property of mapMarker objects


        for (var i = 0; i < modules.length; i++) {
          sections.push(new Section(modules[i], urls[modules[i].verticalConfigId], formatters));
        }

        return sections;
      }
    }]);

    return Section;
  }();

  var AppliedQueryFilter =
  /*#__PURE__*/
  function () {
    // Support legacy model and new model until fully migrated.
    // TODO(billy) Remove the left expression during assignment when migrated.
    function AppliedQueryFilter(appliedQueryFilter) {
      _classCallCheck(this, AppliedQueryFilter);

      this.key = appliedQueryFilter.key || appliedQueryFilter.displayKey;
      this.value = appliedQueryFilter.value || appliedQueryFilter.displayValue;
    }

    _createClass(AppliedQueryFilter, null, [{
      key: "from",
      value: function from(appliedQueryFilters) {
        var filters = [];

        for (var i = 0; i < appliedQueryFilters.length; i++) {
          filters.push(new AppliedQueryFilter(appliedQueryFilters[i]));
        }

        return filters;
      }
    }]);

    return AppliedQueryFilter;
  }();

  var UniversalResults =
  /*#__PURE__*/
  function () {
    function UniversalResults(data) {
      _classCallCheck(this, UniversalResults);

      this.queryId = data.queryId || null;
      this.sections = data.sections || [];
      /**
       * The current state of the search, used to render different templates before, during,
       * and after loading
       * @type {string}
       */

      this.searchState = data.searchState || SearchStates.SEARCH_COMPLETE;
    }
    /**
     * Create universal results from server data
     * @param {Object} response The server response
     * @param {Object} urls The tab urls
     * @param {Object.<string, function>} formatters The field formatters to use
     */


    _createClass(UniversalResults, null, [{
      key: "from",
      value: function from(response, urls, formatters) {
        return new UniversalResults({
          queryId: response.queryId,
          sections: Section.from(response.modules, urls, formatters)
        });
      }
      /**
       * Construct a UnivervalResults object representing loading results
       * @return {UniversalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new UniversalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }]);

    return UniversalResults;
  }();

  /** @module DirectAnswer */
  var DirectAnswer =
  /*#__PURE__*/
  function () {
    function DirectAnswer() {
      var directAnswer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, DirectAnswer);

      Object.assign(this, directAnswer);
      Object.freeze(this);
    }
    /**
     * Create a DirectAnswer model from the given server data and formatters
     * @param {Object} response The server direct answer
     * @param {Object.<string, function>} formatters The formatters to apply to this direct answer
     */


    _createClass(DirectAnswer, null, [{
      key: "from",
      value: function from(response, formatters) {
        var data = _objectSpread({}, response);

        var answer = data.answer,
            relatedItem = data.relatedItem;

        if (answer && formatters[answer.fieldApiName]) {
          answer.value = formatters[answer.fieldApiName](answer.value, relatedItem.data.fieldValues, relatedItem.verticalConfigId, true);
        }

        return new DirectAnswer(data);
      }
    }]);

    return DirectAnswer;
  }();

  /** @module Navigation */
  var Navigation =
  /*#__PURE__*/
  function () {
    function Navigation(tabOrder) {
      _classCallCheck(this, Navigation);

      this.tabOrder = tabOrder || [];
      Object.freeze(this);
    }

    _createClass(Navigation, null, [{
      key: "from",
      value: function from(modules) {
        var nav = [];

        if (!modules || !Array.isArray(modules)) {
          return nav;
        }

        for (var i = 0; i < modules.length; i++) {
          nav.push(modules[i].verticalConfigId);
        }

        return new Navigation(nav);
      }
    }]);

    return Navigation;
  }();

  var VerticalResults =
  /*#__PURE__*/
  function () {
    function VerticalResults() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, VerticalResults);

      Object.assign(this, {
        searchState: SearchStates.SEARCH_COMPLETE
      }, data);
      Object.freeze(this);
    }
    /**
     * Append the provided results to the current results
     * @param {VerticalResults} results the results to append to the current results
     */


    _createClass(VerticalResults, [{
      key: "append",
      value: function append(results) {
        var merged = _objectSpread({}, this);

        merged.results = this.results.concat(results.results);
        merged.map.mapMarkers = this.map.mapMarkers.concat(results.map.mapMarkers);
        return new VerticalResults(merged);
      }
      /**
       * Create vertical results from server data
       * @param {Object} response The server response
       * @param {Object.<string, function>} formatters The field formatters to use
       */

    }], [{
      key: "from",
      value: function from(response, formatters) {
        return new VerticalResults(Section.from(response, null, formatters));
      }
      /**
       * Construct a VerticalResults object representing loading results
       * @return {VerticalResults}
       */

    }, {
      key: "searchLoading",
      value: function searchLoading() {
        return new VerticalResults({
          searchState: SearchStates.SEARCH_LOADING
        });
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }]);

    return VerticalResults;
  }();

  /**
   * SpellCheck is the core state model
   * to power the SpellCheck component
   */

  var SpellCheck =
  /*#__PURE__*/
  function () {
    function SpellCheck(data) {
      _classCallCheck(this, SpellCheck);

      /**
       * The original query
       * @type {string}
       */
      this.query = data.query || null;
      /**
       * The corrected query
       * @type {string}
       */

      this.correctedQuery = data.correctedQuery || null;
      /**
       * The corrected query with highlighted tags
       * @type {string}
       */

      this.correctedQueryDisplay = data.correctedQueryDisplay || null;
      /**
       * The spell check type
       * @type {string}
       */

      this.type = data.type || null;
      /**
       * Should show spell check or not
       * @type {boolean}
       */

      this.shouldShow = this.correctedQuery !== null;
    }
    /**
     * Create a spell check model from the provided data
     * @param {Object} response The spell check response
     */


    _createClass(SpellCheck, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return {};
        }

        return new SpellCheck({
          query: response.originalQuery,
          correctedQuery: response.correctedQuery,
          correctedQueryDisplay: new HighlightedValue(response.correctedQuery).get(),
          type: response.type
        });
      }
    }]);

    return SpellCheck;
  }();

  /** @module StorageKeys */

  /**
   * StorageKeys is an ENUM are considered the root context
   * for how data is stored and scoped in the storage.
   *
   * @enum {string}
   */
  var StorageKeys = {
    NAVIGATION: 'navigation',
    UNIVERSAL_RESULTS: 'universal-results',
    VERTICAL_RESULTS: 'vertical-results',
    AUTOCOMPLETE: 'autocomplete',
    DIRECT_ANSWER: 'direct-answer',
    FILTER: 'filter',
    QUERY: 'query',
    QUERY_ID: 'query-id',
    FACET_FILTER: 'facet-filter',
    DYNAMIC_FILTERS: 'dynamic-filters',
    PARAMS: 'params',
    GEOLOCATION: 'geolocation',
    INTENTS: 'intents',
    QUESTION_SUBMISSION: 'question-submission',
    SEARCH_CONFIG: 'search-config',
    SEARCH_OFFSET: 'search-offset',
    SPELL_CHECK: 'spell-check',
    LOCATION_BIAS: 'location-bias',
    SESSIONS_OPT_IN: 'sessions-opt-in',
    NAVIGATION_CONFIG: 'navigation-config',
    LOCALE: 'locale'
  };

  /** @module DynamicFilters */

  /**
   * Model representing a set of dynamic filters
   */
  var DynamicFilters =
  /*#__PURE__*/
  function () {
    function DynamicFilters(data) {
      _classCallCheck(this, DynamicFilters);

      /**
       * The list of filters this model holds
       * @type {{label: string, fieldId: string, options: object[]}}
       */
      this.filters = data.filters || [];
      Object.freeze(this);
    }
    /**
     * Organize 'facets' from the api response into dynamic filters
     * @param {Object} response dynamic filter response from the api
     * @returns {DynamicFilters}
     */


    _createClass(DynamicFilters, null, [{
      key: "from",
      value: function from(response) {
        var facets = response.facets;
        var dynamicFilters = facets.map(function (f) {
          return {
            label: f['displayName'],
            fieldId: f['fieldId'],
            options: f.options.map(function (o) {
              return {
                label: o['displayName'],
                countLabel: o['count'],
                selected: o['selected'],
                filter: o['filter']
              };
            })
          };
        });
        return new DynamicFilters({
          filters: dynamicFilters
        });
      }
    }]);

    return DynamicFilters;
  }();

  /** @module SearchIntents */
  var SearchIntents =
  /*#__PURE__*/
  function () {
    function SearchIntents(intents) {
      _classCallCheck(this, SearchIntents);

      /**
       * The intent to find results based on the user's location
       * @type {boolean}
       */
      this.nearMe = intents.nearMe;
      Object.freeze(this);
    }
    /**
     * Create SearchIntents from server response
     * @param {Object} response The server response intents
     * @returns {SearchIntents}
     */


    _createClass(SearchIntents, null, [{
      key: "from",
      value: function from(response) {
        var intents = response || [];
        return new SearchIntents({
          nearMe: intents.includes('NEAR_ME')
        });
      }
    }]);

    return SearchIntents;
  }();

  /** @module LocationBias */

  /**
   * LocationBias is the core state model
   * to power the LocationBias component
   */
  var LocationBias =
  /*#__PURE__*/
  function () {
    function LocationBias(data) {
      _classCallCheck(this, LocationBias);

      /**
       * The location bias accuracy which are IP, DEVICE and UNKNWON
       * @type {string}
       */
      this.accuracy = data.accuracy || null;
      /**
       * The latitude used for location bias
       * @type {number}
       */

      this.latitude = data.latitude || null;
      /**
       * The longitude used for location bias
       * @type {number}
       */

      this.longitude = data.longitude || null;
      /**
       * The location display name
       * @type {string}
       */

      this.locationDisplayName = data.locationDisplayName || null;
    }
    /**
     * Create a location bias model from the provided data
     * @param {Object} response The location bias response
     */


    _createClass(LocationBias, null, [{
      key: "from",
      value: function from(response) {
        if (!response) {
          return new LocationBias({
            accuracy: 'UNKNOWN'
          });
        }

        return new LocationBias({
          accuracy: response.accuracy,
          latitude: response.latitude,
          longitude: response.longitude,
          locationDisplayName: response.locationDisplayName
        });
      }
    }]);

    return LocationBias;
  }();

  /**
   * A Data Transformer that takes the response object from a Search request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   */

  var SearchDataTransformer =
  /*#__PURE__*/
  function () {
    function SearchDataTransformer() {
      _classCallCheck(this, SearchDataTransformer);
    }

    _createClass(SearchDataTransformer, null, [{
      key: "transform",
      value: function transform(data) {
        var _ref;

        var urls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var formatters = arguments.length > 2 ? arguments[2] : undefined;
        var response = data.response;
        return _ref = {}, _defineProperty(_ref, StorageKeys.QUERY_ID, response.queryId), _defineProperty(_ref, StorageKeys.NAVIGATION, Navigation.from(response.modules)), _defineProperty(_ref, StorageKeys.DIRECT_ANSWER, DirectAnswer.from(response.directAnswer, formatters)), _defineProperty(_ref, StorageKeys.UNIVERSAL_RESULTS, UniversalResults.from(response, urls, formatters)), _defineProperty(_ref, StorageKeys.INTENTS, SearchIntents.from(response.searchIntents)), _defineProperty(_ref, StorageKeys.SPELL_CHECK, SpellCheck.from(response.spellCheck)), _defineProperty(_ref, StorageKeys.LOCATION_BIAS, LocationBias.from(response.locationBias)), _ref;
      }
    }, {
      key: "transformVertical",
      value: function transformVertical(data, formatters) {
        var _ref2;

        return _ref2 = {}, _defineProperty(_ref2, StorageKeys.QUERY_ID, data.response.queryId), _defineProperty(_ref2, StorageKeys.NAVIGATION, new Navigation()), _defineProperty(_ref2, StorageKeys.VERTICAL_RESULTS, VerticalResults.from(data.response, formatters)), _defineProperty(_ref2, StorageKeys.DYNAMIC_FILTERS, DynamicFilters.from(data.response)), _defineProperty(_ref2, StorageKeys.INTENTS, SearchIntents.from(data.response.searchIntents)), _defineProperty(_ref2, StorageKeys.SPELL_CHECK, SpellCheck.from(data.response.spellCheck)), _defineProperty(_ref2, StorageKeys.LOCATION_BIAS, LocationBias.from(data.response.locationBias)), _ref2;
      }
    }]);

    return SearchDataTransformer;
  }();

  /** @module QuestionSubmission */

  /**
   * QuestionSubmission is the core state model
   * to power the QuestionSubmission component
   */
  var QuestionSubmission =
  /*#__PURE__*/
  function () {
    function QuestionSubmission() {
      var question = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var errors = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, QuestionSubmission);

      /**
       * The author of the question
       * @type {string}
       */
      this.name = question.name || null;
      /**
       * The email address of the question
       * @type {string}
       */

      this.email = question.email || null;
      /**
       * True if the privacy policy was approved
       * @type {boolean}
       */

      this.privacyPolicy = question.privacyPolicy || null;
      /**
       * The question to be sent to the server
       * @type {string}
       */

      this.questionText = question.questionText || null;
      /**
       * Alternative question meta information
       * @type {string}
       */

      this.questionDescription = question.questionDescription || null;
      /**
       * Whether the form is expanded or not. Defaults to true.
       */

      this.questionExpanded = typeof question.expanded !== 'boolean' || question.expanded;
      /**
       * Contains any errors about the question submission
       * @type {object}
       */

      this.errors = errors || null;
      /**
       * Whether the form has been submitted or not. Defaults to false.
       */

      this.questionSubmitted = question.submitted || false;
      Object.freeze(this);
    }

    _createClass(QuestionSubmission, null, [{
      key: "submitted",
      value: function submitted() {
        return {
          questionSubmitted: true,
          questionExpanded: true
        };
      }
    }, {
      key: "errors",
      value: function errors(question, _errors) {
        return QuestionSubmission(question, _errors);
      }
    }]);

    return QuestionSubmission;
  }();

  /** @module Filter */

  /**
   * Represents an api filter and provides static methods for easily constructing Filters.
   * See https://developer.yext.com/docs/api-reference/#operation/listEntities for structure details
   */
  var Filter =
  /*#__PURE__*/
  function () {
    function Filter() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Filter);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Parse a JSON format filter returned from the server into a Filter
     * @param {*} responseFilter A filter in JSON format returned from the backend
     * @returns {Filter}
     */


    _createClass(Filter, null, [{
      key: "fromResponse",
      value: function fromResponse(responseFilter) {
        return new Filter(JSON.parse(responseFilter));
      }
      /**
       * Return a new Filter representing the OR of all provided filters
       * @param  {...Filter} filters The filters to OR together
       * @returns {Filter}
       */

    }, {
      key: "or",
      value: function or() {
        for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
          filters[_key] = arguments[_key];
        }

        return new Filter({
          '$or': filters
        });
      }
      /**
       * Return a new Filter representing the AND of all provided filters
       * @param  {...Filter} filters The filters to AND together
       * @returns {Filter}
       */

    }, {
      key: "and",
      value: function and() {
        for (var _len2 = arguments.length, filters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          filters[_key2] = arguments[_key2];
        }

        return new Filter({
          '$and': filters
        });
      }
      /**
       * OR filters with the same keys, then AND the resulting groups
       * @param  {...Filter} filters The filters to group
       * @returns {Filter}
       */

    }, {
      key: "group",
      value: function group() {
        var groups = {};

        for (var _len3 = arguments.length, filters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          filters[_key3] = arguments[_key3];
        }

        for (var _i = 0, _filters = filters; _i < _filters.length; _i++) {
          var filter = _filters[_i];
          var key = Object.keys(filter)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(filter);
        }

        var groupFilters = [];

        for (var _i2 = 0, _Object$keys = Object.keys(groups); _i2 < _Object$keys.length; _i2++) {
          var field = _Object$keys[_i2];
          groupFilters.push(groups[field].length > 1 ? Filter.or.apply(Filter, _toConsumableArray(groups[field])) : groups[field][0]);
        }

        return groupFilters.length > 1 ? Filter.and.apply(Filter, groupFilters) : groupFilters[0];
      }
      /**
       * Create a new "equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be equal to
       * @returns {Filter}
       */

    }, {
      key: "equal",
      value: function equal(field, value) {
        return Filter._fromMatcher(field, '$eq', value);
      }
      /**
       * Create a new "less than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than
       * @returns {Filter}
       */

    }, {
      key: "lessThan",
      value: function lessThan(field, value) {
        return Filter._fromMatcher(field, '$lt', value);
      }
      /**
       * Create a new "less than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be less than or equal to
       * @returns {Filter}
       */

    }, {
      key: "lessThanEqual",
      value: function lessThanEqual(field, value) {
        return Filter._fromMatcher(field, '$le', value);
      }
      /**
       * Create a new "greater than" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than
       * @returns {Filter}
       */

    }, {
      key: "greaterThan",
      value: function greaterThan(field, value) {
        return Filter._fromMatcher(field, '$gt', value);
      }
      /**
       * Create a new "greater than or equal to" filter for a field
       * @param {string} field The subject field of the filter
       * @param {*} value The value the field should be greater than or equal to
       * @returns {Filter}
       */

    }, {
      key: "greaterThanEqual",
      value: function greaterThanEqual(field, value) {
        return Filter._fromMatcher(field, '$ge', value);
      }
      /**
       * Create a new inclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "inclusiveRange",
      value: function inclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$ge': min,
          '$le': max
        }));
      }
      /**
       * Create a new exclusive range filter
       * @param {string} field The subject field of the filter
       * @param {*} min The minimum value
       * @param {*} max The maximum value
       * @returns {Filter}
       */

    }, {
      key: "exclusiveRange",
      value: function exclusiveRange(field, min, max) {
        return new Filter(_defineProperty({}, field, {
          '$gt': min,
          '$lt': max
        }));
      }
      /**
       * Create a new position filter
       * @param {number} lat The latitude of the position
       * @param {number} lng The longitude of the position
       * @param {number} radius The search radius (in meters)
       */

    }, {
      key: "position",
      value: function position(lat, lng, radius) {
        return Filter._fromMatcher('builtin.location', '$near', {
          lat: lat,
          lng: lng,
          radius: radius
        });
      }
      /**
       * Create a new filter with the given matcher
       * @private
       * @param {string} field The subject field of the filter
       * @param {string} matcher The matcher for the filer
       * @param {*} value The value for the filter
       * @returns {Filter}
       */

    }, {
      key: "_fromMatcher",
      value: function _fromMatcher(field, matcher, value) {
        return new Filter(_defineProperty({}, field, _defineProperty({}, matcher, value)));
      }
    }]);

    return Filter;
  }();

  /** @typedef {import('./services/searchservice').default} SearchService */

  /** @typedef {import('./services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./services/questionanswerservice').default} QuestionAnswerService */

  /**
   * Core is the main application container for all of the network and storage
   * related behaviors of the application.
   */

  var Core =
  /*#__PURE__*/
  function () {
    function Core() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Core);

      /**
       * A reference to the client API Key used for all requests
       * @type {string}
       * @private
       */
      this._apiKey = config.apiKey;
      /**
       * A reference to the client Answers Key used for all requests
       * @type {string}
       * @private
       */

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * A reference to the client locale used for all requests. If not specified, defaults to "en" (for
       * backwards compatibility).
       * @type {string}
       * @private
       */

      this._locale = config.locale;
      /**
       * A map of field formatters used to format results, if present
       * @type {Object.<string, function>}
       * @private
       */

      this._fieldFormatters = config.fieldFormatters || {};
      /**
       * A reference to the core data storage that powers the UI
       * @type {GlobalStorage}
       * @private
       */

      this.globalStorage = config.globalStorage;
      /**
       * A reference to the core persistent storage
       * @type {PersistentStorage}
       * @private
       */

      this.persistentStorage = config.persistentStorage;
      /**
       * An abstraction containing the integration with the RESTful search API
       * For both vertical and universal search
       * @type {SearchService}
       * @private
       */

      this._searcher = config.searchService;
      /**
       * An abstraction containing the integration with the RESTful autocomplete API
       * For filter search, vertical autocomplete, and universal autocomplete
       * @type {AutoCompleteService}
       * @private
       */

      this._autoComplete = config.autoCompleteService;
      /**
       * An abstraction for interacting with the Q&A rest interface
       * @type {QuestionAnswerService}
       * @private
       */

      this._questionAnswer = config.questionAnswerService;
    }
    /**
     * Search in the context of a vertical
     * @param {string} verticalKey vertical ID for the search
     * @param {object} query The query details
     * @param {string} query.input The input to search for
     * @param {string} query.filter The filter to use in the search
     * @param {string} query.facetFilter The facet filter to use in the search
     * @param {number} query.limit The max number of results to include, max of 50
     * @param {number} query.offset The results offset, for fetching more results of the same query
     * @param {string} query.id The query ID to use. If paging within a query, the same ID should be used
     * @param {boolean} query.append If true, adds the results of this query to the end of the current results, defaults false
     */


    _createClass(Core, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, query) {
        var _this = this;

        if (!query.append) {
          this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading());
          this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
          this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        }

        return this._searcher.verticalSearch(verticalKey, _objectSpread({
          limit: this.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit,
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION)
        }, query, {
          isDynamicFiltersEnabled: this._isDynamicFiltersEnabled,
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        })).then(function (response) {
          return SearchDataTransformer.transformVertical(response, _this._fieldFormatters);
        }).then(function (data) {
          _this.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          if (query.append) {
            var mergedResults = _this.globalStorage.getState(StorageKeys.VERTICAL_RESULTS).append(data[StorageKeys.VERTICAL_RESULTS]);

            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, mergedResults);
          } else {
            _this.globalStorage.set(StorageKeys.VERTICAL_RESULTS, data[StorageKeys.VERTICAL_RESULTS]);
          }

          if (data[StorageKeys.DYNAMIC_FILTERS]) {
            _this.globalStorage.set(StorageKeys.DYNAMIC_FILTERS, data[StorageKeys.DYNAMIC_FILTERS]);
          }

          if (data[StorageKeys.SPELL_CHECK]) {
            _this.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);
          }

          if (data[StorageKeys.LOCATION_BIAS]) {
            _this.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);
          }

          _this.globalStorage["delete"]('skipSpellCheck');

          _this.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Page within the results of the last query
       * @param {string} verticalKey The vertical key to use in the search
       * @param {number} offset The offset to use in the search
       */

    }, {
      key: "verticalPage",
      value: function verticalPage(verticalKey, offset) {
        var allFilters = this.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var facetFilter = this.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.verticalSearch(verticalKey, {
          input: this.globalStorage.getState(StorageKeys.QUERY),
          id: this.globalStorage.getState(StorageKeys.QUERY_ID),
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter),
          offset: offset
        });
      }
    }, {
      key: "search",
      value: function search(queryString, urls) {
        var _this2 = this;

        this.globalStorage.set(StorageKeys.DIRECT_ANSWER, {});
        this.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
        this.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, {});
        this.globalStorage.set(StorageKeys.SPELL_CHECK, {});
        this.globalStorage.set(StorageKeys.LOCATION_BIAS, {});
        return this._searcher.universalSearch(queryString, {
          geolocation: this.globalStorage.getState(StorageKeys.GEOLOCATION),
          skipSpellCheck: this.globalStorage.getState('skipSpellCheck'),
          queryTrigger: this.globalStorage.getState('queryTrigger'),
          sessionTrackingEnabled: this.globalStorage.getState(StorageKeys.SESSIONS_OPT_IN)
        }).then(function (response) {
          return SearchDataTransformer.transform(response, urls, _this2._fieldFormatters);
        }).then(function (data) {
          _this2.globalStorage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

          _this2.globalStorage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

          _this2.globalStorage.set(StorageKeys.DIRECT_ANSWER, data[StorageKeys.DIRECT_ANSWER]);

          _this2.globalStorage.set(StorageKeys.UNIVERSAL_RESULTS, data[StorageKeys.UNIVERSAL_RESULTS], urls);

          _this2.globalStorage.set(StorageKeys.INTENTS, data[StorageKeys.INTENTS]);

          _this2.globalStorage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);

          _this2.globalStorage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);

          _this2.globalStorage["delete"]('skipSpellCheck');

          _this2.globalStorage["delete"]('queryTrigger');
        });
      }
      /**
       * Given an input, query for a list of similar results and set into storage
       *
       * @param {string} input     the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       */

    }, {
      key: "autoCompleteUniversal",
      value: function autoCompleteUniversal(input, namespace) {
        var _this3 = this;

        return this._autoComplete.queryUniversal(input).then(function (data) {
          _this3.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);
        });
      }
      /**
       * Given an input, query for a list of similar results in the provided vertical
       * and set into storage
       *
       * @param {string} input       the string to autocomplete
       * @param {string} namespace the namespace to use for the storage key
       * @param {string} verticalKey the vertical key for the experience
       * @param {string} barKey      the bar key for the experience
       */

    }, {
      key: "autoCompleteVertical",
      value: function autoCompleteVertical(input, namespace, verticalKey, barKey) {
        var _this4 = this;

        return this._autoComplete.queryVertical(input, verticalKey, barKey).then(function (data) {
          _this4.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(namespace), data);
        });
      }
      /**
       * Given an input, provide a list of suitable filters for autocompletion
       *
       * @param {string} input  the string to search for filters with
       * @param {object} config  the config to serach for filters with
       * @param {string} config.namespace  the namespace to use for the storage key
       * @param {string} config.verticalKey the vertical key for the config
       * @param {string} config.barKey  the bar key for the config v1
       * @param {object} config.searchParameters  the search parameters for the config v2
       */

    }, {
      key: "autoCompleteFilter",
      value: function autoCompleteFilter(input, config) {
        var _this5 = this;

        return this._autoComplete.queryFilter(input, config).then(function (data) {
          _this5.globalStorage.set("".concat(StorageKeys.AUTOCOMPLETE, ".").concat(config.namespace), data);
        });
      }
      /**
       * Submits a question to the server and updates the underlying question model
       * @param {object} question The question object to submit to the server
       * @param {number} question.entityId The entity to associate with the question (required)
       * @param {string} question.lanuage The language of the question
       * @param {string} question.site The "publisher" of the (e.g. 'FIRST_PARTY')
       * @param {string} question.name The name of the author
       * @param {string} question.email The email address of the author
       * @param {string} question.questionText The question
       * @param {string} question.questionDescription Additional information about the question
       */

    }, {
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var _this6 = this;

        return this._questionAnswer.submitQuestion(question).then(function (data) {
          _this6.globalStorage.set(StorageKeys.QUESTION_SUBMISSION, QuestionSubmission.submitted());
        });
      }
      /**
       * Stores the given query into storage, to be used for the next search
       * @param {string} query the query to store
       */

    }, {
      key: "setQuery",
      value: function setQuery(query) {
        this.globalStorage.set(StorageKeys.QUERY, query);
      }
      /**
       * Stores the provided query ID, to be used in analytics
       * @param {string} queryId The query id to store
       */

    }, {
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this.globalStorage.set(StorageKeys.QUERY_ID, queryId);
      }
      /**
       * Stores the given filter into storage, to be used for the next search
       *
       * @param {string} namespace the namespace to use for the storage key
       * @param {Filter} filter    the filter to set
       */

    }, {
      key: "setFilter",
      value: function setFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "setFacetFilter",
      value: function setFacetFilter(namespace, filter) {
        this.globalStorage.set("".concat(StorageKeys.FACET_FILTER, ".").concat(namespace), filter);
      }
    }, {
      key: "enableDynamicFilters",
      value: function enableDynamicFilters() {
        this._isDynamicFiltersEnabled = true;
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        return this.globalStorage.on(evt, moduleId, cb);
      }
    }]);

    return Core;
  }();

  /** @module DOM */

  /* global HTMLElement, HTMLDocument, Window, Event */
  var document$1 = window.document;
  /**
   * Static interface for interacting with the DOM API.
   * @namespace
   */

  var DOM =
  /*#__PURE__*/
  function () {
    function DOM() {
      _classCallCheck(this, DOM);
    }

    _createClass(DOM, null, [{
      key: "setup",
      value: function setup(d, p) {
        document$1 = d;
      }
      /**
       * create a HTMLElement from and HTML string
       * @param {string} html The HTML to parse to a DOM node.
       * @return {HTMLElement}
       */

    }, {
      key: "create",
      value: function create(html) {
        if ('createRange' in document$1) {
          // prefer this implementation as it has wider browser support
          // and it's better performing.
          // see https://davidwalsh.name/convert-html-stings-dom-nodes
          var container = document$1.createElement('div');
          var frag = document$1.createRange().createContextualFragment(html);
          container.appendChild(frag);
          return container;
        } // fallback to this because of a bug in jsdom that causes tests to fail
        // see: https://github.com/jsdom/jsdom/issues/399


        return new DOMParser().parseFromString(html, 'text/html').body;
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {HTMLElement} the FIRST node it finds, if any
       */

    }, {
      key: "query",
      value: function query(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof Window || selector instanceof HTMLDocument) {
          return selector;
        }

        return parent.querySelector(selector);
      }
      /**
       * query the DOM for a given css selector
       * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
       * @param {string} selector the CSS selector to query for
       *
       * @returns {Array} the FIRST node it finds, if any
       */

    }, {
      key: "queryAll",
      value: function queryAll(parent, selector) {
        // Facade, shifting the selector to the parent argument if only one
        // argument is provided
        if (selector === undefined) {
          selector = parent;
          parent = document$1;
        } // handle the case where client code is using a pointer to a dom node and it's null, e.g. this._container


        if (parent == null) {
          parent = document$1;
        }

        if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof Window) {
          return [selector];
        }

        return Array.from(parent.querySelectorAll(selector));
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        if (document$1.readyState === 'complete' || document$1.readyState === 'loaded' || document$1.readyState === 'interactive') {
          cb();
          return;
        }

        DOM.on(document$1, 'DOMContentLoaded', cb);
      }
      /**
       * createEle will create a {HTMLElement} and apply the properties attributes through an object provided.
       * @param {string} el The element `tag` name to construct
       * @param {Object} opts_data Optional attributes to apply to the new HTMLElement
       */

    }, {
      key: "createEl",
      value: function createEl(el) {
        var opts_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var node = document$1.createElement(el);
        var props = Object.keys(opts_data);

        for (var i = 0; i < props.length; i++) {
          if (props[i] === 'class') {
            DOM.addClass(node, opts_data[props[i]]);
            continue;
          }

          node[props[i]] = opts_data[props[i]];
        }

        return node;
      }
    }, {
      key: "append",
      value: function append(parent, node) {
        if (node === undefined) {
          node = parent;
          parent = document$1;
        }

        if (typeof parent === 'string') {
          parent = DOM.query(parent);
        } // Support HTML injection as well as HTMLElement appends


        if (typeof node === 'string') {
          parent.insertAdjacentHTML('afterBegin', node);
        } else {
          parent.appendChild(node);
        }
      }
    }, {
      key: "addClass",
      value: function addClass(node, className) {
        if (!node) {
          return;
        }

        var classes = className.split(',');
        var len = classes.length;

        for (var i = 0; i < len; i++) {
          node.classList.add(classes[i]);
        }
      }
    }, {
      key: "empty",
      value: function empty(parent) {
        parent.innerHTML = '';
      }
    }, {
      key: "css",
      value: function css(selector, styles) {
        var node = DOM.query(selector);

        for (var prop in styles) {
          node.style[prop] = styles[prop];
        }
      }
    }, {
      key: "attr",
      value: function attr(selector, _attr, val) {
        DOM.query(selector).setAttribute(_attr, val);
      }
    }, {
      key: "attributes",
      value: function attributes(selector, attrs) {
        var _this = this;

        Object.entries(attrs).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              attr = _ref2[0],
              val = _ref2[1];

          return _this.attr(selector, attr, val);
        });
      }
    }, {
      key: "trigger",
      value: function trigger(selector, event, settings) {
        var e = new Event(event, Object.assign({
          'bubbles': true,
          'cancelable': true
        }, settings || {}));
        DOM.query(selector).dispatchEvent(e);
      }
    }, {
      key: "on",
      value: function on(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler);
      }
    }, {
      key: "once",
      value: function once(selector, evt, handler) {
        DOM.query(selector).addEventListener(evt, handler, {
          once: true
        });
      }
    }, {
      key: "off",
      value: function off(selector, evt, handler) {
        DOM.query(selector).removeEventListener(evt, handler);
      }
    }, {
      key: "delegate",
      value: function delegate(ctxt, selector, evt, handler) {
        var el = DOM.query(ctxt);
        el.addEventListener(evt, function (event) {
          var target = event.target;

          while (!target.isEqualNode(el)) {
            if (target.matches(selector)) {
              handler(event, target);
              break;
            }

            target = target.parentNode;
          }
        });
      }
    }]);

    return DOM;
  }();

  /** @module SearchParams */

  /* global window */

  /**
   * SearchParams is a class to get the search params in a URL.
   * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
   */
  var SearchParams =
  /*#__PURE__*/
  function () {
    function SearchParams(url) {
      _classCallCheck(this, SearchParams);

      /**
       * Mapping of all query parameters in the given url, query param -> value
       * Only used if URLSearchParams does not exist in the window
       * @type {Object}
       * @private
       */
      this._params = {};

      if (window && window.URLSearchParams) {
        return new URLSearchParams(url);
      } else {
        this._params = this.parse(url);
      }
    }
    /**
     * parse creates a mapping of all query params in a given url
     * The query param values are decoded before being put in the map
     * Three types of input are supported
     *   (1) full URL e.g. http://www.yext.com/?q=hello
     *   (2) params with ? e.g. ?q=hello
     *   (1) params without ? e.g. q=hello
     * @param {string} url The url
     * @returns {Object} mapping from query param -> value where value is '' if no value is provided
     */


    _createClass(SearchParams, [{
      key: "parse",
      value: function parse(url) {
        var params = {};
        var search = url;

        if (search === '') {
          return params;
        } // Normalize all url inputs to string of query params separated by &


        if (url.indexOf('?') > -1) {
          search = url.slice(url.indexOf('?') + 1);
        }

        var encodedParams = search.split('&');

        for (var i = 0; i < encodedParams.length; i++) {
          var keyVal = encodedParams[i].split('=');

          if (keyVal.length > 1) {
            params[keyVal[0]] = SearchParams.decode(keyVal[1]);
          } else {
            params[keyVal[0]] = '';
          }
        }

        return params;
      }
      /**
       * get returns the value of the given query param
       * @param {string} query the query param key to get the value of
       * @return {string} param value, null otherwise
       */

    }, {
      key: "get",
      value: function get(query) {
        if (typeof this._params[String(query)] === 'undefined') {
          return null;
        }

        return this._params[query];
      }
      /**
       * set changes the value of a given query param
       * @param {string} name the query param key
       * @param {string} value the value of the query param update with
       */

    }, {
      key: "set",
      value: function set(name, value) {
        this._params[String(name)] = String(value);
      }
      /**
       * has checks to see if the given query param key exists in the params object
       * @param {string} query the query param to check
       * @return {boolean} true if the query param is in the params object, false o/w
       */

    }, {
      key: "has",
      value: function has(query) {
        return query in this._params;
      }
      /**
       * toString returns a url with all the query params in the params object (without a ?)
       * @return {string}
       */

    }, {
      key: "toString",
      value: function toString() {
        var string = [];

        for (var key in this._params) {
          string.push("".concat(key, "=").concat(SearchParams.encode(this._params[key])));
        }

        return string.join('&');
      }
    }, {
      key: "entries",
      value: function entries() {
        var entries = [];

        for (var key in this._params) {
          entries.push([key, this._params[key]]);
        }

        return entries;
      }
      /**
       * decode returns the decoded representation of the given string
       * @param {string} string the string to decode
       * @return {string}
       */

    }], [{
      key: "decode",
      value: function decode(string) {
        return decodeURIComponent(string.replace(/[ +]/g, '%20'));
      }
      /**
       * decode returns the encoded representation of the given string (e.g. + -> %2B)
       * @param {string} string the string to encode
       * @return {string}
       */

    }, {
      key: "encode",
      value: function encode(string) {
        var replace = {
          '!': '%21',
          "'": '%27',
          '(': '%28',
          ')': '%29',
          '%20': '+'
        };
        return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
          return replace[match];
        });
      }
    }]);

    return SearchParams;
  }();

  /** @module Renderer */

  /**
   * Renderer is an abstract class that all Renderers should extend and implement
   */
  var Renderer =
  /*#__PURE__*/
  function () {
    function Renderer() {
      _classCallCheck(this, Renderer);
    }

    _createClass(Renderer, [{
      key: "render",

      /**
       * render is a core method for all renderers.
       * All implementations should override this class
       * @param {string} template
       * @param {object} data
       */
      value: function render(template, data) {
        return template;
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {}
    }, {
      key: "compile",
      value: function compile(template) {}
    }]);

    return Renderer;
  }();

  /**
   * HandlebarsRenderer is a wrapper around the nativate handlebars renderer.
   * @extends Renderer
   */

  var HandlebarsRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    _inherits(HandlebarsRenderer, _Renderer);

    function HandlebarsRenderer() {
      var _this;

      var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, HandlebarsRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(HandlebarsRenderer).call(this));
      /**
       * A local reference to the handlebars compiler
       * @type {Handlebars}
       * @private
       */

      _this._handlebars = templates._hb || null;
      /**
       * A local reference to the pre-compiled handlebars templates
       * @type {Handlebars}
       * @private
       */

      _this._templates = templates || {};
      return _this;
    }

    _createClass(HandlebarsRenderer, [{
      key: "init",
      value: function init(templates) {
        // Assign the handlebars compiler and templates based on
        // information provided from external dep (in default case, it comes from external server request)
        this._handlebars = templates._hb;
        this._templates = templates; // TODO(billy) Once we re-write templates using the new helpers library
        // we probably don't need these custom helpers anymore

        this._registerCustomHelpers();
      }
      /**
       * registerHelper is a public interface for external dependencies to
       * register their own custom helpers to our internal Handlebars Compiler
       */

    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this._handlebars.registerHelper(name, cb);
      }
      /**
       * compile a handlebars template so that it can be rendered,
       * using the {Handlebars} compiler
       * @param {string} template The template string to compile
       */

    }, {
      key: "compile",
      value: function compile(template) {
        if (typeof template !== 'string') {
          return '';
        }

        return this._handlebars.compile(template);
      }
      /**
       * render will render a template with data
       * @param {Object} config Provide either a templateName or a pre-compiled template
       * @param {Object} data The data to provide to the template
       */

    }, {
      key: "render",
      value: function render(config, data) {
        // If a custom template is provided, use it,
        // otherwise fall back to the template name
        // TODO(billy) This interface should probably be less ugly
        if (config.template !== null) {
          return config.template(data);
        }

        try {
          return this._templates[config.templateName](data);
        } catch (e) {
          throw new Error('Can not find/render template: ' + config.templateName, e);
        }
      }
    }, {
      key: "_registerCustomHelpers",
      value: function _registerCustomHelpers() {
        this.registerHelper('ifeq', function (arg1, arg2, options) {
          return arg1 === arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('ifnoteq', function (arg1, arg2, options) {
          return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
        });
        this.registerHelper('formatPhoneNumber', function (phoneNumberString) {
          var cleaned = ('' + phoneNumberString).replace(/\D/g, '');
          var match = cleaned.match(/^(1|)?(\d{3})(\d{3})(\d{4})$/);

          if (match) {
            var intlCode = match[1] ? '+1 ' : '';
            return [intlCode, '(', match[2], ') ', match[3], '-', match[4]].join('');
          }

          return null;
        });
        this.registerHelper('assign', function (name, value, options) {
          var args = arguments;
          options = args[args.length - 1];

          if (!options.data.root) {
            options.data.root = {};
          }

          var v = '';

          for (var i = 1; i < args.length - 1; i++) {
            v = v + args[i];
          }

          options.data.root[name] = v;
        });
        this.registerHelper('json', function (name, value, options) {
          return name === undefined ? '' : JSON.stringify(name);
        });
      }
    }]);

    return HandlebarsRenderer;
  }(Renderer);

  /** @module */
  // E.g. Mustache, SOY, HandleBars, React, etc.

  var Renderers = {
    SOY: Renderer,
    Handlebars: HandlebarsRenderer
  };

  /** @module */

  /** The current lib version, reported with errors and analytics */
  var LIB_VERSION = 'v0.11.0';
  /** The base url for the live api backend */

  var LIVE_API_BASE_URL = 'https://liveapi.yext.com';
  /** The base url for the knowledge api backend */

  var API_BASE_URL = 'https://api.yext.com';
  /** The default url for compiled component templates */

  var COMPILED_TEMPLATES_URL = "https://assets.sitescdn.net/answers/".concat(LIB_VERSION, "/answerstemplates.compiled.min.js");
  /** The base urls for the analytics backend  */

  var ANALYTICS_BASE_URL = 'https://realtimeanalytics.yext.com';
  var ANALYTICS_BASE_URL_NO_COOKIE = 'https://answers.yext-pixel.com';

  /**
   * TemplateLoader exposes an interface for loading templates asynchronously
   * from the server and registers them with the proper renderer.
   * It also allows you to assign them synchronously.
   */

  var TemplateLoader =
  /*#__PURE__*/
  function () {
    function TemplateLoader(config) {
      _classCallCheck(this, TemplateLoader);

      if (!TemplateLoader.setInstance(this)) {
        return TemplateLoader.getInstance();
      }
      /**
       * The template url to fetch compiled templates from
       * @type {string}
       * @private
       */


      this._templateUrl = config.templateUrl || COMPILED_TEMPLATES_URL;
      this._templates = {};

      this._onLoaded = function () {};

      this._init();
    }

    _createClass(TemplateLoader, [{
      key: "_init",
      value: function _init() {
        this.fetchTemplates();
      }
    }, {
      key: "fetchTemplates",
      value: function fetchTemplates() {
        var _this = this;

        // If we already have templates loaded, do nothing
        var node = DOM.query('#yext-answers-templates');

        if (node) {
          return;
        } // Inject a script to fetch the compiled templates,
        // wrapping it a Promise for cleanliness


        new Promise(function (resolve, reject) {
          var script = DOM.createEl('script', {
            id: 'yext-answers-templates',
            onload: resolve,
            onerror: reject,
            async: true,
            src: _this._templateUrl
          });
          DOM.append('body', script);
        }).then(function (response) {
          // TODO(billy) Implmenet error handling here (e.g. request could fail)
          console.log('Templates loaded successfully!');
        });
        return this;
      }
      /**
       * register the templates internally so that they can be later consumed
       * (e.g. by components and renderers) with convienience.
       *
       * `fetchTemplates` will automatically call this, providing the compiled templates from the server.
       */

    }, {
      key: "register",
      value: function register(templates) {
        this._templates = templates; // Notify our consumers that the templates are here :)

        this._onLoaded(this._templates);

        return this;
      }
    }, {
      key: "onLoaded",
      value: function onLoaded(cb) {
        this._onLoaded = cb;
        return this;
      }
    }, {
      key: "get",
      value: function get(templateName) {
        return this._templates[templateName];
      }
      /**
       * @return The internal template collection
       */

    }, {
      key: "getTemplates",
      value: function getTemplates() {
        return this._templates;
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return TemplateLoader;
  }();

  /** @module */

  /** @module EventEmitter */

  /**
   * EventEmitter is a base class for any object that wants to expose
   * a pub/sub interface, for emitting messages and providing listeners.
   */
  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      /**
       * The subscribers of messages
       * @type {object[]}
       * @private
       */
      this._listeners = {};
    }
    /**
     * on is the public interface for subscribing events that are emitted.
     * @param {string} evt the event name to listen to
     * @param {function} cb The callback to invoke when the {evt} is emitted
     * @param {boolean} once Optional value which will only handle the message once
     */


    _createClass(EventEmitter, [{
      key: "on",
      value: function on(evt, cb, once) {
        if (typeof cb !== 'function') {
          throw new Error('callback handler should be of type {function}');
        }

        if (this._listeners[evt] === undefined) {
          this._listeners[evt] = [];
        }

        this._listeners[evt].push({
          event: evt,
          cb: cb,
          once: once || false
        });

        return this;
      }
      /**
       * once is the public interface for subscribing events that are emitted.
       * The handler will only be triggered once.
       *
       * @param {string} evt the event name to listen to
       * @param {function} cb The callback to invoke when the {evt} is emitted
       * @param {boolean} once Optional value which will only handle the message once
       */

    }, {
      key: "once",
      value: function once(evt, cb) {
        return this.on(evt, cb, true);
      }
      /**
       * off is the public interface for unsubscribing from an event
       * @param {string} evt the event name to unsubscribe from
       */

    }, {
      key: "off",
      value: function off(evt) {
        delete this._listeners[evt];
        return this;
      }
      /**
       * emit is the public interface for broadcasting messages/events
       * @param {string} evt the event name to publish from
       * @param {Object} data the data to send along to the subscribers
       */

    }, {
      key: "emit",
      value: function emit(evt, data) {
        var listeners = this._listeners[evt];

        if (listeners === undefined) {
          return;
        } // Invoke each of all the listener handlers and remove the ones that should fire only once.


        var keep = [];

        for (var i = 0; i < listeners.length; i++) {
          listeners[i].cb(data);

          if (listeners[i].once === true) {
            continue;
          } // Instead of having a 'dirty' array with deleted or 'undefined' entries,
          // we just create a brand new array without the listeners that were removed


          keep.push(listeners[i]);
        } // Update our old list of listeners to the newly created array


        this._listeners[evt] = keep;
        return this;
      }
    }]);

    return EventEmitter;
  }();

  /**
   * State contains the data for the component
   * and exposes an {EventEmitter} interface so that external
   * dependencies can listen/hook subscribe to messages/updates.
   * @extends EventEmitter
   */

  var State =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(State, _EventEmitter);

    function State(data) {
      var _this;

      _classCallCheck(this, State);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(State).call(this));
      /**
       * The initial state of the component
       * @type {Object}
       * @private
       */

      _this._state = data || {};
      return _this;
    }
    /**
     * Set the initial state of the component.
     * NOTE(billy): Does not fire an update message
     */


    _createClass(State, [{
      key: "init",
      value: function init(prop, optVal) {
        this._set(prop, optVal);
      }
      /**
       * setter for the state
       * @param prop {string|Object} The property to set
       * @param optVal Optional, if prop is a {string}, it will assign the value to that property
       */

    }, {
      key: "set",
      value: function set(prop, optVal) {
        this._set(prop, optVal);

        this.emit('update');
      }
      /**
       * setter for the state enables you to update a single property, or complete state
       * depending on the arguments provided.
       * @param prop {string|Object} The property to set
       * @param optVal If prop is a {string}, provide its value
       * @private
       */

    }, {
      key: "_set",
      value: function _set(prop, optVal) {
        if (optVal === undefined) {
          this._state = prop;
        } else {
          this._state[prop] = optVal;
        }
      }
    }, {
      key: "update",
      value: function update(data) {
        this._state = data;
        this.emit('update');
      }
      /**
       * Retrieve a properties value from the state
       * If no property provided, return the full state
       * @param {string} optProp optional property to retrieve
       */

    }, {
      key: "get",
      value: function get(optProp) {
        if (optProp === undefined) {
          return this._state;
        }

        return this._state[optProp];
      }
    }, {
      key: "has",
      value: function has(prop) {
        return this._state[prop] !== undefined;
      }
    }, {
      key: "asJSON",
      value: function asJSON() {
        return this._state;
      }
    }]);

    return State;
  }(EventEmitter);

  /** @module HttpRequester */

  /* global fetch */

  /**
   * Types of HTTP requests
   */
  var Methods = {
    GET: 'get',
    POST: 'post',
    PUT: 'put',
    DELETE: 'delete'
  };
  /**
   * HttpRequester is a wrapper around the native implementation of AJAX
   * related matters. It's used to make all types of network requests
   * and exposes a promise interface.
   */

  var HttpRequester =
  /*#__PURE__*/
  function () {
    function HttpRequester() {
      _classCallCheck(this, HttpRequester);
    }

    _createClass(HttpRequester, [{
      key: "get",

      /**
       * Create a GET HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} data The data to provide (gets encoded into the URL)
       * @param {Object} opts Configuration options to use for the request
       */
      value: function get(url, data, opts) {
        return this.request(Methods.GET, this.encodeParams(url, data), opts);
      }
      /**
       * Create a POST HTTP request
       * @param {string} url The url to make a request to
       * @param {Object} urlParams The params to encode into the URL
       * @param {Object} jsonBody The request body (json) to provide with the POST request
       * @param {Object} requestConfig Configuration options to use for the request
       */

    }, {
      key: "post",
      value: function post(url, urlParams, jsonBody, requestConfig) {
        return this.request(Methods.POST, this.encodeParams(url, urlParams), Object.assign({}, {
          body: JSON.stringify(jsonBody),
          credentials: undefined
        }, requestConfig));
      }
    }, {
      key: "request",
      value: function request(method, url, opts) {
        var reqArgs = Object.assign({}, {
          'method': method,
          'credentials': 'include'
        }, opts);
        return fetch(url, reqArgs);
      }
      /**
       * Send a beacon to the provided url which will send a non-blocking request
       * to the server that is guaranteed to send before page load. No response is returned,
       * so beacons are primarily used for analytics reporting.
       * @param {string} url The url to send the beacon to
       * @param {object} data The data payload to send in the beacon
       * @return {boolean} true if the request is successfully queued
       */

    }, {
      key: "beacon",
      value: function beacon(url, data) {
        return navigator.sendBeacon(url, JSON.stringify(data));
      }
    }, {
      key: "encodeParams",
      value: function encodeParams(url, params) {
        if (_typeof(params) !== 'object') {
          return;
        }

        var hasParam = url.indexOf('?') > -1;
        var searchQuery = '';

        for (var key in params) {
          if (!hasParam) {
            hasParam = true;
            searchQuery += '?';
          } else {
            searchQuery += '&';
          }

          searchQuery += key + '=' + encodeURIComponent(params[key]);
        }

        return url + searchQuery;
      }
    }]);

    return HttpRequester;
  }();

  /**
   * ApiRequest is the base class for all API requests.
   * It defines all of the core properties required to make a request
   */

  var ApiRequest =
  /*#__PURE__*/
  function () {
    function ApiRequest() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, ApiRequest);

      /**
       * An abstraction used for making network request and handling errors
       * @type {HttpRequester}
       * @private
       */
      this._requester = new HttpRequester();
      /**
       * The baseUrl to use for making a request
       * @type {string}
       * @private
       */

      this._baseUrl = opts.baseUrl || LIVE_API_BASE_URL;
      /**
       * The endpoint to use in the url (appended to the {baseUrl})
       * @type {string}
       * @private
       */

      this._endpoint = opts.endpoint || null;
      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */

      this._apiKey = opts.apiKey || null;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = opts.version || 20190101;
      /**
       * Additional data params that are sent along with the request
       * @type {string}
       * @private
       */

      this._params = opts.params || {};
    }
    /**
     * get creates a new `GET` request to the server using the configuration of the request class
     * @returns {Promise<Response>}
     */


    _createClass(ApiRequest, [{
      key: "get",
      value: function get() {
        return this._requester.get(this._baseUrl + this._endpoint, Object.assign({}, this.baseParams(), this.sanitizeParams(this._params)));
      }
      /**
       * @param {Object} opts
       * @returns {Promise<Response>}
       */

    }, {
      key: "post",
      value: function post(opts) {
        return this._requester.post(this._baseUrl + this._endpoint, this.baseParams()
        /* urlParams */
        , this.sanitizeParams(this._params)
        /* jsonBody */
        , opts
        /* requestConfig */
        );
      }
      /**
       * @returns {Object}
       * @private
       */

    }, {
      key: "baseParams",
      value: function baseParams() {
        var baseParams = {
          'v': this._version,
          'api_key': this._apiKey,
          'jsLibVersion': LIB_VERSION
        };
        var urlParams = new SearchParams(window.location.search.substring(1));

        if (urlParams.has('beta')) {
          baseParams['beta'] = urlParams.get('beta');
        }

        return baseParams;
      }
    }, {
      key: "sanitizeParams",
      value: function sanitizeParams() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Remove any paramaters whos value is `undefined`.
        //
        // NOTE(billy) Probably better to be explicit about how to handle this at the request building level,
        // but I can't see any cases where we'd ever want to send 'undefined' as a value to the server.
        // So it's probably fine to 'clean' the params object here
        Object.keys(params).forEach(function (key) {
          if (params[key] === undefined || params[key] === null) {
            delete params[key];
          }
        });
        return params;
      }
    }]);

    return ApiRequest;
  }();

  /**
   * SearchApi is the API for doing various types of search
   * over the network (e.g. vertical or universal)
   *
   * @implements {SearchService}
   */

  var SearchApi =
  /*#__PURE__*/
  function () {
    function SearchApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchApi);

      /**
       * A local reference to the API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'Search');
      }

      this._apiKey = config.apiKey;
      /**
       * A local reference to the Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'Search');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * A local reference to the locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'Search');
      }

      this._locale = config.locale;
    }
    /** @inheritdoc */


    _createClass(SearchApi, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger,
            sessionTrackingEnabled = _ref.sessionTrackingEnabled;

        if (limit > 50) {
          throw new AnswersCoreError('Provided search limit unsupported', 'SearchApi');
        }

        var request = new ApiRequest({
          endpoint: '/v2/accounts/me/answers/vertical/query',
          apiKey: this._apiKey,
          version: this._version,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'filters': filter,
            'facetFilters': facetFilter,
            'verticalKey': verticalKey,
            'limit': limit,
            'offset': offset,
            'location': geolocation ? "".concat(geolocation.lat, ",").concat(geolocation.lng) : null,
            'radius': geolocation ? geolocation.radius : null,
            'queryId': id,
            'retrieveFacets': isDynamicFiltersEnabled,
            'locale': this._locale,
            'skipSpellCheck': skipSpellCheck,
            'queryTrigger': queryTrigger,
            'sessionTrackingEnabled': sessionTrackingEnabled
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        var request = new ApiRequest({
          endpoint: '/v2/accounts/me/answers/query',
          apiKey: this._apiKey,
          version: this._version,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'location': params.geolocation ? "".concat(params.geolocation.lat, ",").concat(params.geolocation.lng) : null,
            'radius': params.geolocation ? params.geolocation.radius : null,
            'version': this._experienceVersion,
            'locale': this._locale,
            'skipSpellCheck': params.skipSpellCheck,
            'queryTrigger': params.queryTrigger,
            'sessionTrackingEnabled': params.sessionTrackingEnabled
          }
        });
        return request.get().then(function (response) {
          return response.json();
        });
      }
    }]);

    return SearchApi;
  }();

  /**
   * Model for the analytics event type
   */
  var AnalyticsEvent =
  /*#__PURE__*/
  function () {
    function AnalyticsEvent(type, label) {
      _classCallCheck(this, AnalyticsEvent);

      /**
       * The type of event to report
       * @type {string}
       */
      this.eventType = type.toUpperCase();
      /**
       * An optional label to be provided for the event
       * @type {string}
       */

      if (label) {
        this.label = label;
      }
    }
    /**
     * Adds the provided options to the event
     * @param {object} options Additional options for the event
     */


    _createClass(AnalyticsEvent, [{
      key: "addOptions",
      value: function addOptions(options) {
        Object.assign(this, options);
        return this;
      }
      /**
       * Return the event in the api format, typically for reporting to the api
       */

    }, {
      key: "toApiEvent",
      value: function toApiEvent() {
        return Object.assign({}, this);
      }
    }]);

    return AnalyticsEvent;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * Class for reporting analytics events to the server via HTTP
   *
   * @implements {AnalyticsReporterService}
   */

  var AnalyticsReporter =
  /*#__PURE__*/
  function () {
    function AnalyticsReporter(core, experienceKey, experienceVersion, businessId) {
      var _this = this;

      var globalOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      _classCallCheck(this, AnalyticsReporter);

      /**
       * The internal business identifier used for reporting
       * @type {number}
       */
      this._businessId = businessId;
      /**
       * Options to include with every analytic event reported to the server
       * @type {object}
       * @private
       */

      this._globalOptions = Object.assign({}, globalOptions, {
        experienceKey: experienceKey
      });
      /**
       * Base URL for the analytics API
       * @type {string}
       * @private
       */

      this._baseUrl = ANALYTICS_BASE_URL_NO_COOKIE;

      if (experienceVersion) {
        this._globalOptions.experienceVersion = experienceVersion;
      } // listen to query id updates


      core.globalStorage.on('update', StorageKeys.QUERY_ID, function (id) {
        return _this.setQueryId(id);
      });
    }

    _createClass(AnalyticsReporter, [{
      key: "setQueryId",
      value: function setQueryId(queryId) {
        this._globalOptions.queryId = queryId;
      }
      /** @inheritdoc */

    }, {
      key: "report",
      value: function report(event) {
        if (!(event instanceof AnalyticsEvent)) {
          throw new AnswersAnalyticsError('Tried to send invalid analytics event', event);
        }

        event.addOptions(this._globalOptions);
        return new HttpRequester().beacon("".concat(this._baseUrl, "/realtimeanalytics/data/answers/").concat(this._businessId), {
          'data': event.toApiEvent()
        });
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {
        this._baseUrl = isEnabled ? ANALYTICS_BASE_URL : ANALYTICS_BASE_URL_NO_COOKIE;
      }
    }]);

    return AnalyticsReporter;
  }();

  /** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @implements {AnalyticsReporterService}
   */
  var NoopAnalyticsReporter =
  /*#__PURE__*/
  function () {
    function NoopAnalyticsReporter() {
      _classCallCheck(this, NoopAnalyticsReporter);
    }

    _createClass(NoopAnalyticsReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(event) {
        return true;
      }
      /** @inheritdoc */

    }, {
      key: "setConversionTrackingEnabled",
      value: function setConversionTrackingEnabled(isEnabled) {}
    }]);

    return NoopAnalyticsReporter;
  }();

  /**
   * ModuleData is used as a generic model for Storage.
   * Typically an instance of ModuleData powers a single component.

   * A data model that exposes an event emitter interface.
   * @extends EventEmitter
   */

  var ModuleData =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(ModuleData, _EventEmitter);

    function ModuleData(id) {
      var _this;

      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ModuleData);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ModuleData).call(this));
      _this._id = id;
      _this._history = [];
      _this._data = data;

      _this.set(data);

      return _this;
    }
    /**
     * replaces the currently held data with the given data
     * @param {*} data the data to replace the current data
     */


    _createClass(ModuleData, [{
      key: "set",
      value: function set(data) {
        this.capturePrevious();

        if (_typeof(data) !== 'object' || Array.isArray(data) || Object.keys(data).length !== Object.keys(this._data).length) {
          this._data = data;
          this.emit('update', this._data);
          return;
        } // check for shallow equality


        for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];

          if (this._data[key] !== data[key]) {
            this._data = data;
            this.emit('update', this._data);
            return;
          }
        }
      }
    }, {
      key: "capturePrevious",
      value: function capturePrevious() {
        if (this._history === undefined) {
          this._history = [];
        }

        if (this._history.length + 1 > 5) {
          this._history.shift();
        } // If data is ever undefined, we default to empty object


        this._history.push(JSON.stringify(this._data || {}));
      }
    }, {
      key: "undo",
      value: function undo() {
        var previous = {};

        if (this._previous.length > 0) {
          previous = JSON.parse(this._previous.pop());
        }

        this._data.set(previous);
      }
    }, {
      key: "raw",
      value: function raw() {
        return this._data;
      }
    }]);

    return ModuleData;
  }(EventEmitter);

  /**
   * Storage is a container around application state.
   * It exposes an interface for CRUD operations as well as listening
   * for stateful changes.
   */

  var GlobalStorage =
  /*#__PURE__*/
  function () {
    function GlobalStorage() {
      _classCallCheck(this, GlobalStorage);

      this._moduleDataContainer = {};
      this._futureListeners = {};
    }
    /**
     * Set the data in storage with the given key to the provided data,
     * completely overwriting any existing data.
     * @param {string} key the storage key to set
     * @param {*} data the data to set
     */


    _createClass(GlobalStorage, [{
      key: "set",
      value: function set(key, data) {
        this._initDataContainer(key, data);

        this._moduleDataContainer[key].set(data);
      }
      /**
       * Add all key/value pairs in the provided map to the storage
       * @param {*} data The key/value pairs to set in the storage
       */

    }, {
      key: "setAll",
      value: function setAll(data) {
        for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              val = _Object$entries$_i[1];

          if (key === StorageKeys.QUERY) {
            continue;
          }

          this.set(key, val);
        } // Update query last since it triggers a search
        // TODO: move listeners up so all of storage can be updated at the same time


        if (data[StorageKeys.QUERY]) {
          this.set(StorageKeys.QUERY, data[StorageKeys.QUERY]);
        }
      }
    }, {
      key: "_initDataContainer",
      value: function _initDataContainer(key, data) {
        if (key === undefined || key === null || typeof key !== 'string') {
          throw new AnswersStorageError('Invalid storage key provided', key, data);
        }

        if (data === undefined || data === null) {
          throw new AnswersStorageError('No data provided', key, data);
        }

        if (this._moduleDataContainer[key] === undefined) {
          this._moduleDataContainer[key] = new ModuleData(key);

          this._applyFutureListeners(key);
        }
      }
    }, {
      key: "getState",
      value: function getState(moduleId) {
        if (this._moduleDataContainer[moduleId]) {
          return this._moduleDataContainer[moduleId].raw();
        }

        return null;
      }
    }, {
      key: "getAll",
      value: function getAll(key) {
        var data = [];

        for (var _i2 = 0, _Object$keys = Object.keys(this._moduleDataContainer); _i2 < _Object$keys.length; _i2++) {
          var dataKey = _Object$keys[_i2];

          if (dataKey.startsWith(key) && this._moduleDataContainer[dataKey].raw() !== null) {
            data.push(this._moduleDataContainer[dataKey].raw());
          }
        }

        return data;
      }
      /**
       * Remove the data in storage with the given key to the provided data,
       * @param {string} key the storage key to delete
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        // Note: Do we need to clean up listeners here?
        delete this._moduleDataContainer[key];
      }
    }, {
      key: "on",
      value: function on(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] === undefined) {
            this._futureListeners[moduleId] = [];
          }

          this._futureListeners[moduleId].push({
            event: evt,
            cb: cb
          });

          return;
        }

        this._moduleDataContainer[moduleId].on(evt, cb);

        return this;
      }
    }, {
      key: "off",
      value: function off(evt, moduleId, cb) {
        var moduleData = this._moduleDataContainer[moduleId];

        if (moduleData === undefined) {
          if (this._futureListeners[moduleId] !== undefined) {
            this._futureListeners[moduleId].pop();
          }

          return this;
        }

        this._moduleDataContainer[moduleId].off(evt, cb);

        return this;
      }
    }, {
      key: "_applyFutureListeners",
      value: function _applyFutureListeners(moduleId) {
        var futures = this._futureListeners[moduleId];

        if (!futures) {
          return;
        }

        for (var i = 0; i < futures.length; i++) {
          var future = futures[i];
          this.on(future.event, moduleId, future.cb);
        }

        delete this._futureListeners[moduleId];
      }
    }]);

    return GlobalStorage;
  }();

  /** @module */

  /**
   * Component is an abstraction that encapsulates state, behavior,
   * and view for a particular chunk of functionality on the page.
   *
   * The API exposes event life cycle hooks for when things are rendered,
   * mounted, created, etc.
   */

  var Component =
  /*#__PURE__*/
  function () {
    function Component() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Component);

      this.moduleId = null;
      /**
       * Unique name of this component instance
       * Used to distinguish between other components of the same type
       * @type {String}
       */

      this.name = config.name || this.constructor.type;
      /**
       * Cache the options so that we can propogate properly to child components
       * @type {Object}
       */

      this._config = config;
      /**
       * An identifier used to classify the type of component.
       * The component manager uses this information in order to persist and organize components
       * @type {string|ComponentType}
       */

      this._type = this.constructor.name;
      /**
       * A local reference to the parent component, if exists
       * @type {Component}
       */

      this._parentContainer = config.parentContainer || null;
      /**
       * A container for all the child components
       * @type {Component[]}
       */

      this._children = [];
      /**
       * The state (data) of the component to be provided to the template for rendering
       * @type {object}
       */

      this._state = new State(config.state);
      /**
       * TODO(billy) This should be 'services'
       */

      this.core = systemConfig.core || null;
      /**
       * A local reference to the component manager, which contains all of the component classes
       * eligible to be created
       * @type {ComponentManager}
       */

      this.componentManager = systemConfig.componentManager || null;
      /**
       * A local reference to the analytics reporter, used to report events for this component
       * @type {AnalyticsReporter}
       */

      this.analyticsReporter = systemConfig.analyticsReporter || null;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      this._analyticsOptions = config.analyticsOptions || {};
      /**
       * A reference to the DOM node that the component will be appended to when mounted/rendered.
       * @type {HTMLElement}
       */

      if (this._parentContainer === null) {
        if (typeof config.container === 'string') {
          this._container = DOM.query(config.container) || null;

          if (this._container === null) {
            throw new Error('Cannot find container DOM node: ' + config.container);
          }
        }
      } else {
        this._container = DOM.query(this._parentContainer, config.container); // If we have a parent, and the container is missing from the DOM,
        // we construct the container and append it to the parent

        if (this._container === null) {
          this._container = DOM.createEl('div', {
            "class": config.container.substring(1, config.container.length)
          });
          DOM.append(this._parentContainer, this._container);
        }
      }
      /**
       * A custom class to be applied to {this._container} node
       * @type {string}
       */


      this._className = config["class"] || 'component';
      /**
       * A custom render function to be used instead of using the default renderer
       * @type {Renderer}
       */

      this._render = config.render || null;
      /**
       * A local reference to the default {Renderer} that will be used for rendering the template
       * @type {Renderer}
       */

      this._renderer = systemConfig.renderer || Renderers.Handlebars;
      /**
       * The template string to use for rendering the component
       * If this is left empty, we lookup the template the base templates using the templateName
       * @type {string}
       */

      this._template = config.template ? this._renderer.compile(config.template) : null;
      /**
       * The templateName to use for rendering the component.
       * This is only used if _template is empty.
       * @type {string}
       */

      this._templateName = config.templateName || this.constructor.defaultTemplateName(config);
      /**
       * An internal state indicating whether or not the component has been mounted to the DOM
       * @type {boolean}
       */

      this._isMounted = false;
      /**
       * A local reference to the callback, thats used to transform the internal data
       * models of the components, before it gets applied to the component state.
       * By default, no transformation happens.
       * @type {function}
       */

      this.transformData = config.transformData || this.transformData || function () {};
      /**
       * The a local reference to the callback that will be invoked when a component is created.
       * @type {function}
       */


      this.onCreate = config.onCreateOverride || this.onCreate || function () {};

      this.onCreate = this.onCreate.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a component is Mounted.
       * @type {function}
       */

      this.onMount = config.onMountOverride || this.onMount || function () {};

      this.onMount = this.onMount.bind(this);
      /**
       * The a local reference to the callback that will be invoked when a components state is updated.
       * @type {function}
       */

      this.onUpdate = config.onUpdateOverride || this.onUpdate || function () {};

      this.onUpdate = this.onUpdate.bind(this);
      /**
       * A user provided onCreate callback
       * @type {function}
       */

      this.userOnCreate = config.onCreate || function () {};
      /**
       * A user provided onMount callback
       * @type {function}
       */


      this.userOnMount = config.onMount || function () {};
      /**
       * A user provided onUpdate callback
       * @type {function}
       */


      this.userOnUpdate = config.onUpdate || function () {};
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(Component, [{
      key: "init",
      value: function init(opts) {
        var _this = this;

        try {
          this.setState(opts.data || opts.state || {});
          this.onCreate();
          this.userOnCreate();
        } catch (e) {
          throw new AnswersComponentError('Error initializing component', this.constructor.type, e);
        }

        this._state.on('update', function () {
          try {
            _this.onUpdate();

            _this.userOnUpdate();

            _this.unMount();

            _this.mount();
          } catch (e) {
            throw new AnswersComponentError('Error updating component', _this.constructor.type, e);
          }
        });

        DOM.addClass(this._container, this._className);
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var newState = Object.assign({}, {
          _config: this._config
        }, data);

        this._state.set(newState);

        return this;
      }
    }, {
      key: "getState",
      value: function getState(prop) {
        return this._state.get(prop);
      }
    }, {
      key: "hasState",
      value: function hasState(prop) {
        return this._state.has(prop);
      }
    }, {
      key: "transformData",
      value: function transformData(data) {
        return data;
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        var childComponent = this.componentManager.create(type, Object.assign({
          name: data.name,
          parentContainer: this._container,
          data: data
        }, opts || {}, {
          _parentOpts: this._config
        }));

        this._children.push(childComponent);

        return childComponent;
      }
      /**
       * Unmount and remove this component and its children from the list
       * of active components
       */

    }, {
      key: "remove",
      value: function remove() {
        this._children.forEach(function (c) {
          return c.remove();
        });

        this.componentManager.remove(this);
      }
      /**
       * Set the render method to be used for rendering the component
       * @param {Function} render
       * @return {string}
       */

    }, {
      key: "setRender",
      value: function setRender(render) {
        this._render = render;
        return this;
      }
      /**
       * Set the renderer for the component
       * @param {RendererType} renderer
       */

    }, {
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = Renderers[renderer];
        return this;
      }
      /**
       * Sets the template for the component to use when rendering
       * @param {string} template
       */

    }, {
      key: "setTemplate",
      value: function setTemplate(template) {
        this._template = this._renderer.compile(template);
      }
    }, {
      key: "unMount",
      value: function unMount() {
        if (!this._container) {
          return this;
        }

        this._children.forEach(function (child) {
          child.unMount();
        });

        DOM.empty(this._container);

        this._children.forEach(function (c) {
          return c.remove();
        });

        this._children = [];
        this.onUnMount();
      }
    }, {
      key: "mount",
      value: function mount(container) {
        var _this2 = this;

        if (container) {
          this._container = container;
        }

        if (!this._container) {
          return this;
        }

        if (this.beforeMount() === false) {
          return this;
        }

        DOM.append(this._container, this.render(this._state.asJSON())); // Process the DOM to determine if we should create
        // in-memory sub-components for rendering

        var domComponents = DOM.queryAll(this._container, '[data-component]:not([data-is-component-mounted])');
        var data = this.transformData(JSON.parse(JSON.stringify(this._state.get())));
        domComponents.forEach(function (c) {
          return _this2._createSubcomponent(c, data);
        });

        this._children.forEach(function (child) {
          child.mount();
        }); // Attach analytics hooks as necessary


        if (this.analyticsReporter) {
          var domHooks = DOM.queryAll(this._container, '[data-eventtype]:not([data-is-analytics-attached])');
          domHooks.forEach(this._createAnalyticsHook.bind(this));
        }

        this._isMounted = true;
        this.onMount(this);
        this.userOnMount(this);
        return this;
      }
      /**
       * render the template using the {Renderer} with the current state and template of the component
       * @returns {string}
       */

    }, {
      key: "render",
      value: function render() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._state.get();
        this.beforeRender(); // Temporary fix for passing immutable data to transformData().

        data = this.transformData(JSON.parse(JSON.stringify(data)));
        var html = ''; // Use either the custom render function or the internal renderer
        // dependant on the component configuration

        if (typeof this._render === 'function') {
          html = this._render(data);

          if (typeof html !== 'string') {
            throw new Error('Render method must return HTML as type {string}');
          }
        } else {
          // Render the existing templates as a string
          html = this._renderer.render({
            template: this._template,
            templateName: this._templateName
          }, data);
        } // We create an HTML Document fragment with the rendered string
        // So that we can query it for processing of sub components


        var el = DOM.create(html);
        this.afterRender();
        return el.innerHTML;
      }
    }, {
      key: "_createSubcomponent",
      value: function _createSubcomponent(domComponent, data) {
        var _this3 = this;

        domComponent.dataset.isComponentMounted = true;
        var dataset = domComponent.dataset;
        var type = dataset.component;
        var prop = dataset.prop;
        var opts = dataset.opts ? JSON.parse(dataset.opts) : {};
        var childData = data[prop] || {};
        opts = _objectSpread({}, opts, {
          container: domComponent
        }); // TODO(billy) Right now, if we provide an array as the data prop,
        // the behavior is to create many components for each item in the array.
        // THAT interface SHOULD change to use a different property that defines
        // whether to array data should be used for a single component or
        // to create many components for each item.
        // Overloading and having this side effect is unintuitive and WRONG

        if (!Array.isArray(childData)) {
          // Rendering a sub component should be within the context,
          // of the node that we processed it from
          this.addChild(childData, type, opts);
          return;
        }

        childData.reverse();
        childData.forEach(function (data) {
          _this3.addChild(data, type, opts);
        });
      }
    }, {
      key: "_createAnalyticsHook",
      value: function _createAnalyticsHook(domComponent) {
        var _this4 = this;

        domComponent.dataset.isAnalyticsAttached = true;
        var dataset = domComponent.dataset;
        var type = dataset.eventtype;
        var label = dataset.eventlabel;
        var options = dataset.eventoptions ? JSON.parse(dataset.eventoptions) : {};
        DOM.on(domComponent, 'click', function (e) {
          var event = new AnalyticsEvent(type, label);
          event.addOptions(_this4._analyticsOptions);
          event.addOptions(options);

          _this4.analyticsReporter.report(event);
        });
      }
      /**
       * onCreate is triggered when the component is constructed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onCreate",
      value: function onCreate(cb) {}
      /**
       * onUpdate is triggered when the state of the component changes
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUpdate",
      value: function onUpdate(cb) {}
      /**
       * beforeRender event is triggered before the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeRender",
      value: function beforeRender(cb) {}
      /**
       * afterRender event is triggered after the component is rendered
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "afterRender",
      value: function afterRender(cb) {}
      /**
       * onMount is triggered when the component is appended to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onMount",
      value: function onMount(cb) {}
      /**
       * onUnMount is triggered when the component is removed from the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onUnMount",
      value: function onUnMount(cb) {}
      /**
       * beforeMount is triggered before the component is mounted to the DOM
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "beforeMount",
      value: function beforeMount(cb) {}
      /**
       * onDestroy is triggered when the component is destroyed
       * @param {function} the callback to invoke upon emit
       */

    }, {
      key: "onDestroy",
      value: function onDestroy(cb) {}
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'default';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return false;
      }
    }, {
      key: "type",
      get: function get() {
        return 'Component';
      }
    }]);

    return Component;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * ErrorReporter is used for reporting errors to the console and API
   *
   * @implements {ErrorReporterService}
   */

  var ErrorReporter =
  /*#__PURE__*/
  function () {
    function ErrorReporter(config) {
      var _this = this;

      _classCallCheck(this, ErrorReporter);

      /**
       * The apiKey to use for reporting
       * @type {string}
       */
      this.apiKey = config.apiKey;
      /**
       * The experienceKey to use when reporting
       * @type {string}
       */

      this.experienceKey = config.experienceKey;
      /**
       * The answers config version used for api requests
       * @type {string|number}
       */

      this.experienceVersion = config.experienceVersion || 'config1.0';
      /**
       * If true, print entire error objects to the console for inspection
       * @type {boolean}
       */

      this.printVerbose = config.printVerbose;
      /**
       * If true, report the error the server for logging and monitoring
       * @type {boolean}
       */

      this.sendToServer = config.sendToServer; // Attach reporting listeners to window

      window.addEventListener('error', function (e) {
        return _this.report(e.error);
      });
      window.addEventListener('unhandledrejection', function (e) {
        return _this.report(e.error);
      });
    }
    /**
     * report pretty prints the error to the console, optionally
     * prints the entire error if `printVerbose` is true, and sends the
     * error to the server to be logged if `sendToServer` is true
     * @param {AnswersBaseError} err The error to be reported
     * @returns {AnswersBaseError} The reported error
     */


    _createClass(ErrorReporter, [{
      key: "report",
      value: function report(err) {
        if (!(err instanceof AnswersBaseError) || err.reported) {
          return;
        }

        err.reported = true;
        this.printError(err);

        if (this.sendToServer) {
          var request = new ApiRequest({
            endpoint: '/v2/accounts/me/answers/errors',
            apiKey: this.apiKey,
            version: 20190301,
            params: {
              'error': err.toJson(),
              'libVersion': LIB_VERSION,
              'experienceVersion': this.experienceVersion,
              'experienceKey': this.experienceKey
            }
          });
          request.get()["catch"](console.err);
        }

        return err;
      }
      /**
       * prints the given error to the browser console
       * @param {AnswersBaseError} err The error to be printed
       */

    }, {
      key: "printError",
      value: function printError(err) {
        console.error(err.toString());

        if (this.printVerbose) {
          console.log(_objectSpread({}, err));
        }
      }
    }]);

    return ErrorReporter;
  }();

  /** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

  /**
   * @implements {ErrorReporterService}
   */
  var ConsoleErrorReporter =
  /*#__PURE__*/
  function () {
    function ConsoleErrorReporter() {
      _classCallCheck(this, ConsoleErrorReporter);
    }

    _createClass(ConsoleErrorReporter, [{
      key: "report",

      /** @inheritdoc */
      value: function report(err) {
        console.error(err.toString());
      }
    }]);

    return ConsoleErrorReporter;
  }();

  /** @module PersistentStorage */

  var PersistentStorage =
  /*#__PURE__*/
  function () {
    function PersistentStorage() {
      var _this = this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, PersistentStorage);

      /**
       * The current params model
       * @type {SearchParams}
       */
      this._params = new SearchParams(window.location.search.substring(1));
      /**
       * The current history edit timer, if any
       * @type {number}
       */

      this._historyTimer = null;
      /**
       * The list of listeners to every storage update
       * @type {function[]}
       */

      this._updateListener = config.updateListener || function () {};
      /**
       * The list of listeners to storage resets
       * @type {function[]}
       */


      this._resetListener = config.resetListener || function () {};

      window.onpopstate = function () {
        _this._params = new SearchParams(window.location.search.substring(1));

        _this._callListener(_this._updateListener);

        _this._callListener(_this._resetListener);
      };
    }
    /**
     * Insert the given key/value pair into storage
     * @param {string} key The key to insert the data in
     * @param {*} data The data to insert
     * @param {boolean} replace history instead of pushing new state
     */


    _createClass(PersistentStorage, [{
      key: "set",
      value: function set(key, data) {
        var replaceHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (typeof key !== 'string') {
          throw new AnswersStorageError('Storage data key must be a string', key, data);
        }

        var newData = data;

        if (typeof data !== 'string') {
          newData = JSON.stringify(data);
        }

        this._params.set(key, newData);

        this._updateHistory(replaceHistory);
      }
      /**
       * Delete the given key from storage
       * @param {string} key The key to delete
       * @param {boolean} replace history instead of pushing new state
       */

    }, {
      key: "delete",
      value: function _delete(key) {
        var replaceHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this._params["delete"](key);

        this._updateHistory(replaceHistory);
      }
    }, {
      key: "_updateHistory",
      value: function _updateHistory() {
        var _this2 = this;

        var replaceHistory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this._historyTimer) {
          clearTimeout(this._historyTimer);
        } // batch update calls across components to avoid updating the url too much


        this._historyTimer = setTimeout(function () {
          _this2._historyTimer = null;

          if (replaceHistory) {
            window.history.replaceState(null, null, "?".concat(_this2._params.toString()));
          } else {
            window.history.pushState(null, null, "?".concat(_this2._params.toString()));
          }

          _this2._callListener(_this2._updateListener);
        });
      }
      /**
       * Invoke the given list of callbacks with the current storage data
       * @param {function[]} listeners The callbacks to invoke
       * @private
       */

    }, {
      key: "_callListener",
      value: function _callListener(listener) {
        listener(this.getAll(), this._params.toString());
      }
      /**
       * Get all the key/value pairs in storage
       */

    }, {
      key: "getAll",
      value: function getAll() {
        var allParams = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._params.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                val = _step$value[1];

            allParams[key] = val;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return allParams;
      }
    }]);

    return PersistentStorage;
  }();

  /** @module SearchConfig */

  var SearchConfig =
  /*#__PURE__*/
  function () {
    function SearchConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, SearchConfig);

      /**
       * The max results per search.
       * Also defines the number of results per page, if pagination is enabled
       * @type {number}
       */
      this.limit = config.limit || 20;
      /**
       * The vertical key to use for all searches
       * @type {string}
       */

      this.verticalKey = config.verticalKey || null;
      /**
       * A default search to use on initialization for vertical searchers, when the user has't provided a query
       * @type {string}
       */

      this.defaultInitialSearch = config.defaultInitialSearch;
      this.validate();
      Object.freeze(this);
    }

    _createClass(SearchConfig, [{
      key: "validate",
      value: function validate() {
        if (typeof this.limit !== 'number' || this.limit < 1 || this.limit > 50) {
          throw new AnswersConfigError('Search Limit must be between 1 and 50', 'SearchConfig');
        }
      }
    }]);

    return SearchConfig;
  }();

  var AutoCompleteData =
  /*#__PURE__*/
  function () {
    function AutoCompleteData() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AutoCompleteData);

      this.sections = data.sections || [];
      this.queryId = data.queryId || '';
      Object.freeze(this);
    }

    _createClass(AutoCompleteData, null, [{
      key: "from",
      value: function from(response) {
        var sections;

        if (response.sections) {
          sections = response.sections.map(function (s) {
            return {
              label: s.label,
              results: s.results.map(function (r) {
                return new AutoCompleteResult(r);
              })
            };
          });
        } else {
          sections = [{
            results: response.results.map(function (r) {
              return new AutoCompleteResult(r);
            })
          }];
        }

        return new AutoCompleteData({
          sections: sections,
          queryId: response.queryId
        });
      }
    }]);

    return AutoCompleteData;
  }();
  var AutoCompleteResult = function AutoCompleteResult() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AutoCompleteResult);

    this.filter = data.filter || {};
    this.highlightedValue = new HighlightedValue(data).getInverted();
    this.key = data.key || '';
    this.matchedSubstrings = data.matchedSubstrings || [];
    this.value = data.value || '';
    this.shortValue = data.shortValue || this.value;
    Object.freeze(this);
  };

  /**
   * A Data Transformer that takes the response object from a AutoComplete request
   * And transforms in to a front-end oriented data structure that our
   * component library and core storage understand.
   *
   * TODO(billy) Create our own front-end data models
   */

  var AutoCompleteDataTransformer =
  /*#__PURE__*/
  function () {
    function AutoCompleteDataTransformer() {
      _classCallCheck(this, AutoCompleteDataTransformer);
    }

    _createClass(AutoCompleteDataTransformer, null, [{
      key: "clean",
      value: function clean(moduleId, data) {
        if (data.sections && data.sections.length === 0) {
          delete data.sections;
        }

        if (data.sections && data.sections.length === 1 && data.sections[0].results.length === 0) {
          delete data.sections;
        }

        return _defineProperty({}, moduleId, data);
      }
    }, {
      key: "universal",
      value: function universal(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "filter",
      value: function filter(response) {
        return AutoCompleteData.from(response);
      }
    }, {
      key: "vertical",
      value: function vertical(response) {
        return AutoCompleteData.from(response);
      }
    }]);

    return AutoCompleteDataTransformer;
  }();

  /** @typedef {import('./autocompleteservice').default} AutoCompleteService */

  /**
   * AutoCompleteApi exposes an interface for network related matters
   * for all the autocomplete endpoints.
   *
   * @implements {AutoCompleteService}
   */

  var AutoCompleteApi =
  /*#__PURE__*/
  function () {
    function AutoCompleteApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AutoCompleteApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'AutoComplete');
      }

      this._apiKey = config.apiKey;
      /**
       * The Answers Key to use for the request
       * @type {string}
       * @private
       */

      if (!config.experienceKey) {
        throw new AnswersBasicError('Answers Key is required', 'AutoComplete');
      }

      this._experienceKey = config.experienceKey;
      /**
       * The version of the API to make a request to
       * @type {string}
       * @private
       */

      this._version = config.version || 20190101 || 20190301;
      /**
       * The answers config version to use for all requests
       * @type {string}
       * @private
       */

      this._experienceVersion = config.experienceVersion;
      /**
       * The locale to use for the request
       * @type {string}
       * @private
       */

      if (!config.locale) {
        throw new AnswersBasicError('Locale is required', 'AutoComplete');
      }

      this._locale = config.locale;
    }
    /** @inheritdoc */


    _createClass(AutoCompleteApi, [{
      key: "queryFilter",
      value: function queryFilter(input, config) {
        var request = new ApiRequest({
          endpoint: '/v2/accounts/me/answers/filtersearch',
          apiKey: this._apiKey,
          version: this._version,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': config.verticalKey,
            'inputKey': config.barKey,
            'locale': this._locale,
            'search_parameters': JSON.stringify(config.searchParameters)
          }
        });
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.filter(response.response, config.barKey);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Filter search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey, barKey) {
        var request = new ApiRequest({
          endpoint: '/v2/accounts/me/answers/vertical/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          params: {
            'input': input,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'verticalKey': verticalKey,
            'barKey': barKey,
            'locale': this._locale
          }
        });
        return request.get().then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.vertical(response.response, request._params.barKey);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Vertical search request failed', 'AutoComplete', error);
        });
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(queryString) {
        var request = new ApiRequest({
          endpoint: '/v2/accounts/me/answers/autocomplete',
          apiKey: this._apiKey,
          version: this._version,
          params: {
            'input': queryString,
            'experienceKey': this._experienceKey,
            'version': this._experienceVersion,
            'locale': this._locale
          }
        });
        return request.get(queryString).then(function (response) {
          return response.json();
        }).then(function (response) {
          return AutoCompleteDataTransformer.universal(response.response);
        })["catch"](function (error) {
          throw new AnswersEndpointError('Universal search request failed', 'AutoComplete', error);
        });
      }
    }]);

    return AutoCompleteApi;
  }();

  /** @typedef {import('../services/autocompleteservice').default} AutoCompleteService */

  var universalOptions = ['what is yext', 'who is the ceo of yext'];
  var verticalOptions = ['near me', 'in new york', 'available now'];
  /**
   * MockAutoCompleteService serves autocomplete queries with mock data
   *
   * @implements {AutoCompleteService}
   */

  var MockAutoCompleteService =
  /*#__PURE__*/
  function () {
    function MockAutoCompleteService() {
      _classCallCheck(this, MockAutoCompleteService);
    }

    _createClass(MockAutoCompleteService, [{
      key: "queryFilter",

      /** @inheritdoc */
      value: function queryFilter(input, config) {
        // TODO(amullings): Simulate filter search, with sections
        return emptyResults();
      }
      /** @inheritdoc */

    }, {
      key: "queryVertical",
      value: function queryVertical(input, verticalKey) {
        return filterOptions(input, verticalOptions.map(function (opt) {
          return "".concat(verticalKey, " ").concat(opt);
        }).concat(universalOptions));
      }
      /** @inheritdoc */

    }, {
      key: "queryUniversal",
      value: function queryUniversal(input) {
        return filterOptions(input, universalOptions);
      }
    }]);

    return MockAutoCompleteService;
  }();

  function filterOptions(input, options) {
    if (input.length === 0) {
      return emptyResults();
    }

    var lowercase = input.toLowerCase();
    var results = options.filter(function (opt) {
      return opt.includes(lowercase);
    }).map(function (opt) {
      return new AutoCompleteResult({
        value: opt,
        matchedSubstrings: [{
          offset: opt.indexOf(lowercase),
          length: lowercase.length
        }]
      });
    });
    return Promise.resolve(new AutoCompleteData({
      sections: [{
        results: results
      }],
      queryId: randomString()
    }));
  }
  /**
   * @returns {Promise<AutoCompleteData>}
   */


  function emptyResults() {
    return Promise.resolve(new AutoCompleteData({
      sections: [{}],
      queryId: randomString()
    }));
  }
  /**
   * @returns {string}
   */


  function randomString() {
    return Math.random().toString(36).substring(2);
  }

  /** @typedef {import('./questionanswerservice').default} QuestionAnswerService */

  /**
   * QuestionAnswerApi submits questions via the Q&A REST API
   *
   * @implements {QuestionAnswerService}
   */

  var QuestionAnswerApi =
  /*#__PURE__*/
  function () {
    function QuestionAnswerApi() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, QuestionAnswerApi);

      /**
       * The API Key to use for the request
       * @type {string}
       * @private
       */
      if (!config.apiKey) {
        throw new AnswersBasicError('Api Key is required', 'QuestionAnswerApi');
      }

      this._apiKey = config.apiKey;
    }
    /** @inheritdoc */


    _createClass(QuestionAnswerApi, [{
      key: "submitQuestion",
      value: function submitQuestion(question) {
        var request = new ApiRequest({
          baseUrl: API_BASE_URL,
          endpoint: '/v2/accounts/me/questions',
          apiKey: this._apiKey,
          params: {
            'entityId': question.entityId,
            'site': question.site,
            'name': question.name,
            'email': question.email,
            'questionText': question.questionText,
            'questionDescription': question.questionDescription,
            'questionLanguage': question.questionLanguage
          }
        });
        return request.post({
          mode: 'cors',
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(function (response) {
          return response.json();
        })["catch"](function (error) {
          throw new AnswersEndpointError('Question submit failed', 'QuestionAnswerApi', error);
        });
      }
    }]);

    return QuestionAnswerApi;
  }();

  /** @module MockQuestionAnswerService */

  /** @typedef {import('../services/questionanswerservice').default} QuestionAnswerService */

  /**
   * @implements {QuestionAnswerService}
   */
  var MockQuestionAnswerService =
  /*#__PURE__*/
  function () {
    function MockQuestionAnswerService() {
      _classCallCheck(this, MockQuestionAnswerService);
    }

    _createClass(MockQuestionAnswerService, [{
      key: "submitQuestion",

      /** @inheritdoc */
      value: function submitQuestion(question) {
        // TODO(amullings): Make actual response object once we're using it for
        // something
        return Promise.resolve({});
      }
    }]);

    return MockQuestionAnswerService;
  }();

  /* global fetch */

  /** @typedef {import('../models/section').default} Section */

  /** @typedef {import('../services/searchservice').default} SearchService */

  /**
   * @typedef {Object} ResultData
   * @property {Object} data
   * @property {string } htmlTitle
   */

  /**
   * @callback ResultsModifier
   * @param {ResultData[]} results
   * @returns {ResultData[]}
   */

  /**
   * @callback MockDataConsumer
   * @param {Section[]} sections
   * @returns {Promise<Object>}
   */
  var ARBITRARY_BUSINESS_ID = 919871;
  /**
   * @implements {SearchService}
   */

  var MockSearchService =
  /*#__PURE__*/
  function () {
    function MockSearchService() {
      _classCallCheck(this, MockSearchService);

      /**
       * @type {Promise<string>}
       * @private
       */
      this._getMockDataJson = fetch('https://assets.sitescdn.net/answers/testdata/search/mockdata_v1.json').then(function (resp) {
        return resp.text();
      })["catch"](console.error);
    }
    /** @inheritdoc */


    _createClass(MockSearchService, [{
      key: "verticalSearch",
      value: function verticalSearch(verticalKey, _ref) {
        var input = _ref.input,
            filter = _ref.filter,
            facetFilter = _ref.facetFilter,
            limit = _ref.limit,
            offset = _ref.offset,
            id = _ref.id,
            geolocation = _ref.geolocation,
            isDynamicFiltersEnabled = _ref.isDynamicFiltersEnabled,
            skipSpellCheck = _ref.skipSpellCheck,
            queryTrigger = _ref.queryTrigger;
        return this.useMockData(function (sections) {
          if (input === '') {
            return delayedResponse(constructVerticalResponse({
              results: [],
              appliedQueryFilters: []
            }));
          } // Either find a section with matching ID, or pick one at random


          var section = sections.find(function (verticalModule) {
            return verticalKey === verticalModule['verticalConfigId'];
          });

          if (section == null) {
            section = sections[Math.floor(Math.random() * sections.length)];
          }

          modifyResults(section, getResultsFilterer(input));

          if (offset != null && limit != null) {
            modifyResults(section, function limit(results) {
              return results.slice(offset, offset + limit);
            });
          }

          var resp = constructVerticalResponse(section);
          return delayedResponse(resp);
        });
      }
      /** @inheritdoc */

    }, {
      key: "universalSearch",
      value: function universalSearch(queryString, params) {
        return this.useMockData(function (sections) {
          if (queryString === '') {
            return delayedResponse(constructUniversalResponse([]));
          }

          sections.forEach(function (section) {
            modifyResults(section, getResultsFilterer(queryString));
          });
          sections = sections.filter(function (section) {
            return section.results.length > 0;
          });
          var resp = constructUniversalResponse(sections);
          return delayedResponse(resp);
        });
      }
      /**
       * @param {MockDataConsumer} consumer
       * @returns {Promise<Object>}
       * @private
       */

    }, {
      key: "useMockData",
      value: function useMockData(consumer) {
        return this._getMockDataJson.then(JSON.parse).then(consumer);
      }
    }]);

    return MockSearchService;
  }();

  function getResultsFilterer(queryString) {
    return function (results) {
      return results.filter(function (result) {
        if (result.htmlTitle && result.htmlTitle.toLowerCase().includes(queryString)) {
          return true;
        }

        for (var prop in result.data) {
          var val = result.data[prop];

          if (typeof val === 'string' && val.toLowerCase().includes(queryString)) {
            return true;
          }
        }

        return false;
      });
    };
  }
  /**
   * @param {Section} section
   * @param {ResultsModifier} modifyFn
   */


  function modifyResults(section, modifyFn) {
    section.results = modifyFn(section.results);
  }
  /**
   * @param {Section[]} sections A list of mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructUniversalResponse(sections) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    sections = sections.map(fillSectionFields);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: {
        businessId: ARBITRARY_BUSINESS_ID,
        modules: sections,
        failedVerticals: [],
        queryId: uuidV4(),
        searchIntents: []
      }
    };
  }
  /**
   * @param {Section} section A mock section data
   * @returns {Object} A mock AnswersApi response
   */


  function constructVerticalResponse(section) {
    // TODO(amullings): spellcheck, geo, filters
    // TODO(amullings): Fake encodedState once the SDK uses it
    section = fillSectionFields(section);
    return {
      meta: {
        uuid: uuidV4(),
        errors: []
      },
      response: Object.assign(section, {
        businessId: ARBITRARY_BUSINESS_ID,
        queryId: uuidV4(),
        searchIntents: []
      })
    };
  }
  /**
   * @param {Section}
   * @returns {Section}
   */


  function fillSectionFields(section) {
    return {
      verticalConfigId: section.verticalConfigId,
      resultsCount: section.results.length,
      encodedState: '',
      results: section.results,
      appliedQueryFilters: section.appliedQueryFilters,
      queryDurationMillis: randomInt(50, 1000),
      facets: section.facets,
      source: section.source
    };
  }
  /**
   * @param {Object} resp
   * @returns {Promise<Object>}
   */


  function delayedResponse(resp) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(resp);
      }, randomInt(250, 1000));
    });
  }
  /**
   * Code-golf-y but legit basic UUID v4 implementation. Not cryptographically secure.
   * From https://gist.github.com/jed/982883
   * @returns {string} A v4-compliant UUID
   */


  function uuidV4() {
    return function b(a) {
      return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);
    }();
  }
  /**
   * @param {number} min inclusive
   * @param {number} max exclusive
   * @returns {number} A random integer in the specified range
   */


  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }

  /**
   * The debounce duration for resize events
   * @type {number}
   */

  var RESIZE_DEBOUNCE = 100;
  /**
   * The breakpoint for mobile
   * @type {number}
   */

  var MOBILE_BREAKPOINT = 767;
  /**
   * Enum options for mobile overflow beahvior
   * @type {Object.<string, string>}
   */

  var MOBILE_OVERFLOW_BEHAVIOR_OPTION = {
    COLLAPSE: 'COLLAPSE',
    INNERSCROLL: 'INNERSCROLL'
  };
  /**
   * The Tab is a model that is used to power the Navigation tabs in the view.
   * It's initialized through the configuration provided to the component.
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(config) {
      _classCallCheck(this, Tab);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label;

      if (typeof this.label !== 'string') {
        throw new AnswersComponentError('label is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The complete URL, including the params
       * @type {string}
       */


      this.url = config.url;

      if (typeof this.url !== 'string') {
        throw new AnswersComponentError('url is a required configuration option for tab.', 'NavigationComponent');
      }
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */


      this.configId = config.configId || null;
      /**
       * The base URL used for constructing the URL with params
       * @type {string}
       */

      this.baseUrl = config.url;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }
    /**
     * from will construct a map of configId to {Tab} from
     * a configuration file
     * @param {object} tabsConfig the configuration to use
     */


    _createClass(Tab, null, [{
      key: "from",
      value: function from(tabsConfig) {
        var tabs = {}; // Parse the options and build out our tabs and

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = tabsConfig[i]; // For tabs without config ids, map their URL to the configID
          // to avoid duplication of renders

          if (tab.configId === null && tabs[tab.configId] === undefined) {
            tab.configId = tab.url;
          }

          tabs[tab.configId] = new Tab(tab);
        }

        return tabs;
      }
    }]);

    return Tab;
  }();
  /**
   * NavigationComponent exposes an interface for building a dynamic
   * navigation that is powered by universal search updates.
   * @extends Component
   */

  var NavigationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(NavigationComponent, _Component);

    function NavigationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, NavigationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NavigationComponent).call(this, config, systemConfig));
      /**
       * The label to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowLabel = config.overflowLabel || 'More';
      /**
       * The optional icon to show on the dropdown menu button when overflow
       * @type {string}
       */

      _this.overflowIcon = config.overflowIcon || 'kabob';
      /**
       * The data storage key
       * @type {string}
       */

      _this.moduleId = StorageKeys.NAVIGATION;
      /**
       * Tabs config from global navigation config
       * @type {Array.<object>}
       * @private
       */

      _this._tabsConfig = _this.core.globalStorage.getState(StorageKeys.NAVIGATION_CONFIG).tabsConfig;
      /**
       * Unordered map of each tab, keyed by VS configId
       * @type {Object.<String, Object>}
       * @private
       */

      _this._tabs = Tab.from(_this._tabsConfig);
      /**
       * The order of the tabs, parsed from configuration or URL.
       * This gets updated based on the server results
       * @type {Array.<String>} The list of VS configIds
       * @private
       */

      _this._tabOrder = _this.getDefaultTabOrder(_this._tabsConfig, _this.getUrlParams());
      /**
       * Breakpoints at which navigation items move to the "more" dropdown
       * @type {number[]}
       * @private
       */

      _this._navBreakpoints = [];
      /**
       *  The mobile overflow behavior config
       *  @type {string}
       */

      _this._mobileOverflowBehavior = config.mobileOverflowBehavior || MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE;
      /**
       *  The ARIA label
       *  @type {string}
       */

      _this._ariaLabel = config.ariaLabel || 'Search Page Navigation';
      _this.checkOutsideClick = _this.checkOutsideClick.bind(_assertThisInitialized(_this));
      _this.checkMobileOverflowBehavior = _this.checkMobileOverflowBehavior.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(NavigationComponent, [{
      key: "onCreate",
      value: function onCreate() {
        // TODO: Re-rendering and re-mounting the component every tim e the window changes size
        // is not great.
        DOM.on(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        DOM.off(window, 'resize', this.checkMobileOverflowBehavior);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        if (this.shouldCollapse()) {
          this._navBreakpoints = [];
          this.bindOverflowHandlers();
          this.refitNav();
          DOM.on(DOM.query(this._container, '.yxt-Nav-more'), 'click', this.toggleMoreDropdown.bind(this));
        }
      }
    }, {
      key: "onUnMount",
      value: function onUnMount() {
        this.unbindOverflowHandlers();
      }
    }, {
      key: "bindOverflowHandlers",
      value: function bindOverflowHandlers() {
        DOM.on(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "unbindOverflowHandlers",
      value: function unbindOverflowHandlers() {
        DOM.off(window, 'click', this.checkOutsideClick);
      }
    }, {
      key: "refitNav",
      value: function refitNav() {
        var container = DOM.query(this._container, '.yxt-Nav-container');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        var mainLinks = DOM.query(this._container, '.yxt-Nav-expanded');
        var collapsedLinks = DOM.query(this._container, '.yxt-Nav-modal');
        var navWidth = moreButton.classList.contains('yxt-Nav-item--more') ? container.offsetWidth : container.offsetWidth - moreButton.offsetWidth;
        var numBreakpoints = this._navBreakpoints.length; // sum child widths instead of using parent's width to avoid
        // browser inconsistencies

        var mainLinksWidth = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = mainLinks.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var el = _step.value;
            mainLinksWidth += el.offsetWidth;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (mainLinksWidth > navWidth) {
          this._navBreakpoints.push(mainLinksWidth);

          var lastLink = mainLinks.children.item(mainLinks.children.length - 1);

          if (lastLink === null) {
            return;
          }

          collapsedLinks.prepend(lastLink);

          if (moreButton.classList.contains('yxt-Nav-item--more')) {
            moreButton.classList.remove('yxt-Nav-item--more');
          }
        } else {
          if (numBreakpoints && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
            var firstLink = collapsedLinks.children.item(0);

            if (firstLink === null) {
              return;
            }

            mainLinks.append(firstLink);

            this._navBreakpoints.pop();

            numBreakpoints--;
          }

          if (collapsedLinks.children.length === 0) {
            moreButton.classList.add('yxt-Nav-item--more');
          }
        }

        this.closeMoreDropdown();

        if (mainLinksWidth > navWidth || numBreakpoints > 0 && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
          this.refitNav();
        }
      }
    }, {
      key: "closeMoreDropdown",
      value: function closeMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.remove('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', false);
      }
    }, {
      key: "openMoreDropdown",
      value: function openMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.add('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', true);
      }
    }, {
      key: "toggleMoreDropdown",
      value: function toggleMoreDropdown() {
        var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
        collapsed.classList.toggle('is-active');
        var moreButton = DOM.query(this._container, '.yxt-Nav-more');
        moreButton.setAttribute('aria-expanded', collapsed.classList.contains('is-active'));
      }
    }, {
      key: "checkOutsideClick",
      value: function checkOutsideClick(e) {
        if (e.target.closest('.yxt-Nav-container')) {
          return;
        }

        this.closeMoreDropdown();
      }
    }, {
      key: "checkMobileOverflowBehavior",
      value: function checkMobileOverflowBehavior() {
        if (this._checkMobileOverflowBehaviorTimer) {
          clearTimeout(this._checkMobileOverflowBehaviorTimer);
        }

        this._checkMobileOverflowBehaviorTimer = setTimeout(this.setState.bind(this), RESIZE_DEBOUNCE);
      }
      /**
       * Since the server data only provides a list of
       * VS configIds, we need to compute and transform
       * the data into the proper format for rendering.
       *
       * @override
       */

    }, {
      key: "setState",
      value: function setState() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (data.tabOrder !== undefined) {
          this._tabOrder = this.mergeTabOrder(data.tabOrder, this._tabOrder);
        } // Since the tab ordering can change based on the server data
        // we need to update each tabs URL to include the order as part of their params.
        // This helps with persisting state across verticals.


        var tabs = [];

        for (var i = 0; i < this._tabOrder.length; i++) {
          var tab = this._tabs[this._tabOrder[i]];

          if (tab !== undefined) {
            tab.url = this.generateTabUrl(tab.baseUrl, this.getUrlParams());
            tabs.push(tab);
          }
        }

        return _get(_getPrototypeOf(NavigationComponent.prototype), "setState", this).call(this, {
          tabs: tabs,
          overflowLabel: this.overflowLabel,
          overflowIcon: this.overflowIcon,
          showCollapse: this.shouldCollapse(),
          ariaLabel: this._ariaLabel
        });
      }
    }, {
      key: "getUrlParams",
      value: function getUrlParams() {
        return new SearchParams(window.location.search.substring(1));
      }
    }, {
      key: "shouldCollapse",
      value: function shouldCollapse() {
        switch (this._mobileOverflowBehavior) {
          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE:
            return true;

          case MOBILE_OVERFLOW_BEHAVIOR_OPTION.INNERSCROLL:
            var container = DOM.query(this._container, '.yxt-Nav-container') || this._container;

            var navWidth = container.offsetWidth;
            return navWidth > MOBILE_BREAKPOINT;
        }
      }
      /**
       * getDefaultTabOrder will compute the initial tab ordering based
       * on a combination of the configuration provided directly to the component
       * and the url params.
       * @param {Object[]} tabsConfig
       * @param {SearchParams}
       */

    }, {
      key: "getDefaultTabOrder",
      value: function getDefaultTabOrder(tabsConfig, urlParams) {
        var tabOrder = []; // Use the ordering from the URL as the primary configuration
        // And then merge it with the local configuration, if provided.

        if (urlParams && urlParams.has('tabOrder')) {
          tabOrder = urlParams.get('tabOrder').split(',');
        }

        for (var i = 0; i < tabsConfig.length; i++) {
          var tab = tabsConfig[i]; // Some tabs don't have configId, so we map it from URL

          if (tab.configId === undefined) {
            tab.configId = tab.url;
          } // Avoid duplicates if config was provided from URL


          if (tabOrder.includes(tab.configId)) {
            continue;
          } // isFirst should always be the first element in the list


          if (tab.isFirst) {
            tabOrder.unshift(tab.configId);
          } else {
            tabOrder.push(tab.configId);
          }
        }

        return tabOrder;
      }
      /**
       * mergeTabOrder merges two arrays into one
       * by appending additional tabs to the end of the original array
       * @param {string[]} tabOrder Tab order provided by the server
       * @param {string[]} otherTabOrder Tab order provided by configuration
       * @return {string[]}
       */

    }, {
      key: "mergeTabOrder",
      value: function mergeTabOrder(tabOrder, otherTabOrder) {
        for (var i = 0; i < otherTabOrder.length; i++) {
          var tabConfig = otherTabOrder[i];

          if (tabOrder.includes(tabConfig)) {
            continue;
          } // isFirst should be an override to dynamic tab ordering.


          if (this._tabs[tabConfig] && this._tabs[tabConfig].isFirst) {
            tabOrder.unshift(tabConfig);
          } else {
            tabOrder.push(tabConfig);
          }
        }

        return tabOrder;
      }
    }, {
      key: "generateTabUrl",
      value: function generateTabUrl(baseUrl) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();
        // We want to persist the params from the existing URL to the new
        // URLS we create.
        params.set('tabOrder', this._tabOrder);
        return baseUrl + '?' + params.toString();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'navigation/navigation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Navigation';
      }
    }]);

    return NavigationComponent;
  }(Component);

  /**
   * SearchComponent exposes an interface in order to create
   * a UI Search experience for vertical and universal search.
   *
   * @extends Component
   */

  var SearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SearchComponent, _Component);

    function SearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchComponent).call(this, config, systemConfig));
      /**
       * The optional input key for the vertical search configuration
       * If not provided, auto-complete and search will be based on universal
       * @type {string}
       */

      _this._barKey = config.barKey || null;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, auto-complete and search will be based on universal
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided.
       * @type {string}
       */

      _this.title = config.title || 'Answers Universal Search';
      /**
       * The label text is used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.labelText = config.labelText || 'What are you interested in?';
      /**
       * The submit text is used for labeling the submit button, also provided to the template.
       * @type {string}
       */

      _this.submitText = config.submitText || 'Submit';
      /**
       * The submit icon is an icon for the submit button, if provided it will be displayed and the
       * submit text will be used for screen readers.
       * @type {string|null}
       */

      _this.submitIcon = config.submitIcon || null;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * If true, show an "x" that allows the user to clear the current
       * query
       * @type {boolean}
       */

      _this.clearButton = config.clearButton === undefined ? true : config.clearButton;
      /**
       * When autofocusing on load, optionally open the autocomplete
       * (preset prompts)
       * @type {boolean}
       */

      _this.autocompleteOnLoad = config.autocompleteOnLoad || false;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * true if there is another search bar present on the page.
       * Twins only update the query, and do not search
       */

      _this._isTwin = config.isTwin;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string|null}
       */

      _this.query = config.query || _this.core.globalStorage.getState(StorageKeys.QUERY);

      _this.core.globalStorage.on('update', StorageKeys.QUERY, function (q) {
        _this.query = q;

        _this.setState(); // If the Permissions API is supported in this browser, we can use location data the user
        // has already consented to share instead of prompting again to get location data


        if (navigator.permissions) {
          navigator.permissions.query({
            name: 'geolocation'
          }).then(function (_ref) {
            var state = _ref.state;

            if (state === 'granted') {
              navigator.geolocation.getCurrentPosition(function (position) {
                _this.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                  lat: position.coords.latitude,
                  lng: position.coords.longitude,
                  radius: position.coords.accuracy
                });

                _this.search(q);
              });
            } else {
              _this.search(q);
            }
          });
        } else {
          // Make sure both code paths are asynchrounous, for consistency
          setTimeout(function () {
            _this.search(q);
          });
        }
      });
      /**
       * The minimum time allowed in milliseconds between searches to prevent
       * many duplicate searches back-to-back
       * @type {number}
       * @private
       */


      _this._searchCooldown = config.searchCooldown || 300;
      /**
       * When true and "near me" intent is expressed, prompt the user for their geolocation
       * @type {boolean}
       * @private
       */

      _this._promptForLocation = config.promptForLocation === undefined ? true : Boolean(config.promptForLocation);
      /**
       * Controls showing and hiding the search clear button
       */

      _this._showClearButton = _this.clearButton && _this.query;
      /**
       * For vertical search bars, whether or not to allow empty searches.
       * @type {boolean}
       * @private
       */

      _this._allowEmptySearch = !!config.allowEmptySearch;
      return _this;
    }

    _createClass(SearchComponent, [{
      key: "onCreate",
      value: function onCreate() {
        if (this.query != null && !this.redirectUrl) {
          this.core.setQuery(this.query);
        }

        if (this._promptForLocation) {
          this.initLocationPrompt();
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        // NOTE(amullings): If autocompleteOnLoad is false, we focus the input
        // element before loading the autocomplete component so that its focus
        // handler won't be triggered
        if (this.autoFocus === true && !this.query && !this.autocompleteOnLoad) {
          this.focusInputElement();
        } // Wire up our search handling and auto complete


        this.initSearch(this._formEl);
        this.initAutoComplete(this._inputEl);

        if (this.clearButton) {
          this.initClearButton();
        }

        if (this.autoFocus === true && !this.query && this.autocompleteOnLoad) {
          this.focusInputElement();
        }
      }
    }, {
      key: "remove",
      value: function remove() {
        this._autocomplete.remove();

        _get(_getPrototypeOf(SearchComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "initClearButton",
      value: function initClearButton() {
        var _this2 = this;

        var button = DOM.query(this._container, '.js-yxt-SearchBar-clear');
        this._showClearButton = this._showClearButton || this.query;
        button.classList.toggle('yxt-SearchBar--hidden', !this._showClearButton);
        DOM.on(button, 'click', function () {
          _this2.query = '';
          _this2._showClearButton = false;
          button.classList.add('yxt-SearchBar--hidden');

          _this2.setState({});

          _this2.core.persistentStorage.set(StorageKeys.QUERY, _this2.query);

          _this2.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this2.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this2.core.setQuery(_this2.query); // Focus the input element after clearing the query, regardless of whether
          // or not the autoFocus option is enabled.
          // NOTE(amullings): This depends heavily on the fact that the re-renders
          // triggered by setState and core.setQuery happen synchronously; if this
          // stops being the case at some point, we'll need an alternative solution


          _this2.focusInputElement();
        });
        var input = DOM.query(this._container, this._inputEl);
        DOM.on(input, 'input', function (e) {
          var input = e.target.value;

          if (!_this2._showClearButton && input.length > 0) {
            _this2._showClearButton = true;
            button.classList.remove('yxt-SearchBar--hidden');
          } else if (_this2._showClearButton && input.length === 0) {
            _this2._showClearButton = false;
            button.classList.add('yxt-SearchBar--hidden');
          }
        });
      }
    }, {
      key: "initLocationPrompt",
      value: function initLocationPrompt() {
        var _this3 = this;

        this.core.globalStorage.on('update', StorageKeys.INTENTS, function (intent) {
          if (!intent.nearMe || _this3.core.globalStorage.getState(StorageKeys.GEOLOCATION) !== null) {
            return;
          }

          navigator.geolocation.getCurrentPosition(function (position) {
            _this3.core.globalStorage.set(StorageKeys.GEOLOCATION, {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              radius: position.coords.accuracy
            });

            _this3.search(_this3.query || '');
          });
        });
      }
      /**
       * A helper method to use for wiring up searching on form submission
       * @param {string} formSelector CSS selector to bind our submit handling to
       */

    }, {
      key: "initSearch",
      value: function initSearch(formSelector) {
        var _this4 = this;

        this._formEl = formSelector;

        this._container.classList.add('yxt-SearchBar-wrapper');

        var form = DOM.query(this._container, formSelector);

        if (!form) {
          throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._formEl, '`.');
        }

        DOM.on(form, 'submit', function (e) {
          e.preventDefault();
          var inputEl = form.querySelector(_this4._inputEl);
          var query = inputEl.value;
          var params = new SearchParams(window.location.search.substring(1));
          params.set('query', query); // If we have a redirectUrl, we want the form to be
          // serialized and submitted.

          if (typeof _this4.redirectUrl === 'string') {
            window.location.href = _this4.redirectUrl + '?' + params.toString();
            return false;
          }

          inputEl.blur();

          _this4.core.persistentStorage.set(StorageKeys.QUERY, query);

          _this4.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this4.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);

          _this4.core.setQuery(query);

          _this4.search(query);

          return false;
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this5 = this;

        this._inputEl = inputSelector;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          container: '.yxt-SearchBar-autocomplete',
          barKey: this._barKey,
          autoFocus: this.autoFocus && !this.autocompleteOnLoad,
          verticalKey: this._verticalKey,
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          inputEl: inputSelector,
          onSubmit: function onSubmit() {
            DOM.trigger(DOM.query(_this5._container, _this5._formEl), 'submit');
          }
        });
      }
      /**
       * @param {string} query
       */

    }, {
      key: "search",
      value: function search(query) {
        var _this6 = this;

        // Don't search if we recently searched,
        // if there's no query for universal search,
        // or if this is a twin searchbar
        if (this._throttled || !query && !this._verticalKey || !query && this._verticalKey && !this._allowEmptySearch || this._isTwin) {
          return;
        }

        this._throttled = true;
        setTimeout(function () {
          _this6._throttled = false;
        }, this._searchCooldown);

        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          return this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0
          });
        } else {
          // NOTE(billy) Temporary hack for DEMO
          // Remove me after the demo
          var nav = this.componentManager.getActiveComponent('Navigation');

          if (nav) {
            var tabs = nav.getState('tabs');
            var urls = {};

            if (tabs && Array.isArray(tabs)) {
              for (var i = 0; i < tabs.length; i++) {
                var params = new SearchParams(tabs[i].url.split('?')[1]);
                params.set('query', query);
                var url = tabs[i].baseUrl;

                if (params.toString().length > 0) {
                  url += '?' + params.toString();
                }

                urls[tabs[i].configId] = url;
              }
            }

            return this.core.search(query, urls);
          }

          return this.core.search(query);
        }
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(SearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          labelText: this.labelText,
          submitIcon: this.submitIcon,
          submitText: this.submitText,
          showClearButton: this._showClearButton,
          query: this.query || ''
        }, data));
      }
    }, {
      key: "focusInputElement",
      value: function focusInputElement() {
        DOM.query(this._container, this._inputEl).focus();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/search';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SearchBar';
      }
    }]);

    return SearchComponent;
  }(Component);

  /**
   * FilterSearchComponent is used for autocomplete using the FilterSearch backend.
   * It'll allow you to pick pre-set filters that are setup on the backend within
   * a vertical search context.
   *
   * @extends Component
   */

  var FilterSearchComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterSearchComponent, _Component);

    function FilterSearchComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterSearchComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterSearchComponent).call(this, config, systemConfig));
      /**
       * The input key for the vertical search configuration
       * @type {string}
       */

      _this._barKey = config.barKey || config.inputKey || null;
      /**
       * The vertical key for vertical search configuration
       * @type {string}
       */

      _this._verticalKey = config.verticalKey || null;
      /**
       * If true, store the filter value but do not search on change
       * @type {boolean}
       * @private
       */

      _this._storeOnChange = config.storeOnChange || false;
      /**
       * Query submission is based on a form as context.
       * Optionally provided, otherwise defaults to native form node within container
       * @type {string} CSS selector
       */

      _this._formEl = config.formSelector || 'form';
      /**
       * The input element used for searching and wires up the keyboard interaction
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._inputEl = config.inputEl || '.js-yext-query';
      /**
       * The title used, provided to the template as a data point
       * Optionally provided.
       * @type {string}
       */

      _this.title = config.title;
      /**
       * The search text used for labeling the input box, also provided to template.
       * Optionally provided
       * @type {string}
       */

      _this.searchText = config.searchText || 'What are you interested in?';
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = config.promptHeader || null;
      /**
       * Auto focuses the input box if set to true.
       * Optionally provided, defaults to false.
       * @type {boolean}
       */

      _this.autoFocus = config.autoFocus === true;
      /**
       * submitURL will force the search query submission to get
       * redirected to the URL provided.
       * Optional, defaults to null.
       *
       * If no redirectUrl provided, we keep the page as a single page app.
       *
       * @type {boolean}
       */

      _this.redirectUrl = config.redirectUrl || null;
      /**
       * The query string to use for the input box, provided to template for rendering.
       * Optionally provided
       * @type {string}
       */

      _this.query = config.query || _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.search();
      });
      /**
       * The filter string to use for the provided query
       * Optionally provided
       * @type {string}
       */


      _this.filter = config.filter || _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || '';

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.searchParameters = _this._buildSearchParameters(config.searchParameters);

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      return _this;
    }

    _createClass(FilterSearchComponent, [{
      key: "onCreate",
      value: function onCreate() {
        if (this.query && this.filter) {
          this.search();
        }
      }
    }, {
      key: "onMount",
      value: function onMount() {
        // Wire up our search handling and auto complete
        this.initAutoComplete(this._inputEl);

        if (this.autoFocus === true && this.query.length === 0) {
          DOM.query(this._container, this._inputEl).focus();
        }
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       */

    }, {
      key: "initAutoComplete",
      value: function initAutoComplete(inputSelector) {
        var _this2 = this;

        this._inputEl = inputSelector;
        this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.yxt-SearchBar-autocomplete',
          promptHeader: this.promptHeader,
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._verticalKey,
          barKey: this._barKey,
          searchParameters: this.searchParameters,
          onSubmit: function onSubmit(query, filter) {
            var params = new SearchParams(window.location.search.substring(1));
            params.set("".concat(_this2.name, ".query"), query);
            params.set("".concat(_this2.name, ".filter"), filter); // If we have a redirectUrl, we want the params to be
            // serialized and submitted.

            if (typeof _this2.redirectUrl === 'string') {
              window.location.href = _this2.redirectUrl + '?' + params.toString();
              return false;
            } // save the filter to storage for the next search


            _this2.query = query;
            _this2.filter = Filter.fromResponse(filter);

            _this2.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(_this2.name), _this2.query);

            _this2.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(_this2.name), _this2.filter);

            _this2.core.setFilter(_this2.name, _this2.filter);

            _this2.search();
          }
        });
      }
      /**
       * Perform the vertical search with all saved filters and query,
       * optionally redirecting based on config
       */

    }, {
      key: "search",
      value: function search() {
        if (this._storeOnChange) {
          return;
        }

        var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = filters[0];

        if (filters.length > 1) {
          totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
        }

        var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: searchQuery,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(FilterSearchComponent.prototype), "setState", this).call(this, Object.assign({
          title: this.title,
          searchText: this.searchText,
          query: this.query,
          filter: this.filter
        }, data));
      }
    }, {
      key: "_buildSearchParameters",
      value: function _buildSearchParameters(searchParameterConfigs) {
        var searchParameters = {
          sectioned: false,
          fields: []
        };

        if (searchParameterConfigs === undefined) {
          return searchParameters;
        }

        if (searchParameterConfigs.sectioned) {
          searchParameters.sectioned = searchParameterConfigs.sectioned;
        }

        searchParameters.fields = this._buildFields(searchParameterConfigs.fields);
        return searchParameters;
      }
    }, {
      key: "_buildFields",
      value: function _buildFields(fieldConfigs) {
        if (fieldConfigs === undefined) {
          return [];
        }

        return fieldConfigs.map(function (fc) {
          return _objectSpread({
            fetchEntities: false
          }, fc);
        });
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'search/filtersearch';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterSearch';
      }
    }]);

    return FilterSearchComponent;
  }(Component);

  var Keys = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    ESCAPE: 27,
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DELETE: 46,
    DOWN: 40,
    LEFT_OS_KEY: 91,
    RIGHT_OS_KEY: 92,
    SELECT_KEY: 93
  };

  var AutoCompleteComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(AutoCompleteComponent, _Component);

    function AutoCompleteComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AutoCompleteComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AutoCompleteComponent).call(this, opts, systemOpts));
      /**
       * Whether autocomplete is simple or filter
       * @type {boolean}
       */

      _this.isFilterSearch = opts.isFilterSearch || false;
      /**
       * The `barKey` in the vertical search to use for auto-complete
       * @type {string}
       */

      _this._barKey = opts.barKey || null;
      /**
       * The `verticalKey` of the vertical search to use for auto-complete
       * @type {string}
       */

      _this._verticalKey = opts.verticalKey || null;
      /**
       * A reference to the input el selector for auto complete
       * @type {string}
       */

      _this._inputEl = opts.inputEl || '.js-yext-query';
      /**
       * A selector for the autocomplete elementes
       * @type {string}
       */

      _this._autocompleteEls = opts.autoCompleteEls || '.js-yext-autocomlete-option';
      /**
       * An internal reference for the data-storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = "".concat(StorageKeys.AUTOCOMPLETE, ".").concat(_this.name);
      /**
       * An internal reference to the input value when typing.
       * We use this for resetting the state of the input value when other interactions (e.g. result navigation)
       * change based on interactions. For instance, hitting escape should reset the value to the original typed query.
       * @type {string}
       */

      _this._originalQuery = opts.originalQuery || '';
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current section we're navigating in.
       * @type {number}
       */

      _this._sectionIndex = 0;
      /**
       * Used for keyboard navigation through results.
       * An internal reference to the current result index we're navigating on.
       * @type {number}
       */

      _this._resultIndex = -1;
      /**
       * The query text to show as the first item for auto complete.
       * Optionally provided
       * @type {string}
       */

      _this.promptHeader = opts.promptHeader || null;
      /**
       * Whether the input is autocomatically focused or not
       * @type {boolean}
       */

      _this._autoFocus = opts.autoFocus || false;
      /**
       * Callback invoked when the `Enter` key is pressed on auto complete.
       */

      _this._onSubmit = opts.onSubmit || function () {};

      _this._searchParameters = opts.searchParameters || null;
      return _this;
    }
    /**
     * The aliased used by the component manager for creation.
     */


    _createClass(AutoCompleteComponent, [{
      key: "setState",

      /**
       * setState is overridden so that we can provide additional meta data
       * to the template (e.g. the sectionIndex and resultIndex), since
       * those are client-interaction specific values and aren't returned from the server.
       */
      value: function setState(data) {
        if (!this.isQueryInputFocused()) {
          this._sectionIndex = 0;
          this._resultIndex = -1;
          data = {};
        }

        _get(_getPrototypeOf(AutoCompleteComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          hasResults: this.hasResults(data),
          sectionIndex: this._sectionIndex,
          resultIndex: this._resultIndex,
          promptHeader: this._originalQuery.length === 0 ? this.promptHeader : null
        }));
      }
    }, {
      key: "isQueryInputFocused",
      value: function isQueryInputFocused() {
        return document.activeElement.className.includes(this._inputEl.substring(1));
      }
      /**
       * updateState is a helper to apply the current state with new client-state.
       */

    }, {
      key: "updateState",
      value: function updateState() {
        this.setState(this._state.get());
      }
      /**
       * onCreate is triggered when the component is constructed from the framework.
       * Once we're initalized, we wire up all of our user interactions
       */

    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        // Use the context of the parent component to find the input node.
        var queryInput = DOM.query(this._parentContainer, this._inputEl);

        if (!queryInput) {
          throw new Error('Could not initialize AutoComplete. Can not find {HTMLElement} `', this._inputEl, '`.');
        } // Disable the native autocomplete, autocorrect & spellcheck


        DOM.attributes(queryInput, {
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: 'false'
        }); // The user exits the input, so we want to reset the state and close
        // the auto complete
        // TODO(jdelerme): Close logic to be moved to parent

        DOM.on(document, 'click', function (e) {
          if (e.target.matches('.js-yxt-AutoComplete-wrapper *') || e.target.matches(_this2._inputEl)) {
            return;
          }

          _this2.close();
        }); // When a user focuses the input, we should populate the autocomplete based
        // on the current value

        DOM.on(queryInput, 'focus', function () {
          _this2.reset();

          _this2.autoComplete(queryInput.value);
        }); // Allow the user to navigate between the results using the keyboard

        DOM.on(queryInput, 'keydown', function (e) {
          _this2.handleNavigateResults(e.keyCode, e);

          _this2.handleSubmitResult(e.keyCode, queryInput.value, e);
        });

        if (this._autoFocus) {
          DOM.once(queryInput, 'click', function () {
            _this2.autoComplete(queryInput.value);
          });
        } // Allow the user to select a result with the mouse


        DOM.delegate(this._container, '.js-yext-autocomplete-option', 'click', function (evt, target) {
          var data = target.dataset;
          var val = data["short"];

          _this2.updateQuery(val);

          _this2._onSubmit(val, data.filter);

          _this2.close();
        }); // When the user is typing in the input, process the auto complete.

        DOM.on(queryInput, 'keyup', function (e) {
          _this2.handleTyping(e.keyCode, queryInput.value, e);
        });
      }
      /**
       * close will hide the auto complete results and reset the state.
       */

    }, {
      key: "close",
      value: function close() {
        this.setState({});
        this.reset();
      }
      /**
       * resets the client state to their original values and triggers
       * a template-rerender via updateState
       */

    }, {
      key: "reset",
      value: function reset() {
        this._sectionIndex = 0;
        this._resultIndex = -1;
        this.updateState();
      }
      /**
       * Helper method to update the input text
       * @param {string} optValue Option value provided.
       * If no value provided, we'll try to find it based on the selection indexes.
       */

    }, {
      key: "updateQuery",
      value: function updateQuery(optValue) {
        // Only want to update the query string if theres a value.
        // If one is provided, great.
        // Otherwise, lets try to find it from the current selection in the results.
        if (optValue === undefined) {
          var sections = this._state.get('sections');

          var results = sections[this._sectionIndex].results;
          optValue = results[this._resultIndex].shortValue;
        }

        var queryEl = DOM.query(this._parentContainer, this._inputEl);
        queryEl.value = optValue;
      }
    }, {
      key: "handleTyping",
      value: function handleTyping(key, value, e) {
        var ignoredKeys = [Keys.DOWN, Keys.UP, Keys.CTRL, Keys.ALT, Keys.SHIFT, Keys.LEFT, Keys.RIGHT, Keys.LEFT_OS_KEY, Keys.RIGHT_OS_KEY, Keys.ENTER, Keys.TAB, Keys.SELECT_KEY];

        if (ignoredKeys.indexOf(key) > -1) {
          return;
        } // User escapes out of auto complete, so we reset it to the original input


        if (key === Keys.ESCAPE) {
          this.updateQuery(this._originalQuery);
          this.close();
          return;
        } // Update the original value based on the user input


        this._originalQuery = value;
        this.reset();
        this.autoComplete(value);
      }
    }, {
      key: "autoComplete",
      value: function autoComplete(input) {
        if (this.isFilterSearch) {
          this.core.autoCompleteFilter(input, {
            namespace: this.name,
            verticalKey: this._verticalKey,
            barKey: this._barKey,
            searchParameters: this._searchParameters
          });
        } else if (this._verticalKey || this._barKey) {
          this.core.autoCompleteVertical(input, this.name, this._verticalKey, this._barKey);
        } else {
          this.core.autoCompleteUniversal(input, this.name);
        }
      }
      /**
       * returns true if we have results in any section
       * @returns boolean
       */

    }, {
      key: "hasResults",
      value: function hasResults(data) {
        if (!data) {
          return false;
        }

        var sections = data['sections'];

        if (!sections) {
          return false;
        }

        for (var i = 0; i < sections.length; i++) {
          var _data = sections[i];

          if (!_data) {
            continue;
          }

          var results = _data.results;

          if (!results) {
            continue;
          }

          if (results.length > 0) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "handleNavigateResults",
      value: function handleNavigateResults(key, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          return;
        } // Tabbing out or enter should close the auto complete.


        if (key === Keys.TAB) {
          this.close();
          return;
        }

        var results = sections[this._sectionIndex].results;

        if (key === Keys.UP) {
          e.preventDefault();

          if (this._resultIndex <= 0) {
            if (this._sectionIndex > 0) {
              this._sectionIndex--;
              this._resultIndex = sections[this._sectionIndex].results.length - 1;
            } else {
              this.updateQuery(this._originalQuery);
              this.reset();
              return;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex--;
          this.updateState();
          this.updateQuery();
          return;
        }

        if (key === Keys.DOWN) {
          e.preventDefault();

          if (this._resultIndex >= results.length - 1) {
            if (this._sectionIndex < sections.length - 1) {
              this._sectionIndex++;
              this._resultIndex = 0;
            }

            this.updateQuery();
            this.updateState();
            return;
          }

          this._resultIndex++;
          this.updateQuery();
          this.updateState();
        }
      }
    }, {
      key: "handleSubmitResult",
      value: function handleSubmitResult(key, value, e) {
        var sections = this._state.get('sections');

        if (sections === undefined || sections.length <= 0) {
          if (this.isFilterSearch) {
            this.autoComplete(value);
          }

          return;
        } // submit the search on enter


        if (key === Keys.ENTER) {
          e.preventDefault();

          if (this.isFilterSearch && this._resultIndex === -1) {
            return;
          }

          var filter = '';

          if (this._sectionIndex >= 0 && this._resultIndex >= 0) {
            filter = JSON.stringify(sections[this._sectionIndex].results[this._resultIndex].filter);
          }

          this.updateQuery(value);
          this._originalQuery = value;

          this._onSubmit(value, filter);

          this.close();
        }
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'search/autocomplete';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AutoComplete';
      }
    }]);

    return AutoCompleteComponent;
  }(Component);

  /**
   * SpellCheckComponent will support displaying suggestion, autocorrect and combined(maybe in the future)
   * provided from spelling correction.
   *
   * @extends Component
   */

  var SpellCheckComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(SpellCheckComponent, _Component);

    function SpellCheckComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, SpellCheckComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SpellCheckComponent).call(this, config, systemConfig));
      _this.moduleId = StorageKeys.SPELL_CHECK;
      return _this;
    }

    _createClass(SpellCheckComponent, [{
      key: "onCreate",
      value: function onCreate() {
        this.core.persistentStorage["delete"]('skipSpellCheck', true);
        this.core.persistentStorage["delete"]('queryTrigger', true);
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        return _get(_getPrototypeOf(SpellCheckComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          shouldShow: data.correctedQuery !== undefined,
          correctedQueryUrl: this._buildRedirectQueryUrl(data.correctedQuery, data.type),
          helpText: this._getHelpText(data.type)
        }, val));
      }
    }, {
      key: "_buildRedirectQueryUrl",
      value: function _buildRedirectQueryUrl(query, type) {
        if (query === undefined) {
          return '';
        }

        var params = new SearchParams(window.location.search.substring(1));
        params.set('query', query.value);
        params.set('skipSpellCheck', true);
        params.set('queryTrigger', type.toLowerCase());
        return '?' + params.toString();
      }
    }, {
      key: "_getHelpText",
      value: function _getHelpText(type) {
        switch (type) {
          case 'SUGGEST':
            return 'Did you mean:';

          default:
            return '';
        }
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/spellcheck';
      }
    }, {
      key: "type",
      get: function get() {
        return 'SpellCheck';
      }
    }]);

    return SpellCheckComponent;
  }(Component);

  /**
   * LocationBiasComponent will show the user where is used for location bias and allow user to
   * improve accuracy with HTML5 geolocation.
   *
   * @extends Component
   */

  var LocationBiasComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(LocationBiasComponent, _Component);

    function LocationBiasComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LocationBiasComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationBiasComponent).call(this, config, systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.LOCATION_BIAS;
      /**
       * The optional vertical key for vertical search configuration
       * If not provided, when location updated,
       * a universal search will be triggered.
       * @type {string}
       */
      // TODO: Remove config.verticalKey

      _this._verticalKey = config.verticalKey || _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey || null;
      /**
       * The element used for updating location
       * Optionally provided.
       * @type {string} CSS selector
       */

      _this._updateLocationEl = config.updateLocationEl || '.js-locationBias-update-location';
      _this._locationDisplayName = '';
      _this._accuracy = '';
      _this._allowUpdate = true;
      return _this;
    }

    _createClass(LocationBiasComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (!this._allowUpdate) {
          return;
        }

        this._disableLocationUpdateIfGeolocationDenied();

        DOM.on(this._updateLocationEl, 'click', function (e) {
          if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(function (position) {
              _this2.core.globalStorage.set(StorageKeys.GEOLOCATION, {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                radius: position.coords.accuracy
              });

              _this2._doSearch();
            }, function (err) {
              if (err.code === 1) {
                _this2._disableLocationUpdate();
              }
            });
          } // TODO: Should we throw error or warning here if no geolocation?

        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        this._locationDisplayName = data.locationDisplayName;
        this._accuracy = data.accuracy;
        return _get(_getPrototypeOf(LocationBiasComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          locationDisplayName: this._getLocationDisplayName(data),
          accuracyText: this._getAccuracyHelpText(data.accuracy),
          isPreciseLocation: data.accuracy === 'DEVICE' && this._allowUpdate,
          isUnknownLocation: data.accuracy === 'UNKNOWN',
          shouldShow: data.accuracy !== undefined,
          allowUpdate: this._allowUpdate
        }, val));
      }
    }, {
      key: "_getLocationDisplayName",
      value: function _getLocationDisplayName(data) {
        if (data.accuracy === 'UNKNOWN') {
          return 'Unknown Location';
        }

        return data.locationDisplayName;
      }
    }, {
      key: "_getAccuracyHelpText",
      value: function _getAccuracyHelpText(accuracy) {
        switch (accuracy) {
          case 'IP':
            return 'based on your internet address';

          case 'DEVICE':
            return 'based on your device';

          default:
            return '';
        }
      }
    }, {
      key: "_doSearch",
      value: function _doSearch() {
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (this._verticalKey) {
          var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.verticalSearch(this._verticalKey, {
            input: query,
            filter: JSON.stringify(totalFilter),
            offset: this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0,
            facetFilter: JSON.stringify(facetFilter)
          });
        } else {
          this.core.search(query);
        }
      }
    }, {
      key: "_disableLocationUpdateIfGeolocationDenied",
      value: function _disableLocationUpdateIfGeolocationDenied() {
        var _this3 = this;

        if ('permissions' in navigator) {
          navigator.permissions.query({
            name: 'geolocation'
          }).then(function (result) {
            if (result.state === 'denied') {
              _this3._disableLocationUpdate();
            }
          });
        }
      }
    }, {
      key: "_disableLocationUpdate",
      value: function _disableLocationUpdate() {
        this.core.globalStorage["delete"](StorageKeys.GEOLOCATION);
        this._allowUpdate = false;
        this.setState({
          locationDisplayName: this._locationDisplayName,
          accuracy: this._accuracy
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'search/locationbias';
      }
    }, {
      key: "type",
      get: function get() {
        return 'LocationBias';
      }
    }]);

    return LocationBiasComponent;
  }(Component);

  /** @module Facet */

  /**
   * Model representing a facet filter with the format of
   * {
   *   "field_name": [ Filters... ],
   *   ...
   * }
   *
   * @see {@link Filter}
   */
  var Facet =
  /*#__PURE__*/
  function () {
    function Facet() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Facet);

      Object.assign(this, data);
      Object.freeze(this);
    }
    /**
     * Create a facet filter from a list of Filters
     * @param  {...Filter} filters The filters to use in this facet
     * @returns {Facet}
     */


    _createClass(Facet, null, [{
      key: "fromFilters",
      value: function fromFilters(availableFieldIds) {
        var groups = {};
        availableFieldIds.forEach(function (fieldId) {
          groups[fieldId] = [];
        });

        for (var _len = arguments.length, filters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          filters[_key - 1] = arguments[_key];
        }

        var flatFilters = filters.flatMap(function (f) {
          return f.$or || f;
        });
        flatFilters.forEach(function (f) {
          var key = Object.keys(f)[0];

          if (!groups[key]) {
            groups[key] = [];
          }

          groups[key].push(f);
        });
        return new Facet(groups);
      }
    }]);

    return Facet;
  }();

  var FilterBoxConfig =
  /*#__PURE__*/
  function () {
    function FilterBoxConfig(config) {
      _classCallCheck(this, FilterBoxConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFilter = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFilterLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFilters = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFiltersLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The selector of the apply button
       * @type {string}
       */

      this.applyButtonSelector = config.applyButtonSelector || '.js-yext-filterbox-apply';
      /**
       * The list of filters to display and control, ignoring empty sections
       * @type {object[]}
       */

      this.filterConfigs = config.filters.filter(function (f) {
        return f.options.length !== 0;
      });
      /**
       * Whether or not this filterbox contains facets. This affects the
       * the way the filters are used in the search
       * @type {boolean}
       */

      this.isDynamic = config.isDynamic || false;
      this.validate();
    }

    _createClass(FilterBoxConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FilterBoxConfig;
  }();
  /**
   * Renders a set of filters, and searches with them when applied.
   * Multiple FilterBox components will AND together but will not share state.
   * @extends Component
   */


  var FilterBoxComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterBoxComponent, _Component);

    function FilterBoxComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterBoxComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterBoxComponent).call(this, config, systemConfig));
      _this.config = new FilterBoxConfig(config);

      if (!config.filters || !(config.filters instanceof Array)) {
        throw new AnswersComponentError('FilterBox requires filters to be provided as an array', 'FilterBox');
      }
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */


      _this._verticalKey = config.verticalKey || null;
      /**
       * The components created for each filter config
       * @type {Component[]}
       * @private
       */

      _this._filterComponents = [];
      /**
       * The current state of the filter components in the box
       * @type {Filter}
       * @private
       */

      _this._filters = [];

      if (!_this.config.showCount) {
        _this.config.filterConfigs.forEach(function (config) {
          config.options.forEach(function (option) {
            option.countLabel = null;
          });
        });
      }

      return _this;
    }

    _createClass(FilterBoxComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(FilterBoxComponent.prototype), "setState", this).call(this, Object.assign({}, data, this.config, {
          showReset: this.config.resetFilters,
          resetLabel: this.config.resetFiltersLabel,
          showApplyButton: !this.config.searchOnChange
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._filterComponents.length) {
          this._filterComponents.forEach(function (c) {
            return c.remove();
          });

          this._filterComponents = [];
          this._filters = [];
        } // Initialize filters from configs


        var _loop = function _loop(i) {
          var config = _this2.config.filterConfigs[i];

          var component = _this2.componentManager.create(config.type, Object.assign({}, config, _this2.config, {
            parentContainer: _this2._container,
            name: "".concat(_this2.name, ".filter").concat(i),
            storeOnChange: false,
            container: ".js-yext-filterbox-filter".concat(i),
            showReset: _this2.config.resetFilter,
            resetLabel: _this2.config.resetFilterLabel,
            showExpand: _this2.config.expand,
            onChange: function onChange(filter) {
              _this2.onFilterChange(i, filter);
            }
          }));

          component.mount();

          _this2._filterComponents.push(component);

          _this2._filters[i] = component.getFilter();

          _this2._saveFiltersToStorage();
        };

        for (var i = 0; i < this.config.filterConfigs.length; i++) {
          _loop(i);
        } // Initialize apply button


        if (!this.config.searchOnChange) {
          var button = DOM.query(this._container, this.config.applyButtonSelector);

          if (button) {
            DOM.on(button, 'click', function () {
              _this2._saveFiltersToStorage();

              _this2._search();
            });
          }
        } // Initialize reset button


        if (this.config.resetFilters) {
          DOM.on(DOM.query(this._container, '.js-yxt-FilterBox-reset'), 'click', this.resetFilters.bind(this));
        }
      }
    }, {
      key: "resetFilters",
      value: function resetFilters() {
        this._filterComponents.forEach(function (filter) {
          return filter.clearOptions();
        });
      }
      /**
       * Handle changes to child filter components
       * @param {number} index The index of the changed filter
       * @param {Filter} filter The new filter
       */

    }, {
      key: "onFilterChange",
      value: function onFilterChange(index, filter) {
        this._filters[index] = filter;

        if (this.config.searchOnChange) {
          this._saveFiltersToStorage();

          this._search();
        }
      }
      /**
       * Remove all filter components along with this component
       */

    }, {
      key: "remove",
      value: function remove() {
        this._filterComponents.forEach(function (c) {
          return c.remove();
        });

        _get(_getPrototypeOf(FilterBoxComponent.prototype), "remove", this).call(this);
      }
      /**
       * Save current filters to storage to be used in the next search
       * @private
       */

    }, {
      key: "_saveFiltersToStorage",
      value: function _saveFiltersToStorage() {
        var validFilters = this._filters.filter(function (f) {
          return f !== undefined && f !== null && Object.keys(f).length > 0;
        });

        if (this.config.isDynamic) {
          var availableFieldIds = this.config.filterConfigs.map(function (config) {
            return config.fieldId;
          });
          var combinedFilter = Facet.fromFilters.apply(Facet, [availableFieldIds].concat(_toConsumableArray(validFilters)));
          this.core.setFacetFilter(this.name, combinedFilter || {});
        } else {
          var _combinedFilter = validFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(validFilters)) : validFilters[0];

          this.core.setFilter(this.name, _combinedFilter || {});
        }
      }
      /**
       * Trigger a search with all filters in storage
       */

    }, {
      key: "_search",
      value: function _search() {
        var allFilters = this.core.globalStorage.getAll(StorageKeys.FILTER);
        var totalFilter = allFilters.length > 1 ? Filter.and.apply(Filter, _toConsumableArray(allFilters)) : allFilters[0];
        var query = this.core.globalStorage.getState(StorageKeys.QUERY);
        var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
        this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
        this.core.verticalSearch(this._verticalKey, {
          input: query,
          filter: JSON.stringify(totalFilter),
          facetFilter: JSON.stringify(facetFilter)
        });
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'filters/filterbox';
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterBox';
      }
    }]);

    return FilterBoxComponent;
  }(Component);

  /**
   * The currently supported controls
   * @type {string[]}
   */

  var SUPPORTED_CONTROLS = ['singleoption', 'multioption'];

  var FilterOptionsConfig =
  /*#__PURE__*/
  function () {
    function FilterOptionsConfig(config) {
      _classCallCheck(this, FilterOptionsConfig);

      /**
       * The type of control to display
       * @type {string}
       */
      this.control = config.control;
      /**
       * The list of filter options to display with checked status
       * @type {object[]}
       */

      this.options = config.options;
      /**
       * The label to be used in the legend
       * @type {string}
       */

      this.label = config.label || 'Filters';
      /**
       * The callback function to call when changed
       * @type {function}
       */

      this.onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       */


      this.storeOnChange = config.storeOnChange || false;
      /**
       * If true, show a button to reset the current filter selection
       * @type {boolean}
       */

      this.showReset = config.showReset || false;
      this.showReset = this.showReset & this.options.length > 0;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetLabel = config.resetLabel || 'reset';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      this.showMore = this.showMore && this.options.length > this.showMoreLimit;
      /**
       * If true, allow expanding and collapsing the group of facets
       * @type {boolean}
       */

      this.showExpand = config.showExpand === undefined ? true : config.showExpand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * The selector used for options in the template
       * @type {string}
       */

      this.optionSelector = config.optionSelector || '.js-yext-filter-option';
      this.validate();

      if (typeof config.previousOptions === 'string') {
        try {
          config.previousOptions = JSON.parse(config.previousOptions);
        } catch (e) {
          config.previousOptions = [];
        }
      }

      var selectedOptions = config.previousOptions || [];
      this.options = this.setDefaultSelectedValues(this.options, selectedOptions);
    }

    _createClass(FilterOptionsConfig, [{
      key: "setDefaultSelectedValues",
      value: function setDefaultSelectedValues(options, selectedOptions) {
        return options.map(function (o) {
          return _objectSpread({}, o, {
            selected: selectedOptions.length ? selectedOptions.includes(o.label) : o.selected
          });
        });
      }
    }, {
      key: "getSelectedCount",
      value: function getSelectedCount() {
        return this.options.reduce(function (numSelected, option) {
          return option.selected ? numSelected + 1 : numSelected;
        }, 0);
      }
    }, {
      key: "validate",
      value: function validate() {
        if (!this.control || !SUPPORTED_CONTROLS.includes(this.control)) {
          throw new AnswersComponentError('FilterOptions requires a valid "control" to be provided', 'FilterOptions');
        }

        if (!this.options) {
          throw new AnswersComponentError('FilterOptions component requires options to be provided', 'FilterOptions');
        }
      }
    }]);

    return FilterOptionsConfig;
  }();
  /**
   * Renders a set of options, each one representing a filter in a search.
   */


  var FilterOptionsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FilterOptionsComponent, _Component);

    function FilterOptionsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FilterOptionsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterOptionsComponent).call(this, config, systemConfig));

      var previousOptions = _this.core.globalStorage.getState(_this.name);

      _this.core.globalStorage["delete"](_this.name);
      /**
       * The component config
       * @type {FilterOptionsConfig}
       */


      _this.config = new FilterOptionsConfig(_objectSpread({
        previousOptions: previousOptions
      }, config));

      var selectedCount = _this.config.getSelectedCount();
      /**
       * True if the option list is expanded and visible
       * @type {boolean}
       */


      _this.expanded = _this.config.showExpand ? selectedCount > 0 : true;
      /**
       * True if all options are shown, false if some are hidden based on config
       * @type {boolean}
       */

      _this.allShown = false;
      return _this;
    }

    _createClass(FilterOptionsComponent, [{
      key: "setState",
      value: function setState(data) {
        var options = this.config.options;

        if (this.config.showMore && !this.allShown) {
          options = this.config.options.slice(0, this.config.showMoreLimit);
        }

        var selectedCount = this.config.getSelectedCount();

        _get(_getPrototypeOf(FilterOptionsComponent.prototype), "setState", this).call(this, Object.assign({}, data, _objectSpread({
          name: this.name.toLowerCase()
        }, this.config, {
          showReset: this.config.showReset && selectedCount > 0,
          expanded: this.expanded,
          allShown: this.allShown,
          selectedCount: selectedCount,
          isSingleOption: this.config.control === 'singleoption',
          options: options
        })));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        DOM.delegate(DOM.query(this._container, ".yxt-FilterOptions-options"), this.config.optionSelector, 'click', function (event) {
          _this2._updateOption(parseInt(event.target.dataset.index), event.target.checked);
        });
        var selectedCount = this.config.getSelectedCount(); // reset button

        if (this.config.showReset && selectedCount > 0) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-reset'), 'click', this.clearOptions.bind(this));
        } // show more/less button


        if (this.config.showMore) {
          DOM.on(DOM.query(this._container, '.yxt-FilterOptions-showToggle'), 'click', function () {
            _this2.allShown = !_this2.allShown;

            _this2.setState();
          });
        } // expand button


        if (this.config.showExpand) {
          var legend = DOM.query(this._container, '.yxt-FilterOptions-clickableLegend');
          DOM.on(legend, 'mousedown', function (click) {
            if (click.button === 0) {
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
          DOM.on(legend, 'keydown', function (key) {
            if (key.key === ' ' || key.key === 'Enter') {
              key.preventDefault();
              _this2.expanded = !_this2.expanded;

              _this2.setState();
            }
          });
        }
      }
    }, {
      key: "clearOptions",
      value: function clearOptions() {
        this.config.options = this.config.options.map(function (o) {
          return Object.assign({}, o, {
            selected: false
          });
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "updateListeners",
      value: function updateListeners() {
        var filter = this._buildFilter();

        if (this.config.storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.config.onChange(filter);
      }
    }, {
      key: "_updateOption",
      value: function _updateOption(index, selected) {
        if (this.config.control === 'singleoption') {
          this.config.options = this.config.options.map(function (o) {
            return Object.assign({}, o, {
              selected: false
            });
          });
        }

        this.config.options[index] = Object.assign({}, this.config.options[index], {
          selected: selected
        });
        this.updateListeners();
        this.setState();
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Clear all options
       */

    }, {
      key: "clear",
      value: function clear() {
        var elements = DOM.queryAll(this._container, this.config.optionSelector);
        elements.forEach(function (e) {
          return e.setAttribute('checked', 'false');
        });

        this._applyFilter();
      }
      /**
       * Build and return the Filter that represents the current state
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        var filters = this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.filter ? o.filter : Filter.equal(o.field, o.value);
        });
        this.core.persistentStorage.set(this.name, this.config.options.filter(function (o) {
          return o.selected;
        }).map(function (o) {
          return o.label;
        }));
        return filters.length > 0 ? Filter.group.apply(Filter, _toConsumableArray(filters)) : {};
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render, based on the control
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return "controls/filteroptions";
      }
    }, {
      key: "type",
      get: function get() {
        return 'FilterOptions';
      }
    }]);

    return FilterOptionsComponent;
  }(Component);

  var RangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(RangeFilterComponent, _Component);

    function RangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, RangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeFilterComponent).call(this, config, systemConfig));
      /**
       * The field to filter on
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The callback function to call when the filter value changes
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange || false;

      var minVal = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      if (typeof minVal === 'string') {
        try {
          minVal = Number.parseInt(minVal);
        } catch (e) {}
      }

      var maxVal = _this.core.globalStorage.getState("".concat(_this.name, ".max"));

      if (typeof minVal === 'string') {
        try {
          maxVal = Number.parseInt(maxVal);
        } catch (e) {}
      }
      /**
       * The current range represented
       * @type {object}
       * @private
       */


      _this._range = {
        min: minVal || config.initialMin || 0,
        max: maxVal || config.initialMax || 10
      };
      /**
       * The title to display for the range control
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to display for the min input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to display for the max input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The template to render
       * @type {string}
       * @private
       */

      _this._templateName = "controls/range";
      return _this;
    }

    _createClass(RangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(RangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          minValue: this._range.min,
          maxValue: this._range.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-range', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, Number.parseInt(event.target.value));
        });
      }
    }, {
      key: "setMin",
      value: function setMin(value) {
        this._updateRange('min', value);
      }
    }, {
      key: "setMax",
      value: function setMax(value) {
        this._updateRange('max', value);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Update the current range state
       * @param {string} key The range key to update
       * @param {number} value The new value for the key
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._range = Object.assign({}, this._range, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._range.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._range.max);

        this._onChange(filter);
      }
      /**
       * Build the filter representation of the current state
       * @returns {Filter}
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        return Filter.inclusiveRange(this._field, this._range.min, this._range.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RangeFilter';
      }
    }]);

    return RangeFilterComponent;
  }(Component);

  /**
   * A filter for a range of dates
   */

  var DateRangeFilterComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DateRangeFilterComponent, _Component);

    function DateRangeFilterComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DateRangeFilterComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DateRangeFilterComponent).call(this, config, systemConfig));
      /**
       * The api field this filter controls
       * @type {string}
       * @private
       */

      _this._field = config.field;
      /**
       * The title to display for the date range
       * @type {string}
       * @private
       */

      _this._title = config.title;
      /**
       * The optional label to show for the min date input
       * @type {string}
       * @private
       */

      _this._minLabel = config.minLabel || null;
      /**
       * The optional label to show for the max date input
       * @type {string}
       * @private
       */

      _this._maxLabel = config.maxLabel || null;
      /**
       * The callback used when a date is changed
       * @type {function}
       * @private
       */

      _this._onChange = config.onChange || function () {};
      /**
       * If true, stores the filter to storage on each change
       * @type {boolean}
       * @private
       */


      _this._storeOnChange = config.storeOnChange || false;
      /**
       * If true, this filter represents an exclusive range, rather than an inclusive one
       * @type {boolean}
       * @private
       */

      _this._isExclusive = config.isExclusive;
      /**
       * The template for this component
       * @private
       */

      _this._templateName = "controls/date";
      var today = new Date();
      var todayString = "".concat(today.getFullYear(), "-").concat("".concat(today.getMonth() + 1).padStart(2, '0'), "-").concat("".concat(today.getDate()).padStart(2, '0'));

      var minDate = _this.core.globalStorage.getState("".concat(_this.name, ".min"));

      var maxDate = _this.core.globalStorage.getState("".concat(_this.name, ".max"));
      /**
       * The current date range
       * @private
       */


      _this._date = {
        min: minDate || config.initialMin || todayString,
        max: maxDate || config.initialMax || todayString
      };
      return _this;
    }

    _createClass(DateRangeFilterComponent, [{
      key: "setState",
      value: function setState(data) {
        _get(_getPrototypeOf(DateRangeFilterComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          name: this.name,
          title: this._title,
          minLabel: this._minLabel,
          maxLabel: this._maxLabel,
          dateMin: this._date.min,
          dateMax: this._date.max
        }));
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        var _this2 = this;

        DOM.delegate(this._container, '.js-yext-date', 'change', function (event) {
          _this2._updateRange(event.target.dataset.key, event.target.value);
        });
      }
      /**
       * Set the min date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMin",
      value: function setMin(date) {
        this._updateRange('min', date);
      }
      /**
       * Set the max date to the one provided
       * @param {string} date Date to set in yyyy-mm-dd string format
       */

    }, {
      key: "setMax",
      value: function setMax(date) {
        this._updateRange('max', date);
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this._buildFilter();
      }
      /**
       * Updates the current state of the date range
       * @param {string} key The key for the date value
       * @param {string} value The string date value
       * @private
       */

    }, {
      key: "_updateRange",
      value: function _updateRange(key, value) {
        this._date = Object.assign({}, this._date, _defineProperty({}, key, value));
        this.setState();

        var filter = this._buildFilter();

        if (this._storeOnChange) {
          this.core.setFilter(this.name, filter);
        }

        this.core.persistentStorage.set("".concat(this.name, ".min"), this._date.min);
        this.core.persistentStorage.set("".concat(this.name, ".max"), this._date.max);

        this._onChange(filter);
      }
      /**
       * Construct an api filter with the current date state
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter() {
        if (this._date.min === '' || this._date.max === '') {
          return {};
        }

        return this._isExclusive ? Filter.exclusiveRange(this._field, this._date.min, this._date.max) : Filter.inclusiveRange(this._field, this._date.min, this._date.max);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'DateRangeFilter';
      }
    }]);

    return DateRangeFilterComponent;
  }(Component);

  var FacetsConfig =
  /*#__PURE__*/
  function () {
    function FacetsConfig(config) {
      _classCallCheck(this, FacetsConfig);

      /**
       * The title to display above the controls
       * @type {string}
       */
      this.title = config.title || 'Filters';
      /**
       * If true, display the number of results next to each facet
       * @type {boolean}
       */

      this.showCount = config.showCount === undefined ? true : config.showCount;
      /**
       * If true, trigger a search on each change to a filter
       * @type {boolean}
       */

      this.searchOnChange = config.searchOnChange || false;
      /**
       * If true, show a button to reset for each facet group
       * @type {boolean}
       */

      this.resetFacet = config.resetFacet || false;
      /**
       * The label to show for the reset button
       * @type {string}
       */

      this.resetFacetLabel = config.resetFacetLabel || 'reset';
      /**
       * If true, show a "reset all" button to reset all facets
       * @type {boolean}
       */

      this.resetFacets = config.resetFacets === undefined ? true : config.resetFacets;
      /**
       * The label to show for the "reset all" button
       * @type {string}
       */

      this.resetFacetsLabel = config.resetFacetsLabel || 'reset all';
      /**
       * The max number of facets to show before displaying "show more"/"show less"
       * @type {number}
       */

      this.showMoreLimit = config.showMoreLimit || 5;
      /**
       * The label to show for displaying more facets
       * @type {string}
       */

      this.showMoreLabel = config.showMoreLabel || 'show more';
      /**
       * The label to show for displaying less facets
       * @type {string}
       */

      this.showLessLabel = config.showLessLabel || 'show less';
      /**
       * If true, enable hiding excess facets in each group with a "show more"/"show less" button
       * @type {boolean}
       */

      this.showMore = config.showMore === undefined ? true : config.showMore;
      /**
       * If true, allow expanding and collapsing each group of facets
       * @type {boolean}
       */

      this.expand = config.expand === undefined ? true : config.expand;
      /**
       * If true, display the number of currently applied filters when collapsed
       * @type {boolean}
       */

      this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
      /**
       * Text to display on the apply button
       * @type {string}
       */

      this.applyLabel = config.applyLabel || 'apply';
      /**
       * The controls to use for each field. Each type of filter has a default
       * $eq : multioption (checkbox)
       * @type {Object}
       */

      this.fieldControls = config.fieldControls || {};
      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      this.applyButtonSelector = config.applyButtonSelector || null;
      this.validate();
    }

    _createClass(FacetsConfig, [{
      key: "validate",
      value: function validate() {}
    }]);

    return FacetsConfig;
  }();
  /**
   * Displays a set of dynamic filters returned from the backend
   * @extends Component
   */


  var FacetsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(FacetsComponent, _Component);

    function FacetsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, FacetsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FacetsComponent).call(this, config, systemConfig));
      _this.config = new FacetsConfig(config);
      /**
       * The vertical key for the search
       * @type {string}
       * @private
       */

      _this._verticalKey = config.verticalKey; // config.verticalKey || null;

      /**
       * The selector of the apply button
       * @type {string}
       * @private
       */

      _this._applyButtonSelector = config.applyButtonSelector || null;
      /**
       * An internal reference for the data storage to listen for updates from the server
       * @type {string}
       */

      _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
      /**
       * The filter box that displays the dynamic filters
       * @type {FilterBoxComponent}
       * @private
       */

      _this._filterbox = null;
      return _this;
    }

    _createClass(FacetsComponent, [{
      key: "remove",
      value: function remove() {
        if (this._filterbox) {
          this._filterbox.remove();
        }

        _get(_getPrototypeOf(FacetsComponent.prototype), "remove", this).call(this);
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this.core.enableDynamicFilters();

        if (this._filterbox) {
          this._filterbox.remove();
        }

        var _this$_state$get = this._state.get(),
            filters = _this$_state$get.filters;

        if (!filters) {
          return;
        }

        filters = filters.map(function (f) {
          return Object.assign({}, f, {
            type: 'FilterOptions',
            control: _this2.config.fieldControls[f.fieldId] || 'multioption'
          });
        });
        this._filterbox = this.componentManager.create('FilterBox', Object.assign({}, this.config, {
          parentContainer: this._container,
          name: "".concat(this.name, ".filterbox"),
          container: '.js-yxt-Facets',
          verticalKey: this._verticalKey,
          resetFilter: this.config.resetFacet,
          resetFilters: this.config.resetFacets,
          resetFilterLabel: this.config.resetFacetLabel,
          resetFiltersLabel: this.config.resetFacetsLabel,
          isDynamic: true,
          filters: filters
        }));

        this._filterbox.mount();
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName() {
        return 'filters/facets';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Facets';
      }
    }]);

    return FacetsComponent;
  }(Component);

  var METERS_PER_MILE = 1609.344;
  var DEFAULT_CONFIG = {
    /**
     * The radius, in miles, around the user's location to find results.
     * If location accuracy is low, a larger radius may be used automatically
     * @type {number}
     */
    radius: 50,

    /**
     * The vertical key to use
     * @type {string}
     */
    verticalKey: null,

    /**
     * If true, submits a search when the value is changed
     * @type {boolean}
     */
    searchOnChange: false,

    /**
     * The title to display
     * @type {string}
     */
    title: 'Location',

    /**
     * The label to display
     * @type {string}
     */
    label: 'Location',

    /**
     * The icon url to show in the geo button
     * @type {string}
     */
    geoButtonIcon: '',

    /**
     * The text to show in the geo button
     * @type {string}
     */
    geoButtonText: 'Use My Location',

    /**
     * The text to show when geolocation is enabled
     * @type {string}
     */
    enabledText: 'Current Location',

    /**
     * The text to show when loading the user's location
     * @type {string}
     */
    loadingText: 'Finding Your Location...',

    /**
     * The text to show if the user's location cannot be found
     * @type {string}
     */
    errorText: 'Could Not Find Your Location',

    /**
     * The CSS selector of the toggle button
     * @type {string}
     */
    buttonSelector: '.js-yxt-GeoLocationFilter-button',

    /**
     * The CSS selector of the query input
     * @type {string}
     */
    inputSelector: '.js-yxt-GeoLocationFilter-input'
  };
  /**
   * Renders a button that when clicked adds a static filter representing the user's location
   * @extends Component
   */

  var GeoLocationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(GeoLocationComponent, _Component);

    function GeoLocationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, GeoLocationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GeoLocationComponent).call(this, _objectSpread({}, DEFAULT_CONFIG, {}, config), systemConfig));
      /**
       * The query string to use for the input box, provided to template for rendering.
       * @type {string}
       */

      _this.query = _this.core.globalStorage.getState("".concat(StorageKeys.QUERY, ".").concat(_this.name)) || '';

      _this.core.globalStorage.on('update', "".concat(StorageKeys.QUERY, ".").concat(_this.name), function (q) {
        _this.query = q;

        _this.setState();
      });
      /**
       * The filter to use for the current query
       * @type {Filter}
       */


      _this.filter = _this.core.globalStorage.getState("".concat(StorageKeys.FILTER, ".").concat(_this.name)) || {};

      if (typeof _this.filter === 'string') {
        try {
          _this.filter = JSON.parse(_this.filter);
        } catch (e) {}
      }

      _this.core.globalStorage.on('update', "".concat(StorageKeys.FILTER, ".").concat(_this.name), function (f) {
        _this.filter = f;
      });

      return _this;
    }

    _createClass(GeoLocationComponent, [{
      key: "setState",
      value: function setState(data) {
        var placeholder = '';

        if (this._enabled) {
          placeholder = this._config.enabledText;
        }

        if (data.geoLoading) {
          placeholder = this._config.loadingText;
        }

        if (data.geoError) {
          placeholder = this._config.errorText;
        }

        _get(_getPrototypeOf(GeoLocationComponent.prototype), "setState", this).call(this, _objectSpread({}, data, {
          title: this._config.title,
          geoEnabled: this._enabled,
          query: this.query,
          labelText: this._config.label,
          enabledText: this._config.enabledText,
          loadingText: this._config.loadingText,
          errorText: this._config.errorText,
          geoButtonIcon: this._config.geoButtonIcon,
          geoValue: this._enabled || data.geoLoading || data.geoError ? '' : this.query,
          geoPlaceholder: placeholder,
          geoButtonText: this._config.geoButtonText
        }));
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._initAutoComplete(this._config.inputSelector);

        DOM.on(this._config.buttonSelector, 'click', function () {
          return _this2._toggleGeoFilter();
        });
      }
      /**
       * A helper method to wire up our auto complete on an input selector
       * @param {string} inputSelector CSS selector to bind our auto complete component to
       * @private
       */

    }, {
      key: "_initAutoComplete",
      value: function _initAutoComplete(inputSelector) {
        var _this3 = this;

        if (this._autocomplete) {
          this._autocomplete.remove();
        }

        this._autocomplete = this.componentManager.create('AutoComplete', {
          parentContainer: this._container,
          name: "".concat(this.name, ".autocomplete"),
          isFilterSearch: true,
          container: '.js-yxt-GeoLocationFilter-autocomplete',
          originalQuery: this.query,
          originalFilter: this.filter,
          inputEl: inputSelector,
          verticalKey: this._verticalKey,
          onSubmit: function onSubmit(query, filter) {
            _this3.query = query;
            _this3.filter = Filter.fromResponse(filter);

            _this3._saveDataToStorage(query, _this3.filter);

            _this3._enabled = false;
          }
        });
      }
      /**
       * Toggles the static filter representing the user's location
       * @private
       */

    }, {
      key: "_toggleGeoFilter",
      value: function _toggleGeoFilter() {
        var _this4 = this;

        if (!navigator.geolocation) {
          this.setState({
            geoError: true
          });
          return;
        }

        if (!this._enabled) {
          this.setState({
            geoLoading: true
          });
          navigator.geolocation.getCurrentPosition(function (position) {
            var filter = _this4._buildFilter(position);

            _this4._saveDataToStorage('', filter, position);

            _this4._enabled = true;

            _this4.setState({});

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.QUERY, ".").concat(_this4.name));

            _this4.core.persistentStorage["delete"]("".concat(StorageKeys.FILTER, ".").concat(_this4.name));
          }, function () {
            return _this4.setState({
              geoError: true
            });
          });
        }
      }
      /**
       * Saves the provided filter under this component's name
       * @param {string} query The query to save
       * @param {Filter} filter The filter to save
       * @param {Object} position The position to save
       * @private
       */

    }, {
      key: "_saveDataToStorage",
      value: function _saveDataToStorage(query, filter, position) {
        this.core.persistentStorage.set("".concat(StorageKeys.QUERY, ".").concat(this.name), query);
        this.core.persistentStorage.set("".concat(StorageKeys.FILTER, ".").concat(this.name), filter);
        this.core.setFilter(this.name, filter);

        if (position) {
          this.core.globalStorage.set(StorageKeys.GEOLOCATION, {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            radius: position.coords.accuracy
          });
        }

        if (this._config.searchOnChange) {
          var filters = this.core.globalStorage.getAll(StorageKeys.FILTER);
          var totalFilter = filters[0];

          if (filters.length > 1) {
            totalFilter = Filter.and.apply(Filter, _toConsumableArray(filters));
          }

          var searchQuery = this.core.globalStorage.getState(StorageKeys.QUERY) || '';
          var facetFilter = this.core.globalStorage.getAll(StorageKeys.FACET_FILTER)[0];
          this.core.persistentStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.globalStorage["delete"](StorageKeys.SEARCH_OFFSET);
          this.core.verticalSearch(this._config.verticalKey, {
            input: searchQuery,
            filter: JSON.stringify(totalFilter),
            facetFilter: JSON.stringify(facetFilter)
          });
        }
      }
      /**
       * Given a position, construct a Filter object
       * @param {Postition} position The position
       * @returns {Filter}
       * @private
       */

    }, {
      key: "_buildFilter",
      value: function _buildFilter(position) {
        var _position$coords = position.coords,
            latitude = _position$coords.latitude,
            longitude = _position$coords.longitude,
            accuracy = _position$coords.accuracy;
        var radius = Math.max(accuracy, this._config.radius * METERS_PER_MILE);
        return Filter.position(latitude, longitude, radius);
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'controls/geolocation';
      }
    }, {
      key: "type",
      get: function get() {
        return 'GeoLocationFilter';
      }
    }]);

    return GeoLocationComponent;
  }(Component);

  /**
   * EventTypes are explicit strings defined
   * for what the server expects for analytics.
   *
   * @enum
   */

  var EventTypes = {
    THUMBS_UP: 'THUMBS_UP',
    THUMBS_DOWN: 'THUMBS_DOWN'
  };

  var DirectAnswerComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(DirectAnswerComponent, _Component);

    function DirectAnswerComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DirectAnswerComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectAnswerComponent).call(this, config, systemConfig));
      /**
       * Recieve updates from storage based on this index
       * @type {StorageKey}
       */

      _this.moduleId = StorageKeys.DIRECT_ANSWER;
      /**
       * The form used for submitting the feedback
       * @type {string}
       */

      _this._formEl = config.formEl || '.js-directAnswer-feedback-form';
      /**
       * The `thumbs up` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsUpSelector = config.thumbsUpSelector || '.js-directAnswer-thumbUp';
      /**
       * The `thumbs down` css selector to bind ui interaction to for reporting
       * @type {string}
       */

      _this._thumbsDownSelector = config.thumbsDownSelector || '.js-directAnswer-thumbDown';
      /**
       * The display text for the View Details click to action link
       * @type {string}
       */

      _this._viewDetailsText = config.viewDetailsText || 'View Details';
      return _this;
    }

    _createClass(DirectAnswerComponent, [{
      key: "beforeMount",

      /**
       * beforeMount, only display the direct answer component if it has data
       */
      value: function beforeMount() {
        if (!this.hasState('answer')) {
          return false;
        }

        return true;
      }
      /**
       * When the DOM is constructed,
       * we want to wire up the behavior for interacting with the quality feedback reporting (thumbsup/down)
       */

    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        // Avoid bindings if the feedback has previously been submitted
        if (this.getState('feedbackSubmitted') === true) {
          return this;
        } // For WCAG compliance, the feedback should be a submittable form


        DOM.on(this._formEl, 'submit', function (e) {
          var formEl = e.target;
          var checkedValue = DOM.query(formEl, 'input:checked').value === 'true';

          _this2.reportQuality(checkedValue);

          _this2.updateState({
            'feedbackSubmitted': true
          });
        }); // Is this actually necessary? I guess it's only necessary if the
        // submit button is hidden.

        DOM.on(this._thumbsUpSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
        DOM.on(this._thumbsDownSelector, 'click', function () {
          DOM.trigger(_this2._formEl, 'submit');
        });
      }
      /**
       * updateState enables for partial updates (the delta between the old and new)
       * @type {object} The new state to apply to the old
       */

    }, {
      key: "updateState",
      value: function updateState() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var newState = Object.assign({}, this.getState(), state);
        this.setState(newState);
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(DirectAnswerComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          eventOptions: this.eventOptions(data),
          viewDetailsText: this._viewDetailsText
        }));
      }
    }, {
      key: "eventOptions",
      value: function eventOptions(data) {
        if (!data || Object.keys(data).length === 0) {
          return data;
        }

        return JSON.stringify({
          verticalConfigId: data.relatedItem.verticalConfigId,
          searcher: 'UNIVERSAL',
          entityId: data.relatedItem.data.id,
          ctaLabel: this._viewDetailsText.toUpperCase().replace(' ', '_')
        });
      }
      /**
       * reportQuality will send the quality feedback to analytics
       * @param {boolean} isGood true if the answer is what you were looking for
       */

    }, {
      key: "reportQuality",
      value: function reportQuality(isGood) {
        var eventType = isGood === true ? EventTypes.THUMBS_UP : EventTypes.THUMBS_DOWN;
        var event = new AnalyticsEvent(eventType).addOptions({
          'directAnswer': true
        });
        this.analyticsReporter.report(event);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/directanswer';
      }
    }, {
      key: "type",
      get: function get() {
        return 'DirectAnswer';
      }
    }]);

    return DirectAnswerComponent;
  }(Component);

  var ResultsItemComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ResultsItemComponent, _Component);

    function ResultsItemComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ResultsItemComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultsItemComponent).call(this, opts, systemConfig));
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = opts.verticalConfigId;
      /**
       * isUniversal is used for analytics and passed to children and is set to
       * true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = opts.isUniversal || false;
      return _this;
    }

    _createClass(ResultsItemComponent, [{
      key: "eventOptions",

      /**
       * helper to construct the eventOptions object for the title link
       * @param entityId The ID of the result item, if present
       * @param url The url of the result item, if present
       * @returns {string}
       */
      value: function eventOptions(entityId, url) {
        var options = {
          verticalConfigId: this._verticalConfigId,
          searcher: this._isUniversal ? 'UNIVERSAL' : 'VERTICAL'
        };

        if (entityId) {
          options.entityId = entityId;
        } else {
          options.url = url;
        }

        return JSON.stringify(options);
      }
      /**
       * passes eventOptions to the viewModel
       * @override
       * @param data
       * @returns {ResultsItemComponent}
       */

    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(ResultsItemComponent.prototype), "setState", this).call(this, Object.assign(data, {
          eventOptions: this.eventOptions(data.id, data.link)
        }));
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'ResultsItemComponent';
      }
    }]);

    return ResultsItemComponent;
  }(Component);

  var LocationResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(LocationResultsItemComponent, _ResultsItemComponent);

    function LocationResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, LocationResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(LocationResultsItemComponent).call(this, opts, systemConfig));
    }

    _createClass(LocationResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/locationresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'LocationResultsItemComponent';
      }
    }]);

    return LocationResultsItemComponent;
  }(ResultsItemComponent);

  var EventResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(EventResultsItemComponent, _ResultsItemComponent);

    function EventResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, EventResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(EventResultsItemComponent).call(this, opts, systemConfig));
    }

    _createClass(EventResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/eventresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'EventResultsItemComponent';
      }
    }]);

    return EventResultsItemComponent;
  }(ResultsItemComponent);

  var PeopleResultsItemComponent =
  /*#__PURE__*/
  function (_ResultsItemComponent) {
    _inherits(PeopleResultsItemComponent, _ResultsItemComponent);

    function PeopleResultsItemComponent() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PeopleResultsItemComponent);

      return _possibleConstructorReturn(this, _getPrototypeOf(PeopleResultsItemComponent).call(this, opts, systemOpts));
    }

    _createClass(PeopleResultsItemComponent, null, [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/peopleresultsitem';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'PeopleResultsItemComponent';
      }
    }]);

    return PeopleResultsItemComponent;
  }(ResultsItemComponent);

  /** @module MapProvider */

  /**
   * A MapProvider is an interface that represents that should be implemented
   * in order to integrate with a Third Party Map provider for
   * interactive maps. MapProviders are used by the MapComponent.
   *
   * Implementations should extend this interface.
   */
  var MapProvider =
  /*#__PURE__*/
  function () {
    function MapProvider() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MapProvider);

      /**
       * The API Key used for interacting with the map provider
       * @type {string}
       */
      this._apiKey = config.apiKey;
      /**
       * The zoom level of the map, defaults to 14
       * @type {number}
       */

      this._zoom = config.zoom || 14;
      /**
       * The default coordinates to display if there are no results returned
       * Only used if showEmptyMap is set to true
       * @type {Object}
       */

      this._defaultPosition = config.defaultPosition || {
        lat: 37.0902,
        lng: -95.7129
      };
      /**
       * Determines if an empty map should be shown when there are no results
       * @type {boolean}
       */

      this._showEmptyMap = config.showEmptyMap || false;
      /**
       * A reference to the underlying map instance, created by the external lib.
       * @type {number}
       */

      this._map = null;
      /**
       * Temporary boolean tracking whether or not the external JS library is loaded (see TODO below)
       * @type {boolean}
       */

      this._isLoaded = false;
      /**
       * Callback to invoke when a pin is clicked. The clicked item(s) are passed to the callback
       * @type {function}
       */

      this._onPinClick = config.onPinClick || null;
      /**
       * Callback to invoke once the Javascript is loaded
       * @type {function}
       */

      this._onLoaded = config.onLoaded || function () {};
      /**
       * The custom configuration override to use for the map markers
       * @type {Object|Function}
       */


      this._pinConfig = typeof config.pin === 'function' ? config.pin : Object.assign(MapProvider.DEFAULT_PIN_CONFIG, config.pin);
      /**
       * Determines whether or not to collapse pins at the same lat/lng
       * @type {boolean}
       */

      this._collapsePins = config.collapsePins || false;
    }
    /**
     * The default configuration to use for the map markers
     * @type {Object}
     * TODO(billy) Create a configuration model
     */


    _createClass(MapProvider, [{
      key: "onLoaded",
      value: function onLoaded(cb) {
        if (typeof cb !== 'function') {
          return;
        }

        this._onLoaded = cb;

        if (this.isLoaded()) {
          this._onLoaded();
        }
      }
    }, {
      key: "isLoaded",
      value: function isLoaded() {
        return this._isLoaded;
      }
    }, {
      key: "loadJS",
      value: function loadJS() {
        throw new Error('Unimplemented Method: loadJS');
      }
    }, {
      key: "init",
      value: function init(mapData) {
        // TODO(billy) This should be based off a promise that gets created from loadJS
        throw new Error('Unimplemented Method: init');
      }
      /**
       * Given a list of markers, combine markers with the same lat/lng into a single marker
       * @param {object[]} markers The markers to collapse
       */

    }, {
      key: "_collapseMarkers",
      value: function _collapseMarkers(markers) {
        var locationToItem = {};
        markers.forEach(function (m) {
          locationToItem["".concat(m.latitude).concat(m.longitude)] ? locationToItem["".concat(m.latitude).concat(m.longitude)].push(m) : locationToItem["".concat(m.latitude).concat(m.longitude)] = [m];
        });
        var collapsedMarkers = [];

        for (var _i = 0, _Object$entries = Object.entries(locationToItem); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              _markers = _Object$entries$_i[1];

          if (_markers.length > 1) {
            var collapsedMarker = {
              item: _markers.map(function (m) {
                return m.item;
              }),
              label: _markers.length,
              latitude: _markers[0].latitude,
              longitude: _markers[0].longitude
            };
            collapsedMarkers.push(collapsedMarker);
          } else {
            collapsedMarkers.push(_markers[0]);
          }
        }

        return collapsedMarkers;
      }
    }], [{
      key: "DEFAULT_PIN_CONFIG",
      get: function get() {
        return {
          icon: {
            anchor: null,
            // e.g. { x: 1, y: 1 }
            svg: null,
            url: null,
            scaledSize: null // e.g. { w: 20, h: 20 }

          },
          labelType: 'numeric'
        };
      }
    }]);

    return MapProvider;
  }();

  /* global google */

  /**
   * GoogleMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var GoogleMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(GoogleMapProvider, _MapProvider);

    function GoogleMapProvider(opts) {
      var _this;

      _classCallCheck(this, GoogleMapProvider);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GoogleMapProvider).call(this, opts)); // normalize because google's zoom is effectively 1 unit of difference away from mapbox zoom

      _this._zoomOffset = 1;
      _this._zoom += _this._zoomOffset;
      _this._clientId = opts.clientId;
      _this._signature = opts.signature;

      if (!_this.hasValidClientCredentials() && !_this._apiKey) {
        throw new Error('GoogleMapsProvider: Missing `apiKey` or {`clientId`, `signature`}');
      }

      return _this;
    }

    _createClass(GoogleMapProvider, [{
      key: "loadJS",
      value: function loadJS(onLoad) {
        var _this2 = this;

        if (DOM.query('#yext-map-js')) {
          this._isLoaded = true;

          if (typeof onLoad === 'function') {
            onLoad();
          }

          return;
        }

        var script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            _this2._isLoaded = true;

            _this2._onLoaded();
          },
          async: true,
          src: "https://maps.googleapis.com/maps/api/js?".concat(this.generateCredentials())
        });
        DOM.append('body', script);
      }
    }, {
      key: "generateCredentials",
      value: function generateCredentials() {
        if (this.hasValidClientCredentials()) {
          return "client=".concat(this._clientId);
        } else {
          return "key=".concat(this._apiKey);
        }
      }
    }, {
      key: "hasValidClientCredentials",
      value: function hasValidClientCredentials() {
        return this._clientId;
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this3 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        } // NOTE(billy) This timeout is a hack for dealing with async nature.
        // Only here for demo purposes, so we'll fix later.


        setTimeout(function () {
          var container = DOM.query(el);
          _this3.map = new google.maps.Map(container, {
            zoom: _this3._zoom,
            center: _this3.getCenterMarker(mapData)
          }); // Apply our search data to our GoogleMap

          if (mapData && mapData.mapMarkers.length) {
            (function () {
              var collapsedMarkers = _this3._collapsePins ? _this3._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
              var googleMapMarkerConfigs = GoogleMapMarkerConfig.from(collapsedMarkers, _this3._pinConfig, _this3.map);
              var bounds = new google.maps.LatLngBounds();

              var _loop = function _loop(i) {
                var marker = new google.maps.Marker(googleMapMarkerConfigs[i]);

                if (_this3._onPinClick) {
                  marker.addListener('click', function () {
                    return _this3._onPinClick(collapsedMarkers[i].item);
                  });
                }

                bounds.extend(marker.position);
              };

              for (var i = 0; i < googleMapMarkerConfigs.length; i++) {
                _loop(i);
              }

              if (googleMapMarkerConfigs.length >= 2) {
                _this3.map.fitBounds(bounds);
              }
            })();
          }
        }, 100);
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? {
          lng: mapData.mapCenter.longitude,
          lat: mapData.mapCenter.latitude
        } : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return GoogleMapProvider;
  }(MapProvider); // TODO(billy) Move to own class
  var GoogleMapMarkerConfig =
  /*#__PURE__*/
  function () {
    function GoogleMapMarkerConfig(opts) {
      _classCallCheck(this, GoogleMapMarkerConfig);

      /**
       * A reference to the google map, that the marker is appended to
       * @type {GoogleMap}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        lat: undefined,
        lng: undefined
      };
      /**
       * The properties/settings of the icon used for the marker
       * e.g. {
       *        anchor: { x: 0, y: 0 }
       *        url: 'path/to/url.jpg'
       *        scaledSize: { w: 0, h: 0 }
       *       }
       *
       * @type {object}
       */

      this.icon = opts.icon || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {GoogleMapMarkerConfig[]} googleMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(GoogleMapMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(googleMapMarkerConfigs) {
        var serializedMarkers = [];
        googleMapMarkerConfigs.forEach(function (marker) {
          serializedMarkers.push("markers=label:".concat(marker.label, "|").concat(marker.position.lat, ",").concat(marker.position.lng));
        });
        return serializedMarkers.join('&');
      }
      /**
       * Converts the storage data model of markers into GoogleAPIMarker
       * @param {object[]} markers The data of the marker
       * @param {(Object|function)} pinConfig The configuration to apply to the marker
       * @param {GoogleMap} map reference to the google map to apply the marker to
       * @returns {GoogleMapMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var googleMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          } // Transform our Configuration Object into the expected
          // Google API format.


          var icon = {};

          if (pinConfigObj.anchor) {
            icon.anchor = google.maps.Point(pinConfigObj.anchor.x, pinConfigObj.anchor.y);
          }

          if (pinConfigObj.scaledSize) {
            icon.scaledSize = new google.maps.Size(pinConfigObj.scaledSize.w, pinConfigObj.scaledSize.h);
          }

          if (pinConfigObj.url) {
            icon.url = pinConfigObj.url;
          }

          if (pinConfigObj.svg) {
            icon.url = "data:image/svg+xml;charset=utf-8, ".concat(encodeURIComponent(pinConfigObj.svg));
          }

          var label;

          if (pinConfigObj.label) {
            label = pinConfigObj.label;
          } else {
            label = marker.label.toString();
          } // NOTE(billy) Google maps doesn't handle empty icon objects nicely
          // Make google maps happy if no settings for icon are provided;


          if (Object.keys(icon).length === 0) {
            icon = undefined;
          }

          googleMapMarkerConfigs.push(new GoogleMapMarkerConfig({
            map: map,
            position: {
              lat: marker.latitude,
              lng: marker.longitude
            },
            icon: icon,
            label: label
          }));
        });
        return googleMapMarkerConfigs;
      }
    }]);

    return GoogleMapMarkerConfig;
  }();

  /* global mapboxgl */

  /**
   * MapBoxMapProvider is an implementation of a MapProvider
   * that handles the integration with the third party API to expose maps.
   * @extends MapProvider
   */

  var MapBoxMapProvider =
  /*#__PURE__*/
  function (_MapProvider) {
    _inherits(MapBoxMapProvider, _MapProvider);

    function MapBoxMapProvider() {
      _classCallCheck(this, MapBoxMapProvider);

      return _possibleConstructorReturn(this, _getPrototypeOf(MapBoxMapProvider).apply(this, arguments));
    }

    _createClass(MapBoxMapProvider, [{
      key: "loadJS",

      /**
       * Load the external JS Library
       * @param {function} onLoad An optional callback to invoke once the JS is loaded.
       */
      value: function loadJS(onLoad) {
        var _this = this;

        var script = DOM.createEl('script', {
          id: 'yext-map-js',
          onload: function onload() {
            _this._isLoaded = true;
            mapboxgl.accessToken = _this._apiKey;

            if (typeof onLoad === 'function') {
              onLoad();
            }

            if (typeof _this._onLoaded === 'function') {
              _this._onLoaded();
            }
          },
          async: true,
          src: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'
        });
        var css = DOM.createEl('link', {
          id: 'yext-map-css',
          rel: 'stylesheet',
          href: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css'
        });
        DOM.append('body', css);
        DOM.append('body', script);
      }
    }, {
      key: "init",
      value: function init(el, mapData) {
        var _this2 = this;

        if ((!mapData || mapData.mapMarkers.length <= 0) && !this._showEmptyMap) {
          this._map = null;
          return this;
        }

        var container = DOM.query(el);
        this._map = new mapboxgl.Map({
          container: container,
          zoom: this._zoom,
          style: 'mapbox://styles/mapbox/streets-v9',
          center: this.getCenterMarker(mapData)
        });

        if (mapData && mapData.mapMarkers.length) {
          (function () {
            var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
            var mapboxMapMarkerConfigs = MapBoxMarkerConfig.from(collapsedMarkers, _this2._pinConfig, _this2._map);
            var bounds = new mapboxgl.LngLatBounds();

            var _loop = function _loop(i) {
              var wrapper = mapboxMapMarkerConfigs[i].wrapper;
              var coords = new mapboxgl.LngLat(mapboxMapMarkerConfigs[i].position.longitude, mapboxMapMarkerConfigs[i].position.latitude);
              var marker = new mapboxgl.Marker(wrapper).setLngLat(coords);
              bounds.extend(marker.getLngLat());
              marker.addTo(_this2._map);

              if (_this2._onPinClick) {
                marker.getElement().addEventListener('click', function () {
                  return _this2._onPinClick(collapsedMarkers[i].item);
                });
              }
            };

            for (var i = 0; i < mapboxMapMarkerConfigs.length; i++) {
              _loop(i);
            }

            if (mapboxMapMarkerConfigs.length >= 2) {
              _this2._map.fitBounds(bounds, {
                padding: 50
              });
            }
          })();
        }
      }
    }, {
      key: "getCenterMarker",
      value: function getCenterMarker(mapData) {
        return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? [mapData.mapCenter.longitude, mapData.mapCenter.latitude] : {
          lng: this._defaultPosition.lng,
          lat: this._defaultPosition.lat
        };
      }
    }]);

    return MapBoxMapProvider;
  }(MapProvider);
  var MapBoxMarkerConfig =
  /*#__PURE__*/
  function () {
    function MapBoxMarkerConfig(opts) {
      _classCallCheck(this, MapBoxMarkerConfig);

      /**
       * A reference to the mapbox map, that the marker is appended to
       * @type {MapBox}
       */
      this.map = opts.map || undefined;
      /**
       * The coordinates of the marker (lat/lng)
       * @type {Object}
       */

      this.position = opts.position || {
        latitude: undefined,
        longitude: undefined
      };
      /**
       * The html element to be used as the map marker
       * @type {object}
       */

      this.wrapper = opts.wrapper || undefined;
      /**
       * The label of the marker to use
       * @type {string}
       */

      this.label = opts.label || undefined;
      /**
       * The url of the pin for the static map
       * @type {string}
       */

      this.staticMapPin = opts.staticMapPin || undefined;
    }
    /**
     * Serializes an array of marker configs
     * @param {MapBoxMarkerConfig[]} mapboxMapMarkerConfigs
     * @returns {string[]}
     */


    _createClass(MapBoxMarkerConfig, null, [{
      key: "serialize",
      value: function serialize(mapboxMapMarkerConfigs) {
        var serializedMarkers = [];
        mapboxMapMarkerConfigs.forEach(function (marker) {
          if (marker.staticMapPin) {
            serializedMarkers.push("url-".concat(marker.staticMapPin, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          } else {
            serializedMarkers.push("pin-s-".concat(marker.label, "(").concat(marker.position.longitude, ",").concat(marker.position.latitude, ")"));
          }
        });
        return serializedMarkers.join(',');
      }
      /**
       * Converts the storage data model of markers into MapBoxMarkerConfig
       * @param {MapBox} A reference to the mapbox map to apply the marker to
       * @param {object[]} markers The data of the marker
       * @param {Object} pinConfig The configuration to apply to the marker
       * @returns {MapBoxMarkerConfig[]}
       */

    }, {
      key: "from",
      value: function from(markers, pinConfig, map) {
        var mapboxMapMarkerConfigs = [];

        if (!Array.isArray(markers)) {
          markers = [markers];
        }

        markers.forEach(function (marker) {
          // Support configuration as a function
          var pinConfigObj = pinConfig;

          if (typeof pinConfig === 'function') {
            pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
          }

          var wrapper = pinConfigObj.wrapper ? pinConfigObj.wrapper : null;
          var staticMapPin = pinConfigObj.staticMapPin ? pinConfigObj.staticMapPin : null;
          mapboxMapMarkerConfigs.push(new MapBoxMarkerConfig({
            map: map,
            position: {
              latitude: marker.latitude,
              longitude: marker.longitude
            },
            wrapper: wrapper,
            label: marker.label,
            staticMapPin: staticMapPin
          }));
        });
        return mapboxMapMarkerConfigs;
      }
    }]);

    return MapBoxMarkerConfig;
  }();

  var ProviderTypes = {
    'google': GoogleMapProvider,
    'mapbox': MapBoxMapProvider
  };

  var MapComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(MapComponent, _Component);

    function MapComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, MapComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MapComponent).call(this, opts, systemOpts));
      /**
       * Bind this component to listen to the storage based on this key
       */

      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      /**
       * An aliased used to determine the type of map provider to use
       * @type {string}
       */

      _this._mapProvider = opts.mapProvider;

      if (!_this._mapProvider || !(_this._mapProvider.toLowerCase() in ProviderTypes)) {
        throw new Error('MapComponent: Invalid Map Provider; must be `google` or `mapBox`');
      }
      /**
       * A reference to an instance of the {MapProvider} that's constructed
       * @type {MapProvider}
       */


      _this._map = null;
      return _this;
    }

    _createClass(MapComponent, [{
      key: "getProviderInstance",
      // TODO(billy) Make ProviderTypes a factory class
      value: function getProviderInstance(type) {
        return new ProviderTypes[type.toLowerCase()](this._config);
      }
    }, {
      key: "onCreate",
      value: function onCreate() {
        this._map = this.getProviderInstance(this._mapProvider);

        this._map.loadJS();
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        this._map.onLoaded(function () {
          _this2._map.init(_this2._container, _this2.getState('map'));
        });
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        if (Object.keys(data).length === 0) {
          return this;
        }

        return _get(_getPrototypeOf(MapComponent.prototype), "setState", this).call(this, data, val);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/map';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Map';
      }
    }]);

    return MapComponent;
  }(Component);

  var ResultType = {
    EVENT: 'event',
    LOCATION: 'location',
    PEOPLE: 'people'
  };

  var ResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(ResultsComponent, _Component);

    function ResultsComponent() {
      var _this$_itemConfig;

      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultsComponent).call(this, config, systemConfig));
      /**
       * verticalConfigId used for analytics and passed to children
       * @type {string}
       * @private
       */

      _this._verticalConfigId = config.verticalConfigId;
      /**
       * isUniversal is set to true if this component is added by the UniversalResultsComponent
       * @type {boolean}
       * @private
       */

      _this._isUniversal = config.isUniversal || false;
      _this.moduleId = StorageKeys.VERTICAL_RESULTS;
      _this._itemConfig = (_this$_itemConfig = {
        global: {
          render: null,
          template: null
        }
      }, _defineProperty(_this$_itemConfig, EventResultsItemComponent.type, {
        render: null,
        template: null
      }), _defineProperty(_this$_itemConfig, LocationResultsItemComponent.type, {
        render: null,
        template: null
      }), _defineProperty(_this$_itemConfig, PeopleResultsItemComponent.type, {
        render: null,
        template: null
      }), _this$_itemConfig);

      if (config.renderItem === undefined && config._parentOpts !== undefined) {
        config.renderItem = config._parentOpts.renderItem;
      }

      if (config.itemTemplate === undefined && config._parentOpts !== undefined) {
        config.itemTemplate = config._parentOpts.itemTemplate;
      }

      _this.configureItem({
        render: config.renderItem,
        template: config.itemTemplate
      });
      /**
       * The url to the universal page for the no results page to link back to with current query
       * @type {string|null}
       */


      _this._universalUrl = config.universalUrl;
      return _this;
    }

    _createClass(ResultsComponent, [{
      key: "mount",
      value: function mount() {
        if (Object.keys(this.getState()).length > 0) {
          _get(_getPrototypeOf(ResultsComponent.prototype), "mount", this).call(this);
        }

        return this;
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        var results = data.results || [];
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        return _get(_getPrototypeOf(ResultsComponent.prototype), "setState", this).call(this, Object.assign({
          results: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          includeMap: this._config.includeMap,
          mapConfig: this._config.mapConfig,
          eventOptions: this.eventOptions(),
          universalUrl: this._universalUrl ? this._universalUrl + window.location.search : '',
          showNoResults: results.length === 0,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }), val);
      }
      /**
       * helper to construct the eventOptions object for the view all link
       * @returns {string}
       */

    }, {
      key: "eventOptions",
      value: function eventOptions() {
        return JSON.stringify({
          verticalConfigId: this._verticalConfigId
        });
      }
    }, {
      key: "configureItem",
      value: function configureItem(config) {
        if (typeof config.render === 'function') {
          this._itemConfig.global.render = config.render;
        } else {
          for (var key in config.render) {
            this.setItemRender(key, config.render[key]);
          }
        }

        if (typeof config.template === 'string') {
          this._itemConfig.global.template = config.template;
        } else {
          for (var _key in config.template) {
            this.setItemTemplate(_key, config.template[_key]);
          }
        }
      }
    }, {
      key: "setItemTemplate",
      value: function setItemTemplate(type, template) {
        var clazz = this.getItemComponent(type);
        this._itemConfig[clazz.type].template = template;
      }
    }, {
      key: "setItemRender",
      value: function setItemRender(type, render) {
        var clazz = this.getItemComponent(type);
        this._itemConfig[clazz.type].render = render;
      }
    }, {
      key: "getItemComponent",
      value: function getItemComponent(type) {
        var comp = ResultsItemComponent;

        switch (type) {
          case ResultType.EVENT:
            comp = EventResultsItemComponent;
            break;

          case ResultType.LOCATION:
            comp = LocationResultsItemComponent;
            break;

          case ResultType.PEOPLE:
            comp = PeopleResultsItemComponent;
            break;
        }

        return comp;
      }
    }, {
      key: "addChild",
      value: function addChild(data, type, opts) {
        // TODO(billy) Refactor the way configuration and data flows
        // through top level components to child components.
        if (type === ResultsItemComponent.type) {
          var clazz = this.getItemComponent(data.type);

          if (clazz) {
            type = clazz.type;
          }
        } else if (type === MapComponent.type) {
          data = {
            map: data
          };
          var newOpts = Object.assign({}, this._config.mapConfig, opts);
          return _get(_getPrototypeOf(ResultsComponent.prototype), "addChild", this).call(this, data, type, newOpts);
        } // Apply the proper item renders to the the components
        // have just been constructed. Prioritize global over individual items.


        var comp = _get(_getPrototypeOf(ResultsComponent.prototype), "addChild", this).call(this, data, type, Object.assign(opts, {
          verticalConfigId: this._verticalConfigId,
          isUniversal: this._isUniversal
        }));

        var globalConfig = this._itemConfig.global;
        var itemConfig = this._itemConfig[comp.type];
        var hasGlobalRender = typeof globalConfig.render === 'function';
        var hasGlobalTemplate = typeof globalConfig.template === 'string';

        if (hasGlobalRender) {
          comp.setRender(globalConfig.render);
        }

        if (hasGlobalTemplate) {
          comp.setTemplate(globalConfig.template);
        }

        if (!itemConfig) {
          return comp;
        }

        if (!hasGlobalRender && itemConfig.render) {
          comp.setRender(itemConfig.render);
        } // Apply template specific situation


        if (!hasGlobalTemplate && itemConfig.template) {
          comp.setTemplate(itemConfig.template);
        }

        return comp;
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/results';
      }
    }, {
      key: "duplicatesAllowed",
      get: function get() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'VerticalResults';
      }
    }]);

    return ResultsComponent;
  }(Component);

  var AccordionResultsComponent =
  /*#__PURE__*/
  function (_ResultsComponent) {
    _inherits(AccordionResultsComponent, _ResultsComponent);

    function AccordionResultsComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, AccordionResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AccordionResultsComponent).call(this, config, systemConfig));
      /**
       * base selector to use when finding DOM targets
       * @type {string}
       */

      _this._selectorBase = config.selectorBase || '.js-yxt-AccordionResult';
      /**
       * collapsed state class
       * @type {string}
       */

      _this.collapsedClass = config.collapsedClass || 'is-collapsed';
      /**
       * vertical config id is required for analytics
       * @type {string|null}
       */

      _this.verticalConfigId = config.verticalConfigId || config._parentOpts.verticalConfigId || null;
      return _this;
    }
    /**
     * the component type
     * @returns {string}
     * @override
     */


    _createClass(AccordionResultsComponent, [{
      key: "onMount",

      /**
       * overrides onMount to add bindings to change the height on click
       * @returns {AccordionResultsComponent}
       * @override
       */
      value: function onMount() {
        var _this2 = this;

        _get(_getPrototypeOf(AccordionResultsComponent.prototype), "onMount", this).call(this); // NOTE(amullings): This is a hack, since currently components with siblings
        // have no way of referring to their own element. We have to grab the first
        // element since sections get added in reverse.


        var selfEl = this._container.firstElementChild;
        var accordionEls = DOM.queryAll(selfEl, this._selectorBase);
        accordionEls.forEach(function (accordionEl) {
          var toggleEl = DOM.query(accordionEl, _this2.toggleSelector());
          var contentEl = DOM.query(accordionEl, _this2.bodySelector());

          _this2.changeHeight(contentEl, accordionEl);

          toggleEl.addEventListener('click', function () {
            _this2.handleClick(accordionEl, toggleEl, contentEl);
          });
        });
        return this;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        return _get(_getPrototypeOf(AccordionResultsComponent.prototype), "setState", this).call(this, Object.assign({}, data, {
          modifier: this.verticalConfigId
        }));
      }
      /**
       * click handler for the accordion toggle button
       * @param wrapperEl {HTMLElement} the toggle container
       * @param toggleEl {HTMLElement} the button
       * @param contentEl {HTMLElement} the toggle target
       */

    }, {
      key: "handleClick",
      value: function handleClick(wrapperEl, toggleEl, contentEl) {
        var event = new AnalyticsEvent(this.isCollapsed(wrapperEl) ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
          verticalConfigId: this.verticalConfigId,
          entityId: toggleEl.dataset.entityId
        });
        wrapperEl.classList.toggle(this.collapsedClass);
        this.changeHeight(contentEl, wrapperEl);
        toggleEl.setAttribute('aria-expanded', this.isCollapsed(wrapperEl) ? 'false' : 'true');
        this.analyticsReporter.report(event);
      }
      /**
       * returns true if the element is currently collapsed
       * @param wrapperEl {HTMLElement} the toggle container
       * @returns {boolean}
       */

    }, {
      key: "isCollapsed",
      value: function isCollapsed(wrapperEl) {
        if (!wrapperEl) {
          return false;
        }

        return wrapperEl.classList.contains(this.collapsedClass);
      }
      /**
       * toggles the height between 0 and the content height for smooth animation
       * @param targetEl {HTMLElement}
       * @param wrapperEl {HTMLElement}
       */

    }, {
      key: "changeHeight",
      value: function changeHeight(targetEl, wrapperEl) {
        targetEl.style.height = "".concat(this.isCollapsed(wrapperEl) ? 0 : targetEl.scrollHeight, "px");
      }
      /**
       * helper for composing child element selectors
       * @param child {string}
       * @returns {string}
       */

    }, {
      key: "buildSelector",
      value: function buildSelector(child) {
        return "".concat(this._selectorBase).concat(child);
      }
      /**
       * helper for the toggle button selector
       * @returns {string}
       */

    }, {
      key: "toggleSelector",
      value: function toggleSelector() {
        return this.buildSelector('-toggle');
      }
      /**
       * helper for the content element selector
       * @returns {string}
       */

    }, {
      key: "bodySelector",
      value: function bodySelector() {
        return this.buildSelector('-body');
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/resultsaccordion';
      }
    }, {
      key: "type",
      get: function get() {
        return 'AccordionResults';
      }
    }]);

    return AccordionResultsComponent;
  }(ResultsComponent);

  var UniversalResultsComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(UniversalResultsComponent, _Component);

    function UniversalResultsComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, UniversalResultsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UniversalResultsComponent).call(this, opts, systemOpts));
      _this.moduleId = StorageKeys.UNIVERSAL_RESULTS;
      _this._limit = opts.limit || 10;
      return _this;
    }

    _createClass(UniversalResultsComponent, [{
      key: "init",
      value: function init(opts) {
        _get(_getPrototypeOf(UniversalResultsComponent.prototype), "init", this).call(this, opts);

        return this;
      }
    }, {
      key: "setState",
      value: function setState(data, val) {
        var sections = data.sections || [];
        var searchState = data.searchState || SearchStates.PRE_SEARCH;
        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "setState", this).call(this, Object.assign({
          sections: []
        }, data, {
          isPreSearch: searchState === SearchStates.PRE_SEARCH,
          isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
          isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
          showNoResults: sections.length === 0,
          query: this.core.globalStorage.getState(StorageKeys.QUERY)
        }), val);
      }
    }, {
      key: "addChild",
      value: function addChild() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var type = arguments.length > 1 ? arguments[1] : undefined;
        var opts = arguments.length > 2 ? arguments[2] : undefined;

        var childOpts = _objectSpread({}, opts, {}, this.getChildConfig([data['verticalConfigId']]));

        if (childOpts.useAccordion === true) {
          return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, AccordionResultsComponent.type, childOpts);
        }

        return _get(_getPrototypeOf(UniversalResultsComponent.prototype), "addChild", this).call(this, data, type, childOpts);
      }
    }, {
      key: "getChildConfig",
      value: function getChildConfig(configId) {
        var defaultConfig = {
          verticalConfigId: configId,
          isUniversal: true
        };
        var config = this._config.config;

        if (config === undefined) {
          return defaultConfig;
        }

        return Object.assign(defaultConfig, this._config['config'][configId] || this._config['config']);
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'results/universalresults';
      }
    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'UniversalResults';
      }
    }]);

    return UniversalResultsComponent;
  }(Component);

  var PaginationComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(PaginationComponent, _Component);

    function PaginationComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PaginationComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PaginationComponent).call(this, config, systemConfig));
      /**
       * The vertical key to use for searches
       * @type {string}
       * @private
       */

      _this._verticalKey = _this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).verticalKey;

      if (typeof _this._verticalKey !== 'string') {
        throw new AnswersComponentError('verticalKey not provided, but necessary for pagination', 'PaginationComponent');
      }
      /**
       * If true, displays the first page button
       * @type {boolean}
       * @private
       */


      _this._firstPageButtonEnabled = config.showFirst === undefined ? true : config.showFirst;
      /**
       * If true, displays the last page button
       * @type {boolean}
       * @private
       */

      _this._lastPageButtonEnabled = config.showLast === undefined ? true : config.showLast;
      /**
       * Options to include with all analytic events sent by this component
       * @type {object}
       * @private
       */

      _this._analyticsOptions = {
        verticalKey: _this._verticalKey
      };
      var offset = _this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

      _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));

      _this.core.globalStorage.on('update', StorageKeys.SEARCH_OFFSET, function (offset) {
        if (typeof offset === 'number') {
          return;
        }

        _this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, Number(offset));
      });

      _this.core.globalStorage.on('update', StorageKeys.VERTICAL_RESULTS, function (results) {
        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
          _this.setState();
        }
      });

      return _this;
    }

    _createClass(PaginationComponent, [{
      key: "onMount",
      value: function onMount() {
        var _this2 = this;

        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;

        if (!showControls) {
          return;
        }

        var previousPageButton = DOM.query(this._container, '.js-yxt-Pagination-previous');
        var nextPageButton = DOM.query(this._container, '.js-yxt-Pagination-next');
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        DOM.on(previousPageButton, 'click', function () {
          return _this2.updatePage(offset - limit);
        });
        DOM.on(nextPageButton, 'click', function () {
          return _this2.updatePage(offset + limit);
        });

        if (this._firstPageButtonEnabled) {
          var firstPageButton = DOM.query(this._container, '.js-yxt-Pagination-first');
          DOM.on(firstPageButton, 'click', function () {
            return _this2.updatePage(0);
          });
        }

        if (this._lastPageButtonEnabled) {
          var lastPageButton = DOM.query(this._container, '.js-yxt-Pagination-last');
          DOM.on(lastPageButton, 'click', function () {
            return _this2.updatePage(maxPage * limit);
          });
        }
      }
    }, {
      key: "updatePage",
      value: function updatePage(offset) {
        this.scrollToTop();
        this.core.globalStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.persistentStorage.set(StorageKeys.SEARCH_OFFSET, offset);
        this.core.verticalPage(this._verticalKey, offset);
      }
    }, {
      key: "scrollToTop",
      value: function scrollToTop() {
        document.documentElement.scrollTop = 0; // Safari

        document.body.scrollTop = 0;
      }
    }, {
      key: "setState",
      value: function setState(data) {
        var results = this.core.globalStorage.getState(StorageKeys.VERTICAL_RESULTS) || {};
        var offset = this.core.globalStorage.getState(StorageKeys.SEARCH_OFFSET) || 0;
        var limit = this.core.globalStorage.getState(StorageKeys.SEARCH_CONFIG).limit;
        var pageNumber = offset / limit;
        var showControls = results.searchState === 'search-complete' && results.resultsCount > limit;
        var isMoreResults = results.resultsCount > offset + limit;
        var maxPage = Math.trunc((results.resultsCount - 1) / limit);
        return _get(_getPrototypeOf(PaginationComponent.prototype), "setState", this).call(this, _objectSpread({
          showControls: showControls,
          firstPageButtonEnabled: this._firstPageButtonEnabled,
          lastPageButtonEnabled: this._lastPageButtonEnabled,
          pageNumber: pageNumber + 1,
          showFirstPageButton: pageNumber > 1,
          showPreviousPageButton: pageNumber > 0,
          showNextPageButton: isMoreResults,
          showLastPageButton: pageNumber < maxPage - 1
        }, data));
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName() {
        return 'results/pagination';
      }
    }, {
      key: "type",
      get: function get() {
        return 'Pagination';
      }
    }]);

    return PaginationComponent;
  }(Component);

  /**
   * Configurable options for the component
   * @type {Object}
   */

  var DEFAULT_CONFIG$1 = {
    /**
     * The entity identifier that the question is associated with.
     * This is typically an organization object
     * @type {number}
     */
    'entityId': null,

    /**
     * The main CSS selector used to reference the form for the component.
     * @type {string} CSS selector
     */
    'formSelector': 'form',

    /**
     * An optional label to use for the e-mail address input
     * @type {string}
     */
    'emailLabel': 'Email',

    /**
     * An optional label to use for the name input
     * @type {string}
     */
    'nameLabel': 'Name',

    /**
     * An optional label to use for the question
     * @type {string}
     */
    'questionLabel': 'Question',

    /**
     * An optional label to use for the Privacy Policy
     * @type {string}
     */
    'privacyPolicyText': 'By submitting my email address, I consent to being contacted via email at the address provided.',

    /**
     * The label to use for the Submit button
     * @type {string}
     */
    'buttonLabel': 'Submit',

    /**
     * The title to display in the title bar
     * @type {string}
     */
    'sectionTitle': 'Ask a Question',

    /**
     * The description to display in the title bar
     * @type {string}
     */
    'teaser': 'Can’t find what you\'re looking for? Ask a question below.',

    /**
     * The name of the icon to use in the title bar
     * @type {string}
     */
    'sectionTitleIconName': 'support',

    /**
     * The text to display in the feedback form ahead of the Question input
     * @type {string}
     */
    'description': 'Enter your question and contact information, and we\'ll get back to you with a response shortly.',

    /**
     * The placeholder text for required inputs
     * @type {string}
     */
    'requiredInputPlaceholder': '(required)',

    /**
     * The placeholder text for the question text area
     * @type {string}
     */
    'questionInputPlaceholder': 'Enter your question here',

    /**
     * The confirmation text to display after successfully submitting feedback
     * @type {string}
     */
    'questionSubmissionConfirmationText': 'Thank you for your question!',

    /**
     * The default privacy policy url label
     * @type {string}
    */
    'privacyPolicyUrlLabel': 'Learn more here.',

    /**
     * The default privacy policy url
     * @type {string}
     */
    'privacyPolicyUrl': '',

    /**
     * The default privacy policy error text, shown when the user does not agree
     * @type {string}
     */
    'privacyPolicyErrorText': '* You must agree to the privacy policy to submit a question.',

    /**
     * The default email format error text, shown when the user submits an invalid email
     * @type {string}
     */
    'emailFormatErrorText': '* Please enter a valid email address.',

    /**
     * Whether or not this component is expanded by default.
     * @type {boolean}
     */
    'expanded': true
  };
  /**
   * QuestionSubmissionComponent is a component that creates a form
   * thats displayed whenever a query is run. It enables the user
   * to submit questions that they cant find the answer for.
   */

  var QuestionSubmissionComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(QuestionSubmissionComponent, _Component);

    function QuestionSubmissionComponent() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, QuestionSubmissionComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(QuestionSubmissionComponent).call(this, Object.assign({}, DEFAULT_CONFIG$1, config), systemConfig));
      /**
       * Reference to the storage model
       * @type {string}
       */

      _this.moduleId = StorageKeys.QUESTION_SUBMISSION;
      /**
       * Reference to the locale as set in the global config
       * @type {string}
       */

      _this.locale = _this.core.globalStorage.getState(StorageKeys.LOCALE);
      /**
       * NOTE(billy) if this is a pattern we want to follow for configuration
       * we should bake it into the core class.
       */

      _this.validateConfig();

      _this.core.globalStorage.on('update', StorageKeys.QUERY_ID, function () {
        var questionText = _this.core.globalStorage.getState(StorageKeys.QUERY);

        _this.setState(new QuestionSubmission({
          questionText: questionText,
          expanded: _this._config.expanded
        }));
      });

      return _this;
    }
    /**
     * The template to render
     * @returns {string}
     * @override
     */


    _createClass(QuestionSubmissionComponent, [{
      key: "validateConfig",

      /**
       * validationConfig contains a bunch of rules
       * that are used to validate aginst configuration provided by the user
       */
      value: function validateConfig() {
        if (this._config.entityId === null || this._config.entityId === undefined) {
          throw new AnswersComponentError('`entityId` is a required configuration option for Question Submission', 'QuestionSubmission');
        }
      }
    }, {
      key: "beforeMount",
      value: function beforeMount() {
        // Avoid mounting the component if theres no data
        // Note, 1 because `config` is always part of the state.
        return Object.keys(this.getState()).length > 1;
      }
    }, {
      key: "onMount",
      value: function onMount() {
        var triggerEl = DOM.query(this._container, '.js-content-visibility-toggle');

        if (triggerEl !== null) {
          this.bindFormToggle(triggerEl);
        }

        var formEl = DOM.query(this._container, this._config.formSelector);

        if (formEl === null) {
          return;
        }

        this.bindFormFocus(formEl);
        this.bindFormSubmit(formEl);
      }
      /**
       * bindFormFocus will wire up the DOM focus event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormFocus",
      value: function bindFormFocus(formEl) {
        var _this2 = this;

        if (this.analyticsReporter === null) {
          return;
        }

        var questionText = DOM.query(formEl, '.js-question-text');
        DOM.on(questionText, 'focus', function () {
          _this2.analyticsReporter.report(_this2.getAnalyticsEvent('QUESTION_FOCUS'));
        });
      }
      /**
       * bindFormSubmit handles submitting the question to the server,
       * and submits an event to serverside reporting
       * @param {HTMLElement} formEl
       */

    }, {
      key: "bindFormSubmit",
      value: function bindFormSubmit(formEl) {
        var _this3 = this;

        DOM.on(formEl, 'submit', function (e) {
          e.preventDefault();

          _this3.analyticsReporter.report(_this3.getAnalyticsEvent('QUESTION_SUBMIT')); // TODO(billy) we probably want to disable the form from being submitted twice


          var errors = _this3.validate(formEl);

          var formData = _this3.parse(formEl);

          if (Object.keys(errors).length) {
            return _this3.setState(new QuestionSubmission(formData, errors));
          }

          _this3.core.submitQuestion({
            'entityId': _this3._config.entityId,
            'questionLanguage': _this3.locale,
            'site': 'FIRSTPARTY',
            'name': formData.name,
            'email': formData.email,
            'questionText': formData.questionText,
            'questionDescription': formData.questionDescription
          })["catch"](function (error) {
            _this3.setState(new QuestionSubmission(formData, {
              'network': 'We\'re sorry, an error occurred.'
            }));

            throw error;
          });
        });
      }
      /**
       * bindFormToggle handles expanding and mimimizing the component's form.
       * @param {HTMLElement} triggerEl
       */

    }, {
      key: "bindFormToggle",
      value: function bindFormToggle(triggerEl) {
        var _this4 = this;

        DOM.on(triggerEl, 'click', function (e) {
          var formData = _this4.getState();

          _this4.setState(new QuestionSubmission(_objectSpread({}, formData, {
            'expanded': !formData.questionExpanded,
            'submitted': formData.questionSubmitted
          }), formData.errors));
        });
      }
      /**
       * Takes the form, and builds a object that represents the input names
       * and text fields.
       * @param {HTMLElement} formEl
       * @returns {object}
       */

    }, {
      key: "parse",
      value: function parse(formEl) {
        var inputFields = DOM.queryAll(formEl, '.js-question-field');

        if (!inputFields || inputFields.length === 0) {
          return {};
        }

        var obj = {};

        for (var i = 0; i < inputFields.length; i++) {
          var val = inputFields[i].value;

          if (inputFields[i].type === 'checkbox') {
            val = inputFields[i].checked;
          }

          obj[inputFields[i].name] = val;
        }

        return obj;
      }
      /**
       * Validates the fields for correct formatting
       * @param {HTMLElement} formEl
       * @returns {Object} errors object if any errors found
       */

    }, {
      key: "validate",
      value: function validate(formEl) {
        var errors = {};
        var fields = DOM.queryAll(formEl, '.js-question-field');

        for (var i = 0; i < fields.length; i++) {
          if (!fields[i].checkValidity()) {
            if (i === 0) {
              // set focus state on first error
              fields[i].focus();
            }

            switch (fields[i].name) {
              case 'email':
                errors['emailError'] = true;

                if (!fields[i].validity.valueMissing) {
                  errors['emailErrorText'] = this._config.emailFormatErrorText;
                }

                break;

              case 'name':
                errors['nameError'] = true;
                break;

              case 'privacyPolicy':
                errors['privacyPolicyErrorText'] = this._config.privacyPolicyErrorText;
                errors['privacyPolicyError'] = true;
                break;

              case 'questionText':
                errors['questionTextError'] = true;
                break;
            }
          }
        }

        return errors;
      }
      /**
       * Returns an options object describing the context of a reportable event
       */

    }, {
      key: "getAnalyticsEvent",
      value: function getAnalyticsEvent(eventType) {
        var analyticsEvent = new AnalyticsEvent(eventType);
        analyticsEvent.addOptions({
          verticalConfigId: this._verticalKey,
          searcher: this._verticalKey ? 'VERTICAL' : 'UNIVERSAL'
        });
        return analyticsEvent;
      }
    }], [{
      key: "defaultTemplateName",
      value: function defaultTemplateName(config) {
        return 'questions/questionsubmission';
      }
      /**
       * The public interface alias for the component
       * @returns {string}
       * @override
       */

    }, {
      key: "type",
      get: function get() {
        return 'QASubmission';
      }
    }]);

    return QuestionSubmissionComponent;
  }(Component);

  var SVGIcon =
  /*#__PURE__*/
  function () {
    /**
     * @param config
     * @param config.name
     * @param config.path
     * @param config.complexContents
     * @param config.viewBox
     * @constructor
     */
    function SVGIcon(config) {
      _classCallCheck(this, SVGIcon);

      /**
       * the name of the icon
       */
      this.name = config.name;
      /**
       * an svg path definition
       */

      this.path = config.path;
      /**
       * if not using a path, a the markup for a complex SVG
       */

      this.complexContents = config.complexContents;
      /**
       * the view box definition, defaults to 24x24
       * @type {string}
       */

      this.viewBox = config.viewBox || '0 0 24 24';
      /**
       * actual contents used
       */

      this.contents = this.pathDefinition();
    }

    _createClass(SVGIcon, [{
      key: "pathDefinition",
      value: function pathDefinition() {
        if (this.complexContents) {
          return this.complexContents;
        }

        return "<path d=\"".concat(this.path, "\"></path>");
      }
      /**
       * returns the svg markup
       */

    }, {
      key: "markup",
      value: function markup() {
        return "<svg viewBox=\"".concat(this.viewBox, "\" xmlns=\"http://www.w3.org/2000/svg\">").concat(this.contents, "</svg>");
      }
    }]);

    return SVGIcon;
  }();

  var thumbIcon = new SVGIcon({
    name: 'thumb',
    viewBox: '0 0 24 22',
    path: 'M15.273 1H5.455c-.906 0-1.68.55-2.008 1.342L.153 10.097A2.19 2.19 0 000 10.9v2.2c0 1.21.982 2.2 2.182 2.2h6.883L8.03 20.327l-.033.352c0 .451.186.869.48 1.166L9.633 23l7.178-7.249a2.16 2.16 0 00.644-1.551v-11c0-1.21-.982-2.2-2.182-2.2zm0 13.2l-4.735 4.774L11.75 13.1H2.182v-2.2l3.273-7.7h9.818v11zM19.636 1H24v13.2h-4.364V1z'
  });

  var receiptIcon = new SVGIcon({
    name: 'receipt',
    path: 'M14.606 9.5c-.671-.515-1.591-.833-2.606-.833 1.015 0 1.935.318 2.606.833zm-7.985 0H1.655A1.66 1.66 0 010 7.833V3.667C0 2.747.741 2 1.655 2h20.69A1.66 1.66 0 0124 3.667v4.166A1.66 1.66 0 0122.345 9.5h-4.966V22H6.621V9.5h2.773H6.62zm10.758-1.667h4.966V3.667H1.655v4.166h4.966v-2.5h10.758v2.5z'
  });

  var pantheonIcon = new SVGIcon({
    name: 'pantheon',
    path: 'M9.947 16.598h.252V9.412h-.252a.432.432 0 01-.23-.065c-.07-.043-.106-.093-.106-.15L9.15 7.82v-.15c0-.044.028-.08.084-.109a.691.691 0 01.105-.086.254.254 0 01.146-.043H13.6c.056 0 .104.015.146.043.042.03.091.058.147.086a.271.271 0 01.063.108c.014.043.007.093-.02.15l-.42 1.378a.374.374 0 01-.147.15.37.37 0 01-.19.065h-.251v7.186h.252a.37.37 0 01.189.065c.07.043.119.093.147.15l.42 1.378c.027.028.034.071.02.129a.275.275 0 01-.063.129 1.364 1.364 0 00-.147.086.254.254 0 01-.146.043H9.485a.254.254 0 01-.146-.043.691.691 0 01-.105-.086c-.056-.029-.084-.072-.084-.13v-.128l.461-1.377c0-.058.035-.108.105-.151a.432.432 0 01.231-.065zm5.792 0h.252V9.412h-.252a.432.432 0 01-.23-.065.374.374 0 01-.148-.15l-.42-1.377c-.027-.029-.034-.072-.02-.13a.275.275 0 01.063-.129c.056-.028.105-.057.146-.086a.254.254 0 01.147-.043h4.114c.055 0 .104.015.146.043a.691.691 0 01.105.086c.056.03.084.072.084.13v.129l-.42 1.377a.374.374 0 01-.146.15.432.432 0 01-.231.065h-.21v7.186h.21a.43.43 0 01.23.065c.07.043.12.093.148.15l.42 1.378v.15c0 .043-.029.08-.085.108a.691.691 0 01-.105.086.254.254 0 01-.146.043h-4.114a.254.254 0 01-.147-.043 1.364 1.364 0 00-.146-.086.271.271 0 01-.063-.108c-.014-.043-.007-.093.02-.15l.42-1.377a.374.374 0 01.147-.151.432.432 0 01.231-.065zm-11.794-.086h.252V9.498h-.252a.334.334 0 01-.21-.065.386.386 0 01-.126-.193l-.42-1.377a.248.248 0 01-.02-.172.854.854 0 01.063-.173c.028-.057.07-.1.126-.129a.365.365 0 01.168-.043h4.07c.057 0 .113.015.169.043a.278.278 0 01.126.13.854.854 0 01.062.172.248.248 0 01-.02.172l-.42 1.377a.386.386 0 01-.126.193.334.334 0 01-.21.065h-.21v7.014h.21c.084 0 .154.029.21.086a.673.673 0 01.126.172l.42 1.378a.248.248 0 01.02.172.854.854 0 01-.062.172.278.278 0 01-.126.129.365.365 0 01-.168.043H3.526a.365.365 0 01-.168-.043.278.278 0 01-.126-.13.854.854 0 01-.063-.171.248.248 0 01.02-.172l.42-1.378a.673.673 0 01.126-.172.281.281 0 01.21-.086zM1.763 6.658a.717.717 0 01-.504-.194.644.644 0 01-.21-.495v-.43a.73.73 0 01.105-.387.68.68 0 01.273-.259C4.309 3.402 6.54 2.276 8.121 1.515 9.702.755 10.493.361 10.493.332c.531-.258.972-.366 1.322-.323.35.043.734.165 1.154.366l8.31 4.518c.14.058.245.144.315.259a.73.73 0 01.105.387v.43c0 .201-.07.366-.21.495a.717.717 0 01-.504.194H1.763zm-.714 13.34a.54.54 0 01.168-.387.516.516 0 01.378-.172h19.642c.168 0 .308.057.42.172a.541.541 0 01.168.387v.818a.522.522 0 01-.168.408.605.605 0 01-.42.151H1.595a.551.551 0 01-.378-.15.522.522 0 01-.168-.41v-.817zm21.405 2.022c.14 0 .266.058.378.173a.592.592 0 01.168.43v.818a.541.541 0 01-.168.387.516.516 0 01-.378.172L.546 23.957a.516.516 0 01-.378-.172.541.541 0 01-.168-.387v-.818a.59.59 0 01.168-.43.516.516 0 01.378-.173l21.908.043z'
  });

  var micIcon = new SVGIcon({
    name: 'mic',
    path: 'M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z'
  });

  var directionsIcon = new SVGIcon({
    name: 'directions',
    path: 'M23.649 11.154L12.846.35a1.195 1.195 0 00-1.692 0L.35 11.154a1.195 1.195 0 000 1.692L11.154 23.65a1.195 1.195 0 001.692 0L23.65 12.846c.468-.456.468-1.212 0-1.692zm-9.254 3.853v-3.001H9.593v3.6h-2.4v-4.8c0-.66.54-1.2 1.2-1.2h6.002V6.604l4.2 4.2-4.2 4.202z'
  });

  var calendarIcon = new SVGIcon({
    name: 'calendar',
    path: 'M18.111 13.2H12v6h6.111v-6zM16.89 0v2.4H7.11V0H4.667v2.4H3.444c-1.356 0-2.432 1.08-2.432 2.4L1 21.6C1 22.92 2.088 24 3.444 24h17.112C21.9 24 23 22.92 23 21.6V4.8c0-1.32-1.1-2.4-2.444-2.4h-1.223V0H16.89zm3.667 21.6H3.444V8.4h17.112v13.2z'
  });

  var calloutIcon = new SVGIcon({
    name: 'callout',
    path: 'M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z'
  });

  var infoIcon = new SVGIcon({
    name: 'info',
    path: 'M12 8.4A1.2 1.2 0 1012 6a1.2 1.2 0 000 2.4zM12 0c6.624 0 12 5.376 12 12s-5.376 12-12 12S0 18.624 0 12 5.376 0 12 0zm0 18c.66 0 1.2-.54 1.2-1.2V12c0-.66-.54-1.2-1.2-1.2-.66 0-1.2.54-1.2 1.2v4.8c0 .66.54 1.2 1.2 1.2z'
  });

  var briefcaseIcon = new SVGIcon({
    name: 'briefcase',
    path: 'M20 7h-4V5c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 20c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V9c0-1.11-.89-2-2-2zm-6 0h-4V5h4v2z'
  });

  var kabobIcon = new SVGIcon({
    name: 'kabob',
    viewBox: '0 0 3 11',
    complexContents: "<circle cx=\"1.5\" cy=\"1.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"5.5\" r=\"1.5\"/><circle cx=\"1.5\" cy=\"9.5\" r=\"1.5\"/>"
  });

  var personIcon = new SVGIcon({
    name: 'person',
    viewBox: '0 0 18 18',
    path: 'M9 9c2.486 0 4.5-2.014 4.5-4.5S11.486 0 9 0a4.499 4.499 0 00-4.5 4.5C4.5 6.986 6.514 9 9 9zm0 2.25c-3.004 0-9 1.508-9 4.5v1.125C0 17.494.506 18 1.125 18h15.75c.619 0 1.125-.506 1.125-1.125V15.75c0-2.992-5.996-4.5-9-4.5z'
  });

  var magnifyingGlassIcon = new SVGIcon({
    name: 'magnifying_glass',
    path: 'M16.124 13.051a5.154 5.154 0 110-10.308 5.154 5.154 0 010 10.308M16.114 0a7.886 7.886 0 00-6.46 12.407L0 22.06 1.94 24l9.653-9.653A7.886 7.886 0 1016.113 0'
  });

  var officeIcon = new SVGIcon({
    name: 'office',
    path: 'M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z'
  });

  var linkIcon = new SVGIcon({
    name: 'link',
    path: 'M2.28 12A3.723 3.723 0 016 8.28h4.8V6H6c-3.312 0-6 2.688-6 6s2.688 6 6 6h4.8v-2.28H6A3.723 3.723 0 012.28 12zm4.92 1.2h9.6v-2.4H7.2v2.4zM18 6h-4.8v2.28H18A3.723 3.723 0 0121.72 12 3.723 3.723 0 0118 15.72h-4.8V18H18c3.312 0 6-2.688 6-6s-2.688-6-6-6z'
  });

  var windowIcon = new SVGIcon({
    name: 'window',
    path: 'M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z'
  });

  var phoneIcon = new SVGIcon({
    name: 'phone',
    path: 'M4.827 10.387a20.198 20.198 0 008.786 8.786l2.934-2.933c.36-.36.893-.48 1.36-.32a15.21 15.21 0 004.76.76c.733 0 1.333.6 1.333 1.333v4.654C24 23.4 23.4 24 22.667 24 10.147 24 0 13.853 0 1.333 0 .6.6 0 1.333 0H6c.733 0 1.333.6 1.333 1.333 0 1.667.267 3.267.76 4.76.147.467.04.987-.333 1.36l-2.933 2.934z'
  });

  var tagIcon = new SVGIcon({
    name: 'tag',
    viewBox: '0 0 18 18',
    path: 'M17.469 8.622l-8.1-8.1A1.789 1.789 0 008.1 0H1.8C.81 0 0 .81 0 1.8v6.3c0 .495.198.945.531 1.278l8.1 8.1c.324.324.774.522 1.269.522a1.76 1.76 0 001.269-.531l6.3-6.3A1.76 1.76 0 0018 9.9c0-.495-.207-.954-.531-1.278zM3.15 4.5c-.747 0-1.35-.603-1.35-1.35 0-.747.603-1.35 1.35-1.35.747 0 1.35.603 1.35 1.35 0 .747-.603 1.35-1.35 1.35z'
  });

  var documentIcon = new SVGIcon({
    name: 'document',
    path: 'M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z'
  });

  var chevronIcon = new SVGIcon({
    name: 'chevron',
    viewBox: '0 0 7 9',
    complexContents: "<g fill-rule=\"evenodd\" transform=\"translate(-1 -8)\"><path d=\"m2.6417004 8-1.1417004 1.0575 3.70850202 3.4425-3.70850202 3.4425 1.1417004 1.0575 4.8582996-4.5z\"/></g>"
  });

  var supportIcon = new SVGIcon({
    name: 'support',
    path: 'M12,0 C5.376,0 0,5.376 0,12 C0,18.624 5.376,24 12,24 C18.624,24 24,18.624 24,12 C24,5.376 18.624,0 12,0 Z M13,19 L11,19 L11,17 L13,17 L13,19 Z M15.07,11.25 L14.17,12.17 C13.45,12.9 13,13.5 13,15 L11,15 L11,14.5 C11,13.4 11.45,12.4 12.17,11.67 L13.41,10.41 C13.78,10.05 14,9.55 14,9 C14,7.9 13.1,7 12,7 C10.9,7 10,7.9 10,9 L8,9 C8,6.79 9.79,5 12,5 C14.21,5 16,6.79 16,9 C16,9.88 15.64,10.68 15.07,11.25 Z'
  });

  var yextIcon = new SVGIcon({
    name: 'yext',
    viewBox: '0 0 30 30',
    path: 'M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z'
  });

  var pinIcon = new SVGIcon({
    name: 'pin',
    viewBox: '0 0 13 18',
    path: 'm9.375 0c-3.52446429 0-6.375 2.817-6.375 6.3 0 4.725 6.375 11.7 6.375 11.7s6.375-6.975 6.375-11.7c0-3.483-2.8505357-6.3-6.375-6.3zm.00000018 8.55000007c-1.25678576 0-2.27678579-1.008-2.27678579-2.25s1.02000003-2.25 2.27678579-2.25c1.25678572 0 2.27678582 1.008 2.27678582 2.25s-1.0200001 2.25-2.27678582 2.25z'
  });

  var gearIcon = new SVGIcon({
    name: 'gear',
    path: 'M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42a.353.353 0 01.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16a.353.353 0 01-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z'
  });

  var lightBulbIcon = new SVGIcon({
    name: 'light_bulb',
    viewBox: '0 0 32 35',
    path: 'M11.585 31.056l8.38-.493v-.986l-8.38.493zM11.585 33.028L15.775 35l4.19-1.972V31.55l-8.38.493v.986zm6.926-.407l-2.736 1.29-2.13-1.004 4.866-.286zM15.775 7.394c-4.63 0-8.38 3.205-8.38 8.38 0 5.177 4.19 6.902 4.19 12.818v.493l8.38-.493c0-5.916 4.19-8.188 4.19-12.817a8.38 8.38 0 00-8.38-8.38zm5.617 13.48c-1.025 1.837-2.174 3.892-2.381 6.786l-6.44.38c-.129-3.01-1.29-5.021-2.32-6.808-.493-.8-.928-1.636-1.299-2.5h13.556c-.325.708-.704 1.403-1.116 2.142zm1.479-3.128H8.627a7.793 7.793 0 01-.247-1.971c0-4.353 3.042-7.395 7.395-7.395a7.394 7.394 0 017.394 7.395 6.739 6.739 0 01-.3 1.971h.002zM26.62 15.282h4.93v1h-4.93zM23.094 7.756l2.091-2.091.698.697-2.092 2.092zM15.282 0h1v4.93h-1zM5.666 6.362l.697-.697 2.091 2.091-.697.697zM0 15.282h4.93v1H0z'
  });

  var starIcon = new SVGIcon({
    name: 'receipt',
    viewBox: '0 0 18 18',
    path: 'M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z'
  });

  var close = new SVGIcon({
    name: 'close',
    complexContents: "\n    <path d=\"M7 8l9.716 9.716m0-9.716L7 17.716\" \n          stroke=\"currentColor\" \n          stroke-width=\"2\"/>\n  "
  });

  var elements = new SVGIcon({
    name: 'elements',
    path: 'M13,15 L13,17 L21,17 L21,19 L13,19 L13,21 L11,21 L11,15 L13,15 Z M9,17 L9,19 L3,19 L3,17 L9,17 Z M9,15 L7,15 L7,13 L3,13 L3,11 L7,11 L7,9 L9,9 L9,15 Z M21,11 L21,13 L11,13 L11,11 L21,11 Z M17,3 L17,5 L21,5 L21,7 L17,7 L17,9 L15,9 L15,3 L17,3 Z M13,5 L13,7 L3,7 L3,5 L13,5 Z'
  });

  var iconsArray = [thumbIcon, receiptIcon, pantheonIcon, micIcon, directionsIcon, calendarIcon, calloutIcon, infoIcon, briefcaseIcon, kabobIcon, personIcon, magnifyingGlassIcon, officeIcon, linkIcon, windowIcon, phoneIcon, tagIcon, documentIcon, chevronIcon, supportIcon, yextIcon, pinIcon, gearIcon, lightBulbIcon, elements, close];
  var Icons = {};
  iconsArray.forEach(function (icon) {
    Icons[icon.name] = icon.markup();
  });
  Icons["default"] = starIcon.markup();

  var IconComponent =
  /*#__PURE__*/
  function (_Component) {
    _inherits(IconComponent, _Component);

    /**
     * IconComponent
     * @param opts
     * @param opts.iconName {string}
     * @param opts.customIcon {string}
     * @param opts.iconUrl {string}
     */
    function IconComponent() {
      var _this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var systemOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, IconComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(IconComponent).call(this, opts, systemOpts));
      /**
       * name of an icon from the default icon set
       * @type {string}
       */

      _this.iconName = opts.iconName || 'default';
      /**
       * the markup for a fully custom icon
       * @type {*|null}
       */

      _this.customIcon = opts.customIcon || null;
      /**
       * the url to a custom image icon
       * @type {null}
       */

      _this.iconUrl = opts.iconUrl || null;
      return _this;
    }
    /**
     * getter for the image pasted to handlebars
     * @returns {string}
     */


    _createClass(IconComponent, [{
      key: "setState",

      /**
       * overrides default functionality to provide name and markup
       * @param data
       * @returns {IconComponent}
       */
      value: function setState(data) {
        return _get(_getPrototypeOf(IconComponent.prototype), "setState", this).call(this, Object.assign(data, {
          image: this.image,
          name: this.iconName ? this.iconName : 'custom'
        }));
      }
    }, {
      key: "image",
      get: function get() {
        if (this.customIcon) {
          return this.customIcon;
        }

        if (this.iconUrl) {
          return "<img src=\"".concat(this.iconUrl, "\" alt=\"\" class=\"Icon-image\">");
        }

        if (Icons[this.iconName]) {
          return Icons[this.iconName];
        }

        return Icons["default"];
      }
    }], [{
      key: "defaultTemplateName",

      /**
       * The template to render
       * @returns {string}
       * @override
       */
      value: function defaultTemplateName(config) {
        return 'icons/icon';
      }
      /**
       * allowing duplicates
       * @returns {boolean}
       * @override
       */

    }, {
      key: "areDuplicateNamesAllowed",
      value: function areDuplicateNamesAllowed() {
        return true;
      }
    }, {
      key: "type",
      get: function get() {
        return 'IconComponent';
      }
    }]);

    return IconComponent;
  }(Component);

  /** @module */
  var COMPONENT_CLASS_LIST = [// Core Component
  Component, // Navigation Components
  NavigationComponent, // Search Components
  SearchComponent, FilterSearchComponent, AutoCompleteComponent, SpellCheckComponent, LocationBiasComponent, // Filter Components
  FilterBoxComponent, FilterOptionsComponent, RangeFilterComponent, DateRangeFilterComponent, FacetsComponent, GeoLocationComponent, // Results Components
  DirectAnswerComponent, UniversalResultsComponent, ResultsComponent, PaginationComponent, ResultsItemComponent, AccordionResultsComponent, LocationResultsItemComponent, EventResultsItemComponent, PeopleResultsItemComponent, MapComponent, // Questions Components
  QuestionSubmissionComponent, // Helper Components
  IconComponent];
  /**
   * The component registry is a map that contains
   * all available component classes used for creation or extension.
   * Each component class has a unique type, which is used as the key for the registry
   * @type {Object.<string, Component>}
   */

  var COMPONENT_REGISTRY = COMPONENT_CLASS_LIST.reduce(function (registry, clazz) {
    registry[clazz.type] = clazz;
    return registry;
  }, {});

  /**
   * ComponentManager is a Singletone that contains both an internal registry of
   * eligible components to be created, as well as keeps track of the current
   * instantiated and active components.
   *
   * ALL components should be constructed using the {ComponentManager} via its `create` method.
   */

  var ComponentManager =
  /*#__PURE__*/
  function () {
    function ComponentManager() {
      _classCallCheck(this, ComponentManager);

      /**
       * The active components is an internal container to keep track
       * of all of the components that have been constructed
       */
      this._activeComponents = [];
      /**
       * A local reference to the core library dependency
       *
       * The Core contains both the storage AND services that are needed for performing operations
       * like search and auto complete.
       *
       * The storage is the source of truth for the state of ALL components.
       * Whenever the storage is updated, the state gets pushed down to the necessary components.
       * @type {Core}
       */

      this._core = null;
      /**
       * The primary renderer to use for all components
       * @type {HandlebarsRenderer}
       */

      this._renderer = null;
      /**
       * A local reference to the analytics reporter dependency
       */

      this._analyticsReporter = null;
    }

    _createClass(ComponentManager, [{
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this._renderer = renderer;
        return this;
      }
    }, {
      key: "setCore",
      value: function setCore(core) {
        this._core = core;
        return this;
      }
    }, {
      key: "setAnalyticsReporter",
      value: function setAnalyticsReporter(reporter) {
        this._analyticsReporter = reporter;
        return this;
      }
      /**
       * registers a component to be eligible for creation and override.
       * @param {Component} The Component Class to register
       */

    }, {
      key: "register",
      value: function register(componentClazz) {
        COMPONENT_REGISTRY[componentClazz.type] = componentClazz;
        return this;
      }
      /**
       * create is the entry point for constructing any and all components.
       * It will instantiate a new instance of the component, and both apply
       * initial state from the storage and bind it to the storage for updates.
       * @param {string} componentType The component type to create
       * @param {Object} opts The options to pipe to the construction of the component
       */

    }, {
      key: "create",
      value: function create(componentType, opts) {
        // Every component needs local access to the component manager
        // because sometimes components have subcomponents that need to be
        // constructed during creation
        var systemOpts = {
          core: this._core,
          renderer: this._renderer,
          analyticsReporter: this._analyticsReporter,
          componentManager: this
        };
        var componentClass = COMPONENT_REGISTRY[componentType];

        if (!componentClass.areDuplicateNamesAllowed() && this._activeComponents.some(function (c) {
          return c.name === opts.name;
        })) {
          throw new AnswersComponentError("Another component with name ".concat(opts.name, " already exists"), componentType);
        }

        var config = _objectSpread({
          isTwin: this._activeComponents.some(function (component) {
            return component.constructor.type === componentType;
          })
        }, opts); // Instantiate our new component and keep track of it


        var component = new COMPONENT_REGISTRY[componentType](config, systemOpts).init(config);

        this._activeComponents.push(component); // If there is a global storage to power state, apply the state
        // from the storage to the component, and then bind the component
        // state to the storage via its updates


        if (this._core && this._core.globalStorage !== null) {
          if (component.moduleId === undefined || component.moduleId === null) {
            return component;
          }

          this._core.globalStorage.on('update', component.moduleId, function (data) {
            component.setState(data);
          });
        }

        return component;
      }
      /**
       * Remove the provided component from the list of active components and remove
       * the associated storage event listener
       * @param {Component} component The component to remove
       */

    }, {
      key: "remove",
      value: function remove(component) {
        this._core.globalStorage.off('update', component.moduleId);

        var index = this._activeComponents.findIndex(function (c) {
          return c.name === component.name;
        });

        this._activeComponents.splice(index, 1);
      }
      /**
       * Remove the component with the given name
       * @param {string} name The name of the compnent to remove
       */

    }, {
      key: "removeByName",
      value: function removeByName(name) {
        var component = this._activeComponents.find(function (c) {
          return c.name === name;
        });

        component.remove();
        DOM.empty(component._container);
      }
    }, {
      key: "getActiveComponent",
      value: function getActiveComponent(type) {
        return this._activeComponents.find(function (c) {
          return c.constructor.type === type;
        });
      }
    }], [{
      key: "getInstance",
      value: function getInstance() {
        if (!this.instance) {
          this.instance = new ComponentManager();
        }

        return this.instance;
      }
    }]);

    return ComponentManager;
  }();

  /** @module NavigationConfig */
  var TabConfig =
  /*#__PURE__*/
  function () {
    function TabConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, TabConfig);

      /**
       * The name of the tab that is exposed for the link
       * @type {string}
       */
      this.label = config.label || null;
      /**
       * The complete URL, including the params
       * @type {string}
       */

      this.url = config.url || null;
      /**
       * The serverside vertical config id that this is referenced to.
       * By providing this, enables dynamic sorting based on results.
       * @type {string}
       */

      this.configId = config.configId || null;
      /**
       * Determines whether to show this tab first in the order
       * @type {boolean}
       */

      this.isFirst = config.isFirst || false;
      /**
       * Determines whether or not to apply a special class to the
       * markup to determine if it's an active tab
       * @type {boolean}
       */

      this.isActive = config.isActive || false;
    }

    _createClass(TabConfig, [{
      key: "validate",
      value: function validate() {}
    }], [{
      key: "from",
      value: function from(tabs) {
        var tabConfigs = [];

        if (tabs === undefined) {
          return tabConfigs;
        }

        for (var i = 0; i < tabs.length; i++) {
          var tab = tabs[i];
          tabConfigs.push(new TabConfig(tab));
        }

        return tabConfigs;
      }
    }]);

    return TabConfig;
  }();

  var NavigationConfig = function NavigationConfig() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NavigationConfig);

    this.tabsConfig = TabConfig.from(config.tabs);
  };

  /** @typedef {import('./core/services/searchservice').default} SearchService */

  /** @typedef {import('./core/services/autocompleteservice').default} AutoCompleteService */

  /** @typedef {import('./core/services/questionanswerservice').default} QuestionAnswerService */

  /** @typedef {import('./core/services/errorreporterservice').default} ErrorReporterService */

  /** @typedef {import('./core/services/analyticsreporterservice').default} AnalyticsReporterService */

  /**
   * @typedef Services
   * @property {SearchService} searchService
   * @property {AutoCompleteService} autoCompleteService
   * @property {QuestionAnswerService} questionAnswerService
   * @property {ErrorReporterService} errorReporterService
   */

  var DEFAULTS = {
    locale: 'en'
  };
  /**
   * The main Answers interface
   */

  var Answers =
  /*#__PURE__*/
  function () {
    function Answers() {
      _classCallCheck(this, Answers);

      if (!Answers.setInstance(this)) {
        return Answers.getInstance();
      }
      /**
       * A reference to the Component base class for custom
       * components to extend
       */


      this.Component = Component;
      /**
       * A reference to the AnalyticsEvent base class for reporting
       * custom analytics
       */

      this.AnalyticsEvent = AnalyticsEvent;
      /**
       * A reference of the renderer to use for the components
       * This is provided during initialization.
       * @type {Renderer}
       */

      this.renderer = new Renderers.Handlebars();
      /**
       * A local reference to the component manager
       * @type {ComponentManager}
       */

      this.components = ComponentManager.getInstance();
      /**
       * A local reference to the core api
       * @type {Core}
       */

      this.core = null;
      /**
       * A callback function to invoke once the library is ready.
       * Typically fired after templates are fetched from server for rendering.
       */

      this._onReady = function () {};
      /**
       * @type {boolean}
       * @private
       */


      this._eligibleForAnalytics = false;
      /**
       * @type {Services}
       * @private
       */

      this._services = null;
      /**
       * @type {AnalyticsReporterService}
       * @private
       */

      this._analyticsReporterService = null;
    }

    _createClass(Answers, [{
      key: "init",
      value: function init(config) {
        var _this = this;

        config = Object.assign({}, DEFAULTS, config);

        if (typeof config.apiKey !== 'string') {
          throw new Error('Missing required `apiKey`. Type must be {string}');
        }

        if (typeof config.experienceKey !== 'string') {
          throw new Error('Missing required `experienceKey`. Type must be {string}');
        }

        config.search = new SearchConfig(config.search);
        config.navigation = new NavigationConfig(config.navigation);
        var globalStorage = new GlobalStorage();
        var persistentStorage = new PersistentStorage({
          updateListener: config.onStateChange,
          resetListener: function resetListener(data) {
            return globalStorage.setAll(data);
          }
        });
        globalStorage.setAll(persistentStorage.getAll());
        globalStorage.set(StorageKeys.SEARCH_CONFIG, config.search);
        globalStorage.set(StorageKeys.NAVIGATION_CONFIG, config.navigation);
        globalStorage.set(StorageKeys.LOCALE, config.locale);
        var sessionTrackingEnabled = true;

        if (typeof config.sessionTrackingEnabled === 'boolean') {
          sessionTrackingEnabled = config.sessionTrackingEnabled;
        }

        globalStorage.set(StorageKeys.SESSIONS_OPT_IN, sessionTrackingEnabled);
        this._services = config.mock ? getMockServices() : getServices(config);
        this.core = new Core({
          apiKey: config.apiKey,
          globalStorage: globalStorage,
          persistentStorage: persistentStorage,
          experienceKey: config.experienceKey,
          fieldFormatters: config.fieldFormatters,
          experienceVersion: config.experienceVersion,
          locale: config.locale,
          searchService: this._services.searchService,
          autoCompleteService: this._services.autoCompleteService,
          questionAnswerService: this._services.questionAnswerService
        });

        if (config.onStateChange && typeof config.onStateChange === 'function') {
          config.onStateChange(persistentStorage.getAll(), window.location.search.substr(1));
        }

        this.components.setCore(this.core).setRenderer(this.renderer);
        this._eligibleForAnalytics = config.businessId != null;

        if (this._eligibleForAnalytics) {
          // TODO(amullings): Initialize with other services
          var reporter = config.mock ? new NoopAnalyticsReporter() : new AnalyticsReporter(this.core, config.experienceKey, config.experienceVersion, config.businessId, config.analyticsOptions);
          this._analyticsReporterService = reporter;
          this.components.setAnalyticsReporter(reporter);
          initScrollListener(reporter);
        }

        this._setDefaultInitialSearch(config.search);

        this._onReady = config.onReady || function () {};

        if (config.useTemplates === false || config.templateBundle) {
          if (config.templateBundle) {
            this.renderer.init(config.templateBundle);
          }

          this._onReady();

          return this;
        } // Templates are currently downloaded separately from the CORE and UI bundle.
        // Future enhancement is to ship the components with templates in a separate bundle.


        this.templates = new TemplateLoader({
          templateUrl: config.templateUrl
        }).onLoaded(function (templates) {
          _this.renderer.init(templates);

          _this._onReady();
        });
        return this;
      }
    }, {
      key: "domReady",
      value: function domReady(cb) {
        DOM.onReady(cb);
      }
    }, {
      key: "onReady",
      value: function onReady(cb) {
        this._onReady = cb;
        return this;
      }
      /**
       * Register a custom component type so it can be created via
       * addComponent and used as a child component
       * @param {Component} componentClass
       */

    }, {
      key: "registerComponentType",
      value: function registerComponentType(componentClass) {
        this.components.register(componentClass);
      }
    }, {
      key: "addComponent",
      value: function addComponent(type, opts) {
        if (typeof opts === 'string') {
          opts = {
            container: opts
          };
        }

        try {
          this.components.create(type, opts).mount();
        } catch (e) {
          throw new AnswersComponentError('Failed to add component', type, e);
        }

        return this;
      }
      /**
       * Remove the component - and all of its children - with the given name
       * @param {string} name The name of the component to remove
       */

    }, {
      key: "removeComponent",
      value: function removeComponent(name) {
        this.components.removeByName(name);
      }
    }, {
      key: "createComponent",
      value: function createComponent(opts) {
        return this.components.create('Component', opts).mount();
      }
    }, {
      key: "registerHelper",
      value: function registerHelper(name, cb) {
        this.renderer.registerHelper(name, cb);
        return this;
      }
      /**
       * Opt in or out of convertion tracking analytics
       * @param {boolean} optIn
       */

    }, {
      key: "setConversionsOptIn",
      value: function setConversionsOptIn(optIn) {
        if (this._eligibleForAnalytics) {
          this._analyticsReporterService.setConversionTrackingEnabled(optIn);
        }
      }
      /**
       * Opt in or out of session cookies
       * @param {boolean} optIn
       */

    }, {
      key: "setSessionsOptIn",
      value: function setSessionsOptIn(optIn) {
        this.core.globalStorage.set(StorageKeys.SESSIONS_OPT_IN, optIn);
      }
      /**
       * Sets a search query on initialization for vertical searchers that have a
       * defaultInitialSearch provided, if the user hasn't already provided their
       * own via URL param.
       * @param {SearchConfig} searchConfig
       * @private
       */

    }, {
      key: "_setDefaultInitialSearch",
      value: function _setDefaultInitialSearch(searchConfig) {
        if (searchConfig.defaultInitialSearch == null || !searchConfig.verticalKey) {
          return;
        }

        var prepopulatedQuery = this.core.globalStorage.getState(StorageKeys.QUERY);

        if (prepopulatedQuery != null) {
          return;
        }

        this.core.globalStorage.set('queryTrigger', 'initialize');
        this.core.setQuery(searchConfig.defaultInitialSearch);
      }
    }], [{
      key: "setInstance",
      value: function setInstance(instance) {
        if (!this.instance) {
          this.instance = instance;
          return true;
        }

        return false;
      }
    }, {
      key: "getInstance",
      value: function getInstance() {
        return this.instance;
      }
    }]);

    return Answers;
  }();
  /**
   * @param {Object} config
   * @returns {Services}
   */


  function getServices(config) {
    return {
      searchService: new SearchApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale
      }),
      autoCompleteService: new AutoCompleteApi({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        locale: config.locale
      }),
      questionAnswerService: new QuestionAnswerApi({
        apiKey: config.apiKey
      }),
      errorReporterService: new ErrorReporter({
        apiKey: config.apiKey,
        experienceKey: config.experienceKey,
        experienceVersion: config.experienceVersion,
        printVerbose: config.debug,
        sendToServer: !config.suppressErrorReports
      })
    };
  }
  /**
   * @returns {Services}
   */


  function getMockServices() {
    return {
      searchService: new MockSearchService(),
      autoCompleteService: new MockAutoCompleteService(),
      questionAnswerService: new MockQuestionAnswerService(),
      errorReporterService: new ConsoleErrorReporter()
    };
  }
  /**
   * Initialize the scroll event listener to send analytics events
   * when the user scrolls to the bottom. Debounces scroll events so
   * they are processed after the user stops scrolling
   */


  function initScrollListener(reporter) {
    var DEBOUNCE_TIME = 100;
    var timeout = null;

    var sendEvent = function sendEvent() {
      if (window.innerHeight + window.pageYOffset >= document.body.scrollHeight) {
        var event = new AnalyticsEvent('SCROLL_TO_BOTTOM_OF_PAGE');
        reporter.report(event);
      }
    };

    document.addEventListener('scroll', function () {
      clearTimeout(timeout);
      timeout = setTimeout(sendEvent, DEBOUNCE_TIME);
    });
  }

  var ANSWERS = new Answers();

  return ANSWERS;

}));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5zd2Vycy11bWQuanMiLCJzb3VyY2VzIjpbInNyYy9jb3JlL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzLmpzIiwic3JjL2NvcmUvbW9kZWxzL3Jlc3VsdC5qcyIsInNyYy9jb3JlL21vZGVscy9oaWdobGlnaHRlZHZhbHVlLmpzIiwic3JjL2NvcmUvZXJyb3JzL2Vycm9ycy5qcyIsInNyYy9jb3JlL21vZGVscy9yZXN1bHRmYWN0b3J5LmpzIiwic3JjL2NvcmUvbW9kZWxzL3NlY3Rpb24uanMiLCJzcmMvY29yZS9tb2RlbHMvdW5pdmVyc2FscmVzdWx0cy5qcyIsInNyYy9jb3JlL21vZGVscy9kaXJlY3RhbnN3ZXIuanMiLCJzcmMvY29yZS9tb2RlbHMvbmF2aWdhdGlvbi5qcyIsInNyYy9jb3JlL21vZGVscy92ZXJ0aWNhbHJlc3VsdHMuanMiLCJzcmMvY29yZS9tb2RlbHMvc3BlbGxjaGVjay5qcyIsInNyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMuanMiLCJzcmMvY29yZS9tb2RlbHMvZHluYW1pY2ZpbHRlcnMuanMiLCJzcmMvY29yZS9tb2RlbHMvc2VhcmNoaW50ZW50cy5qcyIsInNyYy9jb3JlL21vZGVscy9sb2NhdGlvbmJpYXMuanMiLCJzcmMvY29yZS9zZWFyY2gvc2VhcmNoZGF0YXRyYW5zZm9ybWVyLmpzIiwic3JjL2NvcmUvbW9kZWxzL3F1ZXN0aW9uc3VibWlzc2lvbi5qcyIsInNyYy9jb3JlL21vZGVscy9maWx0ZXIuanMiLCJzcmMvY29yZS9jb3JlLmpzIiwic3JjL3VpL2RvbS9kb20uanMiLCJzcmMvdWkvZG9tL3NlYXJjaHBhcmFtcy5qcyIsInNyYy91aS9yZW5kZXJpbmcvcmVuZGVyZXIuanMiLCJzcmMvdWkvcmVuZGVyaW5nL2hhbmRsZWJhcnNyZW5kZXJlci5qcyIsInNyYy91aS9yZW5kZXJpbmcvY29uc3QuanMiLCJzcmMvY29yZS9jb25zdGFudHMuanMiLCJzcmMvdWkvcmVuZGVyaW5nL3RlbXBsYXRlbG9hZGVyLmpzIiwic3JjL3VpL2luZGV4LmpzIiwic3JjL2NvcmUvZXZlbnRlbWl0dGVyL2V2ZW50ZW1pdHRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL3N0YXRlLmpzIiwic3JjL2NvcmUvaHR0cC9odHRwcmVxdWVzdGVyLmpzIiwic3JjL2NvcmUvaHR0cC9hcGlyZXF1ZXN0LmpzIiwic3JjL2NvcmUvc2VhcmNoL3NlYXJjaGFwaS5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudC5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NyZXBvcnRlci5qcyIsInNyYy9jb3JlL2FuYWx5dGljcy9ub29wYW5hbHl0aWNzcmVwb3J0ZXIuanMiLCJzcmMvY29yZS9zdG9yYWdlL21vZHVsZWRhdGEuanMiLCJzcmMvY29yZS9zdG9yYWdlL2dsb2JhbHN0b3JhZ2UuanMiLCJzcmMvY29yZS9pbmRleC5qcyIsInNyYy91aS9jb21wb25lbnRzL2NvbXBvbmVudC5qcyIsInNyYy9jb3JlL2Vycm9ycy9lcnJvcnJlcG9ydGVyLmpzIiwic3JjL2NvcmUvZXJyb3JzL2NvbnNvbGVlcnJvcnJlcG9ydGVyLmpzIiwic3JjL3VpL3N0b3JhZ2UvcGVyc2lzdGVudHN0b3JhZ2UuanMiLCJzcmMvY29yZS9tb2RlbHMvc2VhcmNoY29uZmlnLmpzIiwic3JjL2NvcmUvbW9kZWxzL2F1dG9jb21wbGV0ZWRhdGEuanMiLCJzcmMvY29yZS9zZWFyY2gvYXV0b2NvbXBsZXRlZGF0YXRyYW5zZm9ybWVyLmpzIiwic3JjL2NvcmUvc2VhcmNoL2F1dG9jb21wbGV0ZWFwaS5qcyIsInNyYy9jb3JlL3NlYXJjaC9tb2NrYXV0b2NvbXBsZXRlc2VydmljZS5qcyIsInNyYy9jb3JlL3NlYXJjaC9xdWVzdGlvbmFuc3dlcmFwaS5qcyIsInNyYy9jb3JlL3NlYXJjaC9tb2NrcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlLmpzIiwic3JjL2NvcmUvc2VhcmNoL21vY2tzZWFyY2hzZXJ2aWNlLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL3NlYXJjaGNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3NlYXJjaC9maWx0ZXJzZWFyY2hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvYXV0b2NvbXBsZXRlY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvc2VhcmNoL3NwZWxsY2hlY2tjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9zZWFyY2gvbG9jYXRpb25iaWFzY29tcG9uZW50LmpzIiwic3JjL2NvcmUvbW9kZWxzL2ZhY2V0LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXJib3hjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlcm9wdGlvbnNjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL3JhbmdlZmlsdGVyY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvZmlsdGVycy9kYXRlcmFuZ2VmaWx0ZXJjb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9maWx0ZXJzL2ZhY2V0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL2ZpbHRlcnMvZ2VvbG9jYXRpb25jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL2RpcmVjdGFuc3dlcmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvcmVzdWx0c2l0ZW1jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL2xvY2F0aW9ucmVzdWx0c2l0ZW1jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL2V2ZW50cmVzdWx0c2l0ZW1jb21wb25lbnQuanMiLCJzcmMvdWkvY29tcG9uZW50cy9yZXN1bHRzL3Blb3BsZXJlc3VsdHNpdGVtY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbWFwL3Byb3ZpZGVycy9tYXBwcm92aWRlci5qcyIsInNyYy91aS9jb21wb25lbnRzL21hcC9wcm92aWRlcnMvZ29vZ2xlbWFwcHJvdmlkZXIuanMiLCJzcmMvdWkvY29tcG9uZW50cy9tYXAvcHJvdmlkZXJzL21hcGJveG1hcHByb3ZpZGVyLmpzIiwic3JjL3VpL2NvbXBvbmVudHMvbWFwL21hcGNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvcmVzdWx0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvYWNjb3JkaW9ucmVzdWx0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvdW5pdmVyc2FscmVzdWx0c2NvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3Jlc3VsdHMvcGFnaW5hdGlvbmNvbXBvbmVudC5qcyIsInNyYy91aS9jb21wb25lbnRzL3F1ZXN0aW9ucy9xdWVzdGlvbnN1Ym1pc3Npb25jb21wb25lbnQuanMiLCJzcmMvdWkvaWNvbnMvaWNvbi5qcyIsInNyYy91aS9pY29ucy90aHVtYi5qcyIsInNyYy91aS9pY29ucy9yZWNlaXB0LmpzIiwic3JjL3VpL2ljb25zL3BhbnRoZW9uLmpzIiwic3JjL3VpL2ljb25zL21pYy5qcyIsInNyYy91aS9pY29ucy9kaXJlY3Rpb25zLmpzIiwic3JjL3VpL2ljb25zL2NhbGVuZGFyLmpzIiwic3JjL3VpL2ljb25zL2NhbGxvdXQuanMiLCJzcmMvdWkvaWNvbnMvaW5mby5qcyIsInNyYy91aS9pY29ucy9icmllZmNhc2UuanMiLCJzcmMvdWkvaWNvbnMva2Fib2IuanMiLCJzcmMvdWkvaWNvbnMvcGVyc29uLmpzIiwic3JjL3VpL2ljb25zL21hZ25pZnlpbmdfZ2xhc3MuanMiLCJzcmMvdWkvaWNvbnMvb2ZmaWNlLmpzIiwic3JjL3VpL2ljb25zL2xpbmsuanMiLCJzcmMvdWkvaWNvbnMvd2luZG93LmpzIiwic3JjL3VpL2ljb25zL3Bob25lLmpzIiwic3JjL3VpL2ljb25zL3RhZy5qcyIsInNyYy91aS9pY29ucy9kb2N1bWVudC5qcyIsInNyYy91aS9pY29ucy9jaGV2cm9uLmpzIiwic3JjL3VpL2ljb25zL3N1cHBvcnQuanMiLCJzcmMvdWkvaWNvbnMveWV4dC5qcyIsInNyYy91aS9pY29ucy9waW4uanMiLCJzcmMvdWkvaWNvbnMvZ2Vhci5qcyIsInNyYy91aS9pY29ucy9saWdodF9idWxiLmpzIiwic3JjL3VpL2ljb25zL3N0YXIuanMiLCJzcmMvdWkvaWNvbnMvY2xvc2UuanMiLCJzcmMvdWkvaWNvbnMvZWxlbWVudHMuanMiLCJzcmMvdWkvaWNvbnMvaW5kZXguanMiLCJzcmMvdWkvY29tcG9uZW50cy9pY29ucy9pY29uY29tcG9uZW50LmpzIiwic3JjL3VpL2NvbXBvbmVudHMvcmVnaXN0cnkuanMiLCJzcmMvdWkvY29tcG9uZW50cy9jb21wb25lbnRtYW5hZ2VyLmpzIiwic3JjL2NvcmUvbW9kZWxzL25hdmlnYXRpb25jb25maWcuanMiLCJzcmMvYW5zd2Vycy11bWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgU2VhcmNoU3RhdGVzICovXG5cbi8qKlxuICogU2VhcmNoU3RhdGVzIGlzIGFuIEVOVU0gZm9yIHRoZSB2YXJpb3VzIHN0YWdlcyBvZiBzZWFyY2hpbmcsXG4gKiB1c2VkIHRvIHNob3cgZGlmZmVyZW50IHRlbXBsYXRlc1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQUkVfU0VBUkNIOiAncHJlLXNlYXJjaCcsXG4gIFNFQVJDSF9MT0FESU5HOiAnc2VhcmNoLWxvYWRpbmcnLFxuICBTRUFSQ0hfQ09NUExFVEU6ICdzZWFyY2gtY29tcGxldGUnXG59O1xuIiwiLyoqIEBtb2R1bGUgUmVzdWx0ICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdCB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHByb2ZpbGUgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yYXcgPSBkYXRhLnJhdyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBwcm9maWxlIGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZm9ybWF0dGVkID0gZGF0YS5mb3JtYXR0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGlnaGxpZ2h0ZWQgcHJvZmlsZSBkYXRhIHdpdGggaGlnaGxpZ2h0cyBhcHBsaWVkIHRvIGFwcGxpY2FibGUgZmllbGRzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hpZ2hsaWdodGVkID0gZGF0YS5oaWdobGlnaHRlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBudW1iZXIgb2YgdGhlIHJlc3VsdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmRpbmFsID0gZGF0YS5vcmRpbmFsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBvZiB0aGUgZGV0YWlscyBzZWN0aW9uIG9mIHRoZSByZXN1bHQgY2FyZCwgY2FuIGNvbnRhaW4gSFRNTFxuICAgICAqIEB0eXBlIHtzdHJpbmd8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzdGluYXRpb24gbGluayBmb3IgdGhlIHRpdGxlIG9mIHRoZSByZXN1bHQgY2FyZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmsgPSBkYXRhLmxpbmsgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBFbnRpdHkgSUQsIG9yIG90aGVyIHVuaXF1ZSBpZGVudGlmaWVyLCB1c2VkIGZvciB0byBwb3dlciBpbnRlcmFjdGl2aXR5XG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VidGl0bGUgb24gdGhlIHJlc3VsdCBjYXJkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3VidGl0bGUgPSBkYXRhLnN1YnRpdGxlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgbW9kaWZpZXIsIHVzdWFsbHkgZGVyaXZlZCBmcm9tIHRoZSB2ZXJ0aWNhbCBjb25maWd1cmF0aW9uIElEXG4gICAgICogVXNlZCB0byBhcHBseSBkaWZmZXJlbnQgc3R5bGluZyB0byBkaWZmZXJlbnQgcmVzdWx0IGNhcmQgdHlwZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tb2RpZmllciA9IGRhdGEubW9kaWZpZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbGFyZ2UgZGF0ZSwgb2YgdGhlIGZvcm1hdCB7IG1vbnRoOiAnSmFuJywgZGF5OiAnMDEnIH1cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iaWdEYXRlID0gZGF0YS5iaWdEYXRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbWFnZSBwcm9maWxlIG9iamVjdCwgZXhwZWN0ZWQgdG8gaGF2ZSBhIHVybCBwcm9wZXJ0eVxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gZGF0YS5pbWFnZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2FsbHMgdG8gYWN0aW9uLCBvZiB0aGUgZm9ybWF0OlxuICAgICAqIHsgaWNvbjogJycsIHVybDogJycsIHRleHQ6ICcnLCBldmVudFR5cGU6ICcnLCBldmVudE9wdGlvbnM6IHt9fVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNhbGxzVG9BY3Rpb24gPSBkYXRhLmNhbGxzVG9BY3Rpb24gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGFjY29yZGlhbiByZXN1bHQgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzZWQgPSBkYXRhLmNvbGxhcHNlZCB8fCB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIaWdobGlnaHRlZFZhbHVlICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgaGlnaGxpZ2h0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpZ2hsaWdodGVkVmFsdWUge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWUgfHwgZGF0YS5zaG9ydFZhbHVlIHx8ICcnO1xuICAgIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MgPSBkYXRhLm1hdGNoZWRTdWJzdHJpbmdzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCAoKSB7XG4gICAgdGhpcy5fc29ydE1hdGNoZWRTdWJzdHJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRIaWdobGlnaHRlZFZhbHVlKHRoaXMudmFsdWUsIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBpbnZlcnRlZCBoaWdobGlnaHRlZCB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldEludmVydGVkICgpIHtcbiAgICB0aGlzLl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MoKTtcbiAgICBjb25zdCBpbnZlcnRlZFN1YnN0cmluZ3MgPSB0aGlzLl9nZXRJbnZlcnRlZFN1YnN0cmluZ3ModGhpcy5tYXRjaGVkU3Vic3RyaW5ncywgdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZSh0aGlzLnZhbHVlLCBpbnZlcnRlZFN1YnN0cmluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIGludHJvZHVjZXMgaGlnaGxpZ2h0aW5nIHRvIGlucHV0IGRhdGEgYWNjb3JkaW5nIHRvIGhpZ2hsaWdodGluZyBzcGVjaWZpZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgaW5wdXQgb2JqZWN0IHRvIGFwcGx5IGhpZ2hsaWdodGluZyB0b1xuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnQVRNJyxcbiAgICogICAgZmVhdHVyZWRNZXNzYWdlOiB7XG4gICAqICAgICAgZGVzY3JpcHRpb246ICdTYXZlIHRpbWUgJiBiYW5rIG9uIHlvdXIgdGVybXMgYXQgb3ZlciAxLDgwMCBBVE1zJ1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZFN1YnN0cmluZ3MgaGlnaGxpZ2h0aW5nIHNwZWNpZmllcnMgdG8gYXBwbHkgdG8gaW5wdXQgb2JqZWN0XG4gICAqXG4gICAqICBleGFtcGxlIG9iamVjdCA6XG4gICAqICB7XG4gICAqICAgIG5hbWU6IHtcbiAgICogICAgICBtYXRjaGVkU3Vic3RyaW5nczogW3tcbiAgICogICAgICAgIGxlbmd0aDogMyxcbiAgICogICAgICAgIG9mZnNldDogMFxuICAgKiAgICAgIH1dLFxuICAgKiAgICAgIHZhbHVlOiAnQVRNJ1xuICAgKiAgICB9LFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjoge1xuICAgKiAgICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAqICAgICAgICAgIGxlbmd0aDogNCxcbiAgICogICAgICAgICAgb2Zmc2V0OiA0NVxuICAgKiAgICAgICAgfV0sXG4gICAqICAgICAgICB2YWx1ZTogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIEFUTXMnXG4gICAqICAgICAgfVxuICAgKiAgICB9XG4gICAqICB9XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvcHkgb2YgaW5wdXQgdmFsdWUgd2l0aCBoaWdobGlnaHRpbmcgYXBwbGllZFxuICAgKlxuICAgKiAgZXhhbXBsZSBvYmplY3QgOlxuICAgKiAge1xuICAgKiAgICBuYW1lOiAnPHN0cm9uZz5BVE08L3N0cm9uZz4nLFxuICAgKiAgICBmZWF0dXJlZE1lc3NhZ2U6IHtcbiAgICogICAgICBkZXNjcmlwdGlvbjogJ1NhdmUgdGltZSAmIGJhbmsgb24geW91ciB0ZXJtcyBhdCBvdmVyIDEsODAwIDxzdHJvbmc+QVRNczwvc3Ryb25nPidcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKi9cbiAgYnVpbGRIaWdobGlnaHRlZFZhbHVlICh2YWwsIGhpZ2hsaWdodGVkU3Vic3RyaW5ncykge1xuICAgIGxldCBoaWdobGlnaHRlZFZhbHVlID0gJyc7XG4gICAgbGV0IG5leHRTdGFydCA9IDA7XG5cbiAgICBpZiAoaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IHN0YXJ0ID0gTnVtYmVyKGhpZ2hsaWdodGVkU3Vic3RyaW5nc1tqXS5vZmZzZXQpO1xuICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzW2pdLmxlbmd0aDtcblxuICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSBbdmFsLnNsaWNlKG5leHRTdGFydCwgc3RhcnQpLCAnPHN0cm9uZz4nLCB2YWwuc2xpY2Uoc3RhcnQsIGVuZCksICc8L3N0cm9uZz4nXS5qb2luKCcnKTtcblxuICAgICAgaWYgKGogPT09IGhpZ2hsaWdodGVkU3Vic3RyaW5ncy5sZW5ndGggLSAxICYmIGVuZCA8IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWRWYWx1ZSArPSB2YWwuc2xpY2UoZW5kKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBoaWdobGlnaHRlZFZhbHVlO1xuICB9XG5cbiAgX3NvcnRNYXRjaGVkU3Vic3RyaW5ncyAoKSB7XG4gICAgdGhpcy5tYXRjaGVkU3Vic3RyaW5ncy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5vZmZzZXQgPCBiLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLm9mZnNldCA+IGIub2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRJbnZlcnRlZFN1YnN0cmluZ3MgKG1hdGNoZWRTdWJzdHJpbmdzLCB2YWx1ZUxlbmd0aCkge1xuICAgIGNvbnN0IGludmVydGVkU3Vic3RyaW5ncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1YnN0cmluZyA9IG1hdGNoZWRTdWJzdHJpbmdzW2ldO1xuICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHN1YnN0cmluZy5vZmZzZXQgKyBzdWJzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGkgPT09IDAgJiYgc3Vic3RyaW5nLm9mZnNldCAhPT0gMCkge1xuICAgICAgICBpbnZlcnRlZFN1YnN0cmluZ3MucHVzaCh7IG9mZnNldDogMCwgbGVuZ3RoOiBzdWJzdHJpbmcub2Zmc2V0IH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVMZW5ndGggPiBuZXh0T2Zmc2V0KSB7XG4gICAgICAgIGludmVydGVkU3Vic3RyaW5ncy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IG5leHRPZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBpIDwgbWF0Y2hlZFN1YnN0cmluZ3MubGVuZ3RoIC0gMVxuICAgICAgICAgICAgPyBtYXRjaGVkU3Vic3RyaW5nc1tpICsgMV0ub2Zmc2V0IC0gbmV4dE9mZnNldFxuICAgICAgICAgICAgOiB2YWx1ZUxlbmd0aCAtIG5leHRPZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFN1YnN0cmluZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEVycm9ycyAqL1xuXG4vKipcbiAqIEFuc3dlcnNCYXNlRXJyb3IgaXMgYW4gZXh0ZW5zaW9uIG9mIHRoZSBiYXNlIEVycm9yIG9iamVjdC5cbiAqIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gd2hlbiByZXBvcnRpbmcgdG8gdGhlIHNlcnZlci5cbiAqIEBleHRlbmRzIEVycm9yXG4gKlxuICogRXJyb3IgY29kZXMgZmFsbCBpbnRvIG9uZSBvZiBmb3VyIGNhdGVnb3JpZXM6XG4gKiAxWFggZXJyb3JzOiBCYXNpYyBlcnJvcnNcbiAqIDJYWCBlcnJvcnM6IFVJIGVycm9yc1xuICogM1hYIGVycm9yczogRW5kcG9pbnQgZXJyb3JzXG4gKiA0WFggZXJyb3JzOiBDb3JlIGVycm9yc1xuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0Jhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycm9yQ29kZSwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnJlcG9ydGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2F1c2VkQnkpIHtcbiAgICAgIHRoaXMuY2F1c2VkQnkgPSBjYXVzZWRCeSBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3JcbiAgICAgICAgPyBjYXVzZWRCeVxuICAgICAgICA6IEFuc3dlcnNCYXNlRXJyb3IuZnJvbShjYXVzZWRCeSk7XG4gICAgfVxuICB9XG5cbiAgdG9Kc29uICgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IHN0cmluZyA9IGAke3RoaXMuZXJyb3JNZXNzYWdlfSAoJHt0aGlzLmJvdW5kYXJ5fSlgO1xuICAgIGlmICh0aGlzLmNhdXNlZEJ5KSB7XG4gICAgICBzdHJpbmcgKz0gYFxcbiAgQ2F1c2VkIEJ5OiAke3RoaXMuY2F1c2VkQnkudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb20gKGJ1aWx0aW5FcnJvciwgYm91bmRhcnkpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcihidWlsdGluRXJyb3IubWVzc2FnZSwgYm91bmRhcnkpO1xuICAgIGVycm9yLnN0YWNrID0gYnVpbHRpbkVycm9yLnN0YWNrO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNCYXNpY0Vycm9yIGlzIGEgd3JhcHBlciBhcm91bmQgYWxsIHRoZSBidWlsdC1pbiBlcnJvcnNcbiAqIGUuZy4gdW5kZWZpbmVkIHZhcmlhYmxlcywgaW5jb3JyZWN0IHN5bnRheCwgdHlwZXMsIG1pc3NpbmcgbWV0aG9kcywgZXRjLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0Jhc2ljRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDEwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNVaUVycm9yIHVzZWQgZm9yIHRoaW5ncyBsaWtlIERPTSBlcnJvcnMuXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzQ29uZmlnRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDEwMSwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNVaUVycm9yIHVzZWQgZm9yIHRoaW5ncyBsaWtlIERPTSBlcnJvcnMuXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzVWlFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoMjAwLCBtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc0NvbXBvbmVudEVycm9yIGlzIHVzZWQgZm9yIENvbXBvbmVudCBvcmllbnRlZCBlcnJvcnNcbiAqIGUuZy4gZmFpbHVyZSB0byByZW5kZXIsIG9yIGNhdGNoaW5nIHVua25vd25zLlxuICogQGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQW5zd2Vyc0NvbXBvbmVudEVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb21wb25lbnQsIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoMjAxLCBtZXNzYWdlLCBjb21wb25lbnQsIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNFbmRwb2ludEVycm9yIHJlcHJlc2VudHMgYWxsIG5ldHdvcmsgcmVsYXRlZCBlcnJvcnMuXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzRW5kcG9pbnRFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoMzAwLCBtZXNzYWdlLCBib3VuZGFyeSwgY2F1c2VkQnkpO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc0NvcmVFcnJvciByZXByZXNlbnRzIGVycm9ycyBmb3IgcHJlY29uZGl0aW9uIGZhaWx1cmVzIGluIHRoZSBjb3JlIGxpYnJhcnlcbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNDb3JlRXJyb3IgZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGJvdW5kYXJ5LCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDQwMCwgbWVzc2FnZSwgYm91bmRhcnksIGNhdXNlZEJ5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuc3dlcnNTdG9yYWdlRXJyb3IgcmVwcmVzZW50cyBzdG9yYWdlIHJlbGF0ZWQgZXJyb3JzXG4gKiBAZXh0ZW5kcyBBbnN3ZXJzQmFzZUVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBbnN3ZXJzU3RvcmFnZUVycm9yIGV4dGVuZHMgQW5zd2Vyc0Jhc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzdG9yYWdlS2V5LCBkYXRhLCBjYXVzZWRCeSkge1xuICAgIHN1cGVyKDQwMSwgbWVzc2FnZSwgJ1N0b3JhZ2UnLCBjYXVzZWRCeSk7XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogQW5zd2Vyc0FuYWx5dGljc0Vycm9yIGlzIHVzZWQgZm9yIGVycm9ycyB3aGVuIHJlcG9ydGluZyBhbmFseXRpY3NcbiAqIEBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFuc3dlcnNBbmFseXRpY3NFcnJvciBleHRlbmRzIEFuc3dlcnNCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgZXZlbnQsIGNhdXNlZEJ5KSB7XG4gICAgc3VwZXIoNDAyLCBtZXNzYWdlLCAnQW5hbHl0aWNzJywgY2F1c2VkQnkpO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUmVzdWx0RmFjdG9yeSAqL1xuXG5pbXBvcnQgUmVzdWx0IGZyb20gJy4vcmVzdWx0JztcbmltcG9ydCBIaWdobGlnaHRlZFZhbHVlIGZyb20gJy4vaGlnaGxpZ2h0ZWR2YWx1ZSc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29yZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdEZhY3Rvcnkge1xuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIFJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBJbmNsdWRlcyBkZWZhdWx0IG1hcHBpbmdzIG9mIEdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSByZXN1bHRzIHRvXG4gICAqIHRoZSBmaWVsZHMgZXhwb3NlZCBieSB0aGUgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSByZXN1bHRzRGF0YSAge0FycmF5fSBleHBlY3RlZCBmb3JtYXQ6IHsgZGF0YTogeyAuLi4gfSwgaGlnaGxpZ2h0ZWRGaWVsZHM6IHsgLi4uIH19XG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBUaGUgZm9ybWF0dGVycyB0byBhcHBseSB0byB0aGUgcmVzdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbElkIFRoZSB2ZXJ0aWNhbCBvZiB0aGVzZSByZXN1bHRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgQmFja2VuZCBzb3VyY2Ugb2YgdGhlc2UgcmVzdWx0c1xuICAgKiBAcmV0dXJucyB7UmVzdWx0W119XG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzdWx0c0RhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIHNvdXJjZSkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHNEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gcmVzdWx0c0RhdGFbaV0uZGF0YSB8fCByZXN1bHRzRGF0YVtpXTtcblxuICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgY2FzZSAnR09PR0xFX0NTRSc6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0JJTkdfQ1NFJzpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tQmluZ0N1c3RvbVNlYXJjaEVuZ2luZShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1pFTkRFU0snOlxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21aZW5kZXNrU2VhcmNoRW5naW5lKGRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQUxHT0xJQSc6XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFJlc3VsdEZhY3RvcnkuZnJvbUFsZ29saWFTZWFyY2hFbmdpbmUoZGF0YSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLTk9XTEVER0VfTUFOQUdFUic6XG4gICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRGaWVsZHMgPSByZXN1bHRzRGF0YVtpXS5oaWdobGlnaHRlZEZpZWxkcyB8fCB7fTtcblxuICAgICAgICAgIHJlc3VsdHMucHVzaChSZXN1bHRGYWN0b3J5LmZyb21Lbm93bGVkZ2VNYW5hZ2VyKFxuICAgICAgICAgICAgZGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgaGlnaGxpZ2h0ZWRGaWVsZHMsIGkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXN1bHRzLnB1c2goUmVzdWx0RmFjdG9yeS5mcm9tR2VuZXJpYyhkYXRhLCBpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBmaWVsZCBmb3JtYXR0ZXJzIHRvIEtub3dsZWRnZSBNYW5hZ2VyIEVudGl0eSBQcm9maWxlIERhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVByb2ZpbGVEYXRhIEVudGl0eSBQcm9maWxlIERhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdHRlcnMgRGV2ZWxvcGVyIHNwZWNpZmllZCBGaWVsZCBGb3JtYXR0ZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbElkIElkZW50aWZpZXIgZm9yIFZlcnRpY2FsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhIFN1YnNldCBvZiBFbnRpdHkgUHJvZmlsZSBEYXRhIHdpdGggaGlnaGxpZ2h0aW5nIGFwcGxpZWRcbiAgICogQHJldHVybnMge09iamVjdH0gU3Vic2V0IG9mIEVudGl0eSBQcm9maWxlIERhdGEgRmllbGRzIHdpdGggZmllbGQgZm9ybWF0dGVycyBhcHBsaWVkXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUZvcm1hdHRlZERhdGEgKGVudGl0eVByb2ZpbGVEYXRhLCBmb3JtYXR0ZXJzLCB2ZXJ0aWNhbElkLCBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhKSB7XG4gICAgLy8gaWYgbm8gZmllbGQgZm9ybWF0dGVycyBzcGVjaWZpZWQsIG5vdGhpbmcgdG8gZm9ybWF0XG4gICAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHRlZERhdGEgPSB7fTtcblxuICAgIE9iamVjdC5lbnRyaWVzKGVudGl0eVByb2ZpbGVEYXRhKS5mb3JFYWNoKChbZmllbGROYW1lLCBmaWVsZFZhbF0pID0+IHtcbiAgICAgIC8vIGNoZWNrIGlmIGEgZmllbGQgZm9ybWF0dGVyIGV4aXN0cyBmb3IgdGhlIGN1cnJlbnQgZW50aXR5IHByb2ZpbGUgZmllbGRcbiAgICAgIGlmIChmb3JtYXR0ZXJzW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB2ZXJpZnkgdGhlIGZpZWxkIGZvcm1hdHRlciBwcm92aWRlZCBpcyBhIGZvcm1hdHRlciBmdW5jdGlvbiBhcyBleHBlY3RlZFxuICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXJzW2ZpZWxkTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb3JlRXJyb3IoJ0ZpZWxkIGZvcm1hdHRlciBpcyBub3Qgb2YgZXhwZWN0ZWQgdHlwZSBmdW5jdGlvbicsICdSZXN1bHRGYWN0b3J5Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGhpZ2hsaWdodGVkIHZlcnNpb24gb2YgZmllbGQgdmFsdWUgaXMgYXZhaWxhYmxlLCBtYWtlIGl0IGF2YWlsYWJsZSB0byBmaWVsZCBmb3JtYXR0ZXJcbiAgICAgIGxldCBoaWdobGlnaHRlZEZpZWxkVmFsID0gbnVsbDtcbiAgICAgIGlmIChoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhICYmIGhpZ2hsaWdodGVkRW50aXR5UHJvZmlsZURhdGFbZmllbGROYW1lXSkge1xuICAgICAgICBoaWdobGlnaHRlZEZpZWxkVmFsID0gaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YVtmaWVsZE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIGZvcm1hdHRlciBmdW5jdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGZpZWxkIG5hbWVcbiAgICAgIC8vIHRoZSBpbnB1dCBvYmplY3QgZGVmaW5lcyB0aGUgaW50ZXJmYWNlIHRoYXQgZmllbGQgZm9ybWF0dGVyIGZ1bmN0aW9ucyB3b3JrIHdpdGhcbiAgICAgIGZvcm1hdHRlZERhdGFbZmllbGROYW1lXSA9IGZvcm1hdHRlcnNbZmllbGROYW1lXSh7XG4gICAgICAgIGVudGl0eVByb2ZpbGVEYXRhOiBlbnRpdHlQcm9maWxlRGF0YSxcbiAgICAgICAgZW50aXR5RmllbGRWYWx1ZTogZmllbGRWYWwsXG4gICAgICAgIGhpZ2hsaWdodGVkRW50aXR5RmllbGRWYWx1ZTogaGlnaGxpZ2h0ZWRGaWVsZFZhbCxcbiAgICAgICAgdmVydGljYWxJZDogdmVydGljYWxJZCxcbiAgICAgICAgaXNEaXJlY3RBbnN3ZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmb3JtYXR0ZWREYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIHN1YnN0cmluZ3Mgd2l0aGluIEtub3dsZWRnZSBNYW5hZ2VyIEVudGl0eSBGaWVsZCBWYWx1ZXNcbiAgICogYWNjb3JkaW5nIHRvIGhpZ2hsaWdodGluZyBzcGVjaWZpZXJzIHJldHVybmVkIGZyb20gdGhlIEtub3dsZWRnZSBNYW5hZ2VyIFNlYXJjaCBCYWNrZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlQcm9maWxlRGF0YSBFbnRpdHkgUHJvZmlsZSBEYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoaWdobGlnaHRlZEZpZWxkcyBLTSBzcGVjaWZpZWQgaGlnaGxpZ2h0aW5nIGluc3RydWN0aW9ucyB0byBoaWdobGlnaHQgY2VydGFpbiBGaWVsZHNcbiAgICogQHJldHVybnMge09iamVjdH0gU3Vic2V0IG9mIEVudGl0eSBQcm9maWxlIERhdGEgRmllbGRzIHdpdGggaGlnaGxpZ2h0aW5nIGFwcGxpZWRcbiAgICovXG4gIHN0YXRpYyBjb21wdXRlSGlnaGxpZ2h0ZWREYXRhIChlbnRpdHlQcm9maWxlRGF0YSwgaGlnaGxpZ2h0ZWRGaWVsZHMpIHtcbiAgICAvLyBpZiBubyBoaWdobGlnaHRlZCBmaWVsZHMgc3BlY2lmaWVkLCBub3RoaW5nIHRvIGhpZ2hsaWdodFxuICAgIGlmIChPYmplY3Qua2V5cyhoaWdobGlnaHRlZEZpZWxkcykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXRhID0ge307XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZW50aXR5IGZpZWxkcyB0aGF0IGhhdmUgaGlnaGxpZ2h0aW5nIGluc3RydWN0aW9uc1xuICAgIE9iamVjdC5lbnRyaWVzKGhpZ2hsaWdodGVkRmllbGRzKS5mb3JFYWNoKChbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdKSA9PiB7XG4gICAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgaGlnaGxpZ2h0ZWQgZmllbGQgbmFtZSBjb3JyZXNwb25kcyB0byBhbiBleGlzdGluZyBlbnRpdHkgcHJvZmlsZSBmaWVsZFxuICAgICAgaWYgKGVudGl0eVByb2ZpbGVEYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29yZUVycm9yKCdIaWdobGlnaHRlZCBGaWVsZCBOYW1lIGRvZXMgbm90IGV4aXN0IGluIEVudGl0eSBQcm9maWxlJywgJ1Jlc3VsdEZhY3RvcnknKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGhpZ2hsaWdodGVkRmllbGQgPSBoaWdobGlnaHRlZEZpZWxkc1toaWdobGlnaHRlZEZpZWxkTmFtZV07XG5cbiAgICAgIC8vIGNoZWNrIGZvciBuZXN0ZWQgZmllbGRzXG4gICAgICBpZiAodHlwZW9mIGhpZ2hsaWdodGVkRmllbGQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgT2JqZWN0LmtleXMoaGlnaGxpZ2h0ZWRGaWVsZCkubGVuZ3RoID4gMCAmJlxuICAgICAgICAgIGhpZ2hsaWdodGVkRmllbGRbJ21hdGNoZWRTdWJzdHJpbmdzJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZWN1cnNlIHRvIGNoaWxkcmVuIGZpZWxkc1xuICAgICAgICBoaWdobGlnaHRlZERhdGFbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdID0gUmVzdWx0RmFjdG9yeS5jb21wdXRlSGlnaGxpZ2h0ZWREYXRhKFxuICAgICAgICAgIGVudGl0eVByb2ZpbGVEYXRhW2hpZ2hsaWdodGVkRmllbGROYW1lXSxcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkc1toaWdobGlnaHRlZEZpZWxkTmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGhpZ2hsaWdodGVkRGF0YVZhbHVlID0gbmV3IEhpZ2hsaWdodGVkVmFsdWUoZW50aXR5UHJvZmlsZURhdGEpLmJ1aWxkSGlnaGxpZ2h0ZWRWYWx1ZShcbiAgICAgICAgICBoaWdobGlnaHRlZEZpZWxkLnZhbHVlLFxuICAgICAgICAgIGhpZ2hsaWdodGVkRmllbGQubWF0Y2hlZFN1YnN0cmluZ3MpO1xuICAgICAgICBoaWdobGlnaHRlZERhdGFbaGlnaGxpZ2h0ZWRGaWVsZE5hbWVdID0gaGlnaGxpZ2h0ZWREYXRhVmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWREYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFQSSByZXN1bHQgb2JqZWN0IGludG8gYSBnZW5lcmljIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tR2VuZXJpYyAoZGF0YSwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICB0aXRsZTogZGF0YS5uYW1lLFxuICAgICAgZGV0YWlsczogdGhpcy50cnVuY2F0ZShkYXRhLmRlc2NyaXB0aW9uKSxcbiAgICAgIGxpbms6IGRhdGEud2Vic2l0ZSxcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgb3JkaW5hbDogaW5kZXggKyAxXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIEtub3dsZWRnZSBNYW5hZ2VyIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0dGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVydGljYWxJZFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGlnaGxpZ2h0ZWRGaWVsZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqL1xuICBzdGF0aWMgZnJvbUtub3dsZWRnZU1hbmFnZXIgKGRhdGEsIGZvcm1hdHRlcnMsIHZlcnRpY2FsSWQsIGhpZ2hsaWdodGVkRmllbGRzLCBpbmRleCkge1xuICAgIC8vIGNvbXB1dGUgaGlnaGxpZ2h0ZWQgZW50aXR5IHByb2ZpbGUgZGF0YVxuICAgIGxldCBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhID0gUmVzdWx0RmFjdG9yeS5jb21wdXRlSGlnaGxpZ2h0ZWREYXRhKGRhdGEsIGhpZ2hsaWdodGVkRmllbGRzKTtcbiAgICAvLyBjb21wdXRlIGZvcm1hdHRlZCBlbnRpdHkgcHJvZmlsZSBkYXRhXG4gICAgY29uc3QgZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEgPSBSZXN1bHRGYWN0b3J5LmNvbXB1dGVGb3JtYXR0ZWREYXRhKFxuICAgICAgZGF0YSwgZm9ybWF0dGVycywgdmVydGljYWxJZCwgaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSk7XG5cbiAgICAvLyBzZXQgcmVzdWx0IGRldGFpbHMgY2hlY2tpbmcgdGhlIGZvbGxvd2luZyBpbiBvcmRlciBvZiBwcmlvcml0eSA6IGZvcm1hdHRlZCwgaGlnaGxpZ2h0ZWQsIHJhd1xuICAgIGxldCByZXN1bHREZXRhaWxzID0gbnVsbDtcbiAgICBpZiAoZm9ybWF0dGVkRW50aXR5UHJvZmlsZURhdGEuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0RGV0YWlscyA9IGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhLmRlc2NyaXB0aW9uO1xuICAgIH0gZWxzZSBpZiAoaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHREZXRhaWxzID0gdGhpcy50cnVuY2F0ZShoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhLmRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0RGV0YWlscyA9IHRoaXMudHJ1bmNhdGUoZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgZm9ybWF0dGVkOiBmb3JtYXR0ZWRFbnRpdHlQcm9maWxlRGF0YSxcbiAgICAgIGhpZ2hsaWdodGVkOiBoaWdobGlnaHRlZEVudGl0eVByb2ZpbGVEYXRhLFxuICAgICAgdGl0bGU6IGZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhLm5hbWUgfHwgZGF0YS5uYW1lLFxuICAgICAgZGV0YWlsczogcmVzdWx0RGV0YWlscyxcbiAgICAgIGxpbms6IGRhdGEud2Vic2l0ZSxcbiAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgb3JkaW5hbDogaW5kZXggKyAxXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBNYXBzIHZpZXcgbW9kZWwgZmllbGRzIGJhc2VkIG9uIHRoZSBBUEkgZGF0YSBmb3IgYSBHb29nbGUgQ3VzdG9tIFNlYXJjaCBFbmdpbmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Hb29nbGVDdXN0b21TZWFyY2hFbmdpbmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh7XG4gICAgICByYXc6IGRhdGEsXG4gICAgICB0aXRsZTogZGF0YS5odG1sVGl0bGUucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKSxcbiAgICAgIGRldGFpbHM6IGRhdGEuaHRtbFNuaXBwZXQsXG4gICAgICBsaW5rOiBkYXRhLmxpbmtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBUEkgcmVzdWx0IG9iamVjdCBpbnRvIGEgcmVzdWx0IHZpZXcgbW9kZWwuXG4gICAqIE1hcHMgdmlldyBtb2RlbCBmaWVsZHMgYmFzZWQgb24gdGhlIEFQSSBkYXRhIGZvciBhIEJpbmcgQ3VzdG9tIFNlYXJjaCBFbmdpbmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEubmFtZSxcbiAgICAgIGRldGFpbHM6IGRhdGEuc25pcHBldCxcbiAgICAgIGxpbms6IGRhdGEudXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBNYXBzIHZpZXcgbW9kZWwgZmllbGRzIGJhc2VkIG9uIHRoZSBBUEkgZGF0YSBmb3IgYSBaZW5kZXNrIFNlYXJjaCBFbmdpbmUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJucyB7UmVzdWx0fVxuICAgKi9cbiAgc3RhdGljIGZyb21aZW5kZXNrU2VhcmNoRW5naW5lIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHQoe1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICBkZXRhaWxzOiBkYXRhLnNuaXBwZXQsXG4gICAgICBsaW5rOiBkYXRhLmh0bWxfdXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVBJIHJlc3VsdCBvYmplY3QgaW50byBhIHJlc3VsdCB2aWV3IG1vZGVsLlxuICAgKiBNYXBzIHZpZXcgbW9kZWwgZmllbGRzIGJhc2VkIG9uIHRoZSBBUEkgZGF0YSBmb3IgYSBBbGdvbGlhIFNlYXJjaCBFbmdpbmUgb2JqZWN0LlxuICAgKiBEZXRhaWxzIGZpZWxkIGlzIHNldCB0byBvYmplY3RJRCBzaW5jZSByZXNwb25zZSBoYXMgb25seSBvbmUgZ2VuZXJhbCBmaWVsZCBvYmplY3RJRC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge1Jlc3VsdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tQWxnb2xpYVNlYXJjaEVuZ2luZSAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHtcbiAgICAgIHJhdzogZGF0YSxcbiAgICAgIGRldGFpbHM6IGRhdGEub2JqZWN0SUQsXG4gICAgICBpZDogZGF0YS5vYmplY3RJRFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydW5jYXRlcyBzdHJpbmdzIHRvIDI1MCBjaGFyYWN0ZXJzLCBhdHRlbXB0aW5nIHRvIHByZXNlcnZlIHdob2xlIHdvcmRzXG4gICAqIEBwYXJhbSBzdHIge3N0cmluZ30gdGhlIHN0cmluZyB0byB0cnVuY2F0ZVxuICAgKiBAcGFyYW0gbGltaXQge051bWJlcn0gdGhlIG1heGltdW0gY2hhcmFjdGVyIGxlbmd0aCB0byByZXR1cm5cbiAgICogQHBhcmFtIHRyYWlsaW5nIHtzdHJpbmd9IGEgdHJhaWxpbmcgc3RyaW5nIHRvIGRlbm90ZSB0cnVuY2F0aW9uLCBlLmcuICcuLi4nXG4gICAqIEBwYXJhbSBzZXAge3N0cmluZ30gdGhlIHdvcmQgc2VwYXJhdG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgdHJ1bmNhdGUgKHN0ciwgbGltaXQgPSAyNTAsIHRyYWlsaW5nID0gJy4uLicsIHNlcCA9ICcgJykge1xuICAgIGlmICghc3RyIHx8IHN0ci5sZW5ndGggPD0gbGltaXQpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAoYm1jZ2lubmlzKTogc3BsaXQgcHVuY3R1YXRpb24gdG9vIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoIFwiZm9vLC4uLlwiXG4gICAgY29uc3Qgd29yZHMgPSBzdHIuc3BsaXQoc2VwKTtcbiAgICBjb25zdCBtYXggPSBsaW1pdCAtIHRyYWlsaW5nLmxlbmd0aDtcbiAgICBsZXQgdHJ1bmNhdGVkID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB3b3JkID0gd29yZHNbaV07XG4gICAgICBpZiAodHJ1bmNhdGVkLmxlbmd0aCArIHdvcmQubGVuZ3RoID4gbWF4IHx8XG4gICAgICAgIChpICE9PSAwICYmIHRydW5jYXRlZC5sZW5ndGggKyB3b3JkLmxlbmd0aCArIHNlcC5sZW5ndGggPiBtYXgpKSB7XG4gICAgICAgIHRydW5jYXRlZCArPSB0cmFpbGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRydW5jYXRlZCArPSBpID09PSAwID8gd29yZCA6IHNlcCArIHdvcmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydW5jYXRlZDtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU2VjdGlvbiAqL1xuXG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcbmltcG9ydCBSZXN1bHRGYWN0b3J5IGZyb20gJy4vcmVzdWx0ZmFjdG9yeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3Rpb24ge1xuICBjb25zdHJ1Y3RvciAoZGF0YSwgdXJsLCBmb3JtYXR0ZXJzKSB7XG4gICAgdGhpcy5zZWFyY2hTdGF0ZSA9IFNlYXJjaFN0YXRlcy5TRUFSQ0hfQ09NUExFVEU7XG4gICAgdGhpcy52ZXJ0aWNhbENvbmZpZ0lkID0gZGF0YS52ZXJ0aWNhbENvbmZpZ0lkIHx8IG51bGw7XG4gICAgdGhpcy5yZXN1bHRzQ291bnQgPSBkYXRhLnJlc3VsdHNDb3VudCB8fCAwO1xuICAgIHRoaXMuZW5jb2RlZFN0YXRlID0gZGF0YS5lbmNvZGVkU3RhdGUgfHwgJyc7XG4gICAgdGhpcy5hcHBsaWVkUXVlcnlGaWx0ZXJzID0gQXBwbGllZFF1ZXJ5RmlsdGVyLmZyb20oZGF0YS5hcHBsaWVkUXVlcnlGaWx0ZXJzKTtcbiAgICB0aGlzLmZhY2V0cyA9IGRhdGEuZmFjZXRzIHx8IG51bGw7XG4gICAgdGhpcy5yZXN1bHRzID0gUmVzdWx0RmFjdG9yeS5mcm9tKGRhdGEucmVzdWx0cywgZm9ybWF0dGVycywgdGhpcy52ZXJ0aWNhbENvbmZpZ0lkLCBkYXRhLnNvdXJjZSk7XG4gICAgdGhpcy5tYXAgPSBTZWN0aW9uLnBhcnNlTWFwKGRhdGEucmVzdWx0cyk7XG4gICAgdGhpcy52ZXJ0aWNhbFVSTCA9IHVybCB8fCBudWxsO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFwIChyZXN1bHRzKSB7XG4gICAgbGV0IG1hcE1hcmtlcnMgPSBbXTtcblxuICAgIGxldCBjZW50ZXJDb29yZGluYXRlcyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBUT0RPKGJpbGx5KSBSZW1vdmUgbGVnYWN5IGZhbGxiYWNrIGZyb20gYWxsIGRhdGEgZm9ybWF0XG4gICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tqXS5kYXRhIHx8IHJlc3VsdHNbal07XG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUpIHtcbiAgICAgICAgaWYgKCFjZW50ZXJDb29yZGluYXRlcy5sYXRpdHVkZSkge1xuICAgICAgICAgIGNlbnRlckNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgICAgbGF0aXR1ZGU6IHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUubGF0aXR1ZGUsXG4gICAgICAgICAgICBsb25naXR1ZGU6IHJlc3VsdC55ZXh0RGlzcGxheUNvb3JkaW5hdGUubG9uZ2l0dWRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBtYXBNYXJrZXJzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHJlc3VsdCxcbiAgICAgICAgICBsYWJlbDogbWFwTWFya2Vycy5sZW5ndGggKyAxLFxuICAgICAgICAgIGxhdGl0dWRlOiByZXN1bHQueWV4dERpc3BsYXlDb29yZGluYXRlLmxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogcmVzdWx0LnlleHREaXNwbGF5Q29vcmRpbmF0ZS5sb25naXR1ZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICdtYXBDZW50ZXInOiBjZW50ZXJDb29yZGluYXRlcyxcbiAgICAgICdtYXBNYXJrZXJzJzogbWFwTWFya2Vyc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2VjdGlvbiBmcm9tIHRoZSBwcm92aWRlZCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBtb2R1bGVzIFRoZSByZXN1bHQgbW9kdWxlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gdXJscyBUaGUgdGFiIHVybHNcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIEZpZWxkIGZvcm1hdHRlcnMgZm9yIHJlc3VsdHNcbiAgICovXG4gIHN0YXRpYyBmcm9tIChtb2R1bGVzLCB1cmxzLCBmb3JtYXR0ZXJzKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICByZXR1cm4gc2VjdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlY3Rpb24obW9kdWxlcywgbnVsbCwgZm9ybWF0dGVycyk7XG4gICAgfVxuXG4gICAgLy8gT3VyIHNlY3Rpb25zIHNob3VsZCBjb250YWluIGEgcHJvcGVydHkgb2YgbWFwTWFya2VyIG9iamVjdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICAgIG5ldyBTZWN0aW9uKFxuICAgICAgICAgIG1vZHVsZXNbaV0sXG4gICAgICAgICAgdXJsc1ttb2R1bGVzW2ldLnZlcnRpY2FsQ29uZmlnSWRdLFxuICAgICAgICAgIGZvcm1hdHRlcnNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbnM7XG4gIH1cbn1cblxuY2xhc3MgQXBwbGllZFF1ZXJ5RmlsdGVyIHtcbiAgLy8gU3VwcG9ydCBsZWdhY3kgbW9kZWwgYW5kIG5ldyBtb2RlbCB1bnRpbCBmdWxseSBtaWdyYXRlZC5cbiAgLy8gVE9ETyhiaWxseSkgUmVtb3ZlIHRoZSBsZWZ0IGV4cHJlc3Npb24gZHVyaW5nIGFzc2lnbm1lbnQgd2hlbiBtaWdyYXRlZC5cbiAgY29uc3RydWN0b3IgKGFwcGxpZWRRdWVyeUZpbHRlcikge1xuICAgIHRoaXMua2V5ID0gYXBwbGllZFF1ZXJ5RmlsdGVyLmtleSB8fCBhcHBsaWVkUXVlcnlGaWx0ZXIuZGlzcGxheUtleTtcbiAgICB0aGlzLnZhbHVlID0gYXBwbGllZFF1ZXJ5RmlsdGVyLnZhbHVlIHx8IGFwcGxpZWRRdWVyeUZpbHRlci5kaXNwbGF5VmFsdWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAoYXBwbGllZFF1ZXJ5RmlsdGVycykge1xuICAgIGxldCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcHBsaWVkUXVlcnlGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmaWx0ZXJzLnB1c2gobmV3IEFwcGxpZWRRdWVyeUZpbHRlcihhcHBsaWVkUXVlcnlGaWx0ZXJzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBVbml2ZXJzYWxSZXN1bHRzICovXG5cbmltcG9ydCBTZWN0aW9uIGZyb20gJy4vc2VjdGlvbic7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pdmVyc2FsUmVzdWx0cyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5xdWVyeUlkID0gZGF0YS5xdWVyeUlkIHx8IG51bGw7XG4gICAgdGhpcy5zZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2VhcmNoLCB1c2VkIHRvIHJlbmRlciBkaWZmZXJlbnQgdGVtcGxhdGVzIGJlZm9yZSwgZHVyaW5nLFxuICAgICAqIGFuZCBhZnRlciBsb2FkaW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaFN0YXRlID0gZGF0YS5zZWFyY2hTdGF0ZSB8fCBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB1bml2ZXJzYWwgcmVzdWx0cyBmcm9tIHNlcnZlciBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBUaGUgc2VydmVyIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cmxzIFRoZSB0YWIgdXJsc1xuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGZvcm1hdHRlcnMgVGhlIGZpZWxkIGZvcm1hdHRlcnMgdG8gdXNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UsIHVybHMsIGZvcm1hdHRlcnMpIHtcbiAgICByZXR1cm4gbmV3IFVuaXZlcnNhbFJlc3VsdHMoe1xuICAgICAgcXVlcnlJZDogcmVzcG9uc2UucXVlcnlJZCxcbiAgICAgIHNlY3Rpb25zOiBTZWN0aW9uLmZyb20ocmVzcG9uc2UubW9kdWxlcywgdXJscywgZm9ybWF0dGVycylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBVbml2ZXJ2YWxSZXN1bHRzIG9iamVjdCByZXByZXNlbnRpbmcgbG9hZGluZyByZXN1bHRzXG4gICAqIEByZXR1cm4ge1VuaXZlcnNhbFJlc3VsdHN9XG4gICAqL1xuICBzdGF0aWMgc2VhcmNoTG9hZGluZyAoKSB7XG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxSZXN1bHRzKHsgc2VhcmNoU3RhdGU6IFNlYXJjaFN0YXRlcy5TRUFSQ0hfTE9BRElORyB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgRGlyZWN0QW5zd2VyICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdEFuc3dlciB7XG4gIGNvbnN0cnVjdG9yIChkaXJlY3RBbnN3ZXIgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGlyZWN0QW5zd2VyKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERpcmVjdEFuc3dlciBtb2RlbCBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXIgZGF0YSBhbmQgZm9ybWF0dGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciBkaXJlY3QgYW5zd2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gZm9ybWF0dGVycyBUaGUgZm9ybWF0dGVycyB0byBhcHBseSB0byB0aGlzIGRpcmVjdCBhbnN3ZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tIChyZXNwb25zZSwgZm9ybWF0dGVycykge1xuICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJlc3BvbnNlIH07XG4gICAgY29uc3QgeyBhbnN3ZXIsIHJlbGF0ZWRJdGVtIH0gPSBkYXRhO1xuXG4gICAgaWYgKGFuc3dlciAmJiBmb3JtYXR0ZXJzW2Fuc3dlci5maWVsZEFwaU5hbWVdKSB7XG4gICAgICBhbnN3ZXIudmFsdWUgPSBmb3JtYXR0ZXJzW2Fuc3dlci5maWVsZEFwaU5hbWVdKFxuICAgICAgICBhbnN3ZXIudmFsdWUsXG4gICAgICAgIHJlbGF0ZWRJdGVtLmRhdGEuZmllbGRWYWx1ZXMsXG4gICAgICAgIHJlbGF0ZWRJdGVtLnZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICAgIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGlyZWN0QW5zd2VyKGRhdGEpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBOYXZpZ2F0aW9uICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb24ge1xuICBjb25zdHJ1Y3RvciAodGFiT3JkZXIpIHtcbiAgICB0aGlzLnRhYk9yZGVyID0gdGFiT3JkZXIgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChtb2R1bGVzKSB7XG4gICAgbGV0IG5hdiA9IFtdO1xuICAgIGlmICghbW9kdWxlcyB8fCAhQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgcmV0dXJuIG5hdjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYXYucHVzaChtb2R1bGVzW2ldLnZlcnRpY2FsQ29uZmlnSWQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hdmlnYXRpb24obmF2KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVmVydGljYWxSZXN1bHRzICovXG5cbmltcG9ydCBTZWN0aW9uIGZyb20gJy4vc2VjdGlvbic7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uL3N0b3JhZ2Uvc2VhcmNoc3RhdGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGljYWxSZXN1bHRzIHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBzZWFyY2hTdGF0ZTogU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSB9LCBkYXRhKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcHJvdmlkZWQgcmVzdWx0cyB0byB0aGUgY3VycmVudCByZXN1bHRzXG4gICAqIEBwYXJhbSB7VmVydGljYWxSZXN1bHRzfSByZXN1bHRzIHRoZSByZXN1bHRzIHRvIGFwcGVuZCB0byB0aGUgY3VycmVudCByZXN1bHRzXG4gICAqL1xuICBhcHBlbmQgKHJlc3VsdHMpIHtcbiAgICBjb25zdCBtZXJnZWQgPSB7IC4uLnRoaXMgfTtcbiAgICBtZXJnZWQucmVzdWx0cyA9IHRoaXMucmVzdWx0cy5jb25jYXQocmVzdWx0cy5yZXN1bHRzKTtcbiAgICBtZXJnZWQubWFwLm1hcE1hcmtlcnMgPSB0aGlzLm1hcC5tYXBNYXJrZXJzLmNvbmNhdChyZXN1bHRzLm1hcC5tYXBNYXJrZXJzKTtcbiAgICByZXR1cm4gbmV3IFZlcnRpY2FsUmVzdWx0cyhtZXJnZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB2ZXJ0aWNhbCByZXN1bHRzIGZyb20gc2VydmVyIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBzZXJ2ZXIgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBmb3JtYXR0ZXJzIFRoZSBmaWVsZCBmb3JtYXR0ZXJzIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlLCBmb3JtYXR0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBWZXJ0aWNhbFJlc3VsdHMoU2VjdGlvbi5mcm9tKHJlc3BvbnNlLCBudWxsLCBmb3JtYXR0ZXJzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgVmVydGljYWxSZXN1bHRzIG9iamVjdCByZXByZXNlbnRpbmcgbG9hZGluZyByZXN1bHRzXG4gICAqIEByZXR1cm4ge1ZlcnRpY2FsUmVzdWx0c31cbiAgICovXG4gIHN0YXRpYyBzZWFyY2hMb2FkaW5nICgpIHtcbiAgICByZXR1cm4gbmV3IFZlcnRpY2FsUmVzdWx0cyh7IHNlYXJjaFN0YXRlOiBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcgfSk7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3BlbGxDaGVjayAqL1xuXG5pbXBvcnQgSGlnaGxpZ2h0ZWRWYWx1ZSBmcm9tICcuL2hpZ2hsaWdodGVkdmFsdWUnO1xuXG4vKipcbiAqIFNwZWxsQ2hlY2sgaXMgdGhlIGNvcmUgc3RhdGUgbW9kZWxcbiAqIHRvIHBvd2VyIHRoZSBTcGVsbENoZWNrIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVsbENoZWNrIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwgcXVlcnlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucXVlcnkgPSBkYXRhLnF1ZXJ5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ycmVjdGVkIHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvcnJlY3RlZFF1ZXJ5ID0gZGF0YS5jb3JyZWN0ZWRRdWVyeSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvcnJlY3RlZCBxdWVyeSB3aXRoIGhpZ2hsaWdodGVkIHRhZ3NcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29ycmVjdGVkUXVlcnlEaXNwbGF5ID0gZGF0YS5jb3JyZWN0ZWRRdWVyeURpc3BsYXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzcGVsbCBjaGVjayB0eXBlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBzaG93IHNwZWxsIGNoZWNrIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvdWxkU2hvdyA9IHRoaXMuY29ycmVjdGVkUXVlcnkgIT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3BlbGwgY2hlY2sgbW9kZWwgZnJvbSB0aGUgcHJvdmlkZWQgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNwZWxsIGNoZWNrIHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTcGVsbENoZWNrKHtcbiAgICAgIHF1ZXJ5OiByZXNwb25zZS5vcmlnaW5hbFF1ZXJ5LFxuICAgICAgY29ycmVjdGVkUXVlcnk6IHJlc3BvbnNlLmNvcnJlY3RlZFF1ZXJ5LFxuICAgICAgY29ycmVjdGVkUXVlcnlEaXNwbGF5OiBuZXcgSGlnaGxpZ2h0ZWRWYWx1ZShyZXNwb25zZS5jb3JyZWN0ZWRRdWVyeSkuZ2V0KCksXG4gICAgICB0eXBlOiByZXNwb25zZS50eXBlXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFN0b3JhZ2VLZXlzICovXG5cbi8qKlxuICogU3RvcmFnZUtleXMgaXMgYW4gRU5VTSBhcmUgY29uc2lkZXJlZCB0aGUgcm9vdCBjb250ZXh0XG4gKiBmb3IgaG93IGRhdGEgaXMgc3RvcmVkIGFuZCBzY29wZWQgaW4gdGhlIHN0b3JhZ2UuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBOQVZJR0FUSU9OOiAnbmF2aWdhdGlvbicsXG4gIFVOSVZFUlNBTF9SRVNVTFRTOiAndW5pdmVyc2FsLXJlc3VsdHMnLFxuICBWRVJUSUNBTF9SRVNVTFRTOiAndmVydGljYWwtcmVzdWx0cycsXG4gIEFVVE9DT01QTEVURTogJ2F1dG9jb21wbGV0ZScsXG4gIERJUkVDVF9BTlNXRVI6ICdkaXJlY3QtYW5zd2VyJyxcbiAgRklMVEVSOiAnZmlsdGVyJyxcbiAgUVVFUlk6ICdxdWVyeScsXG4gIFFVRVJZX0lEOiAncXVlcnktaWQnLFxuICBGQUNFVF9GSUxURVI6ICdmYWNldC1maWx0ZXInLFxuICBEWU5BTUlDX0ZJTFRFUlM6ICdkeW5hbWljLWZpbHRlcnMnLFxuICBQQVJBTVM6ICdwYXJhbXMnLFxuICBHRU9MT0NBVElPTjogJ2dlb2xvY2F0aW9uJyxcbiAgSU5URU5UUzogJ2ludGVudHMnLFxuICBRVUVTVElPTl9TVUJNSVNTSU9OOiAncXVlc3Rpb24tc3VibWlzc2lvbicsXG4gIFNFQVJDSF9DT05GSUc6ICdzZWFyY2gtY29uZmlnJyxcbiAgU0VBUkNIX09GRlNFVDogJ3NlYXJjaC1vZmZzZXQnLFxuICBTUEVMTF9DSEVDSzogJ3NwZWxsLWNoZWNrJyxcbiAgTE9DQVRJT05fQklBUzogJ2xvY2F0aW9uLWJpYXMnLFxuICBTRVNTSU9OU19PUFRfSU46ICdzZXNzaW9ucy1vcHQtaW4nLFxuICBOQVZJR0FUSU9OX0NPTkZJRzogJ25hdmlnYXRpb24tY29uZmlnJyxcbiAgTE9DQUxFOiAnbG9jYWxlJ1xufTtcbiIsIi8qKiBAbW9kdWxlIER5bmFtaWNGaWx0ZXJzICovXG5cbi8qKlxuICogTW9kZWwgcmVwcmVzZW50aW5nIGEgc2V0IG9mIGR5bmFtaWMgZmlsdGVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEeW5hbWljRmlsdGVycyB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVycyB0aGlzIG1vZGVsIGhvbGRzXG4gICAgICogQHR5cGUge3tsYWJlbDogc3RyaW5nLCBmaWVsZElkOiBzdHJpbmcsIG9wdGlvbnM6IG9iamVjdFtdfX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcnMgPSBkYXRhLmZpbHRlcnMgfHwgW107XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcmdhbml6ZSAnZmFjZXRzJyBmcm9tIHRoZSBhcGkgcmVzcG9uc2UgaW50byBkeW5hbWljIGZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIGR5bmFtaWMgZmlsdGVyIHJlc3BvbnNlIGZyb20gdGhlIGFwaVxuICAgKiBAcmV0dXJucyB7RHluYW1pY0ZpbHRlcnN9XG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IGZhY2V0cyB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3QgZHluYW1pY0ZpbHRlcnMgPSBmYWNldHMubWFwKGYgPT4gKHtcbiAgICAgIGxhYmVsOiBmWydkaXNwbGF5TmFtZSddLFxuICAgICAgZmllbGRJZDogZlsnZmllbGRJZCddLFxuICAgICAgb3B0aW9uczogZi5vcHRpb25zLm1hcChvID0+ICh7XG4gICAgICAgIGxhYmVsOiBvWydkaXNwbGF5TmFtZSddLFxuICAgICAgICBjb3VudExhYmVsOiBvWydjb3VudCddLFxuICAgICAgICBzZWxlY3RlZDogb1snc2VsZWN0ZWQnXSxcbiAgICAgICAgZmlsdGVyOiBvWydmaWx0ZXInXVxuICAgICAgfSkpXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIG5ldyBEeW5hbWljRmlsdGVycyh7IGZpbHRlcnM6IGR5bmFtaWNGaWx0ZXJzIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hJbnRlbnRzICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEludGVudHMge1xuICBjb25zdHJ1Y3RvciAoaW50ZW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlbnQgdG8gZmluZCByZXN1bHRzIGJhc2VkIG9uIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5lYXJNZSA9IGludGVudHMubmVhck1lO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgU2VhcmNoSW50ZW50cyBmcm9tIHNlcnZlciByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIHNlcnZlciByZXNwb25zZSBpbnRlbnRzXG4gICAqIEByZXR1cm5zIHtTZWFyY2hJbnRlbnRzfVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgaW50ZW50cyA9IHJlc3BvbnNlIHx8IFtdO1xuXG4gICAgcmV0dXJuIG5ldyBTZWFyY2hJbnRlbnRzKHtcbiAgICAgIG5lYXJNZTogaW50ZW50cy5pbmNsdWRlcygnTkVBUl9NRScpXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIExvY2F0aW9uQmlhcyAqL1xuXG4vKipcbiAqIExvY2F0aW9uQmlhcyBpcyB0aGUgY29yZSBzdGF0ZSBtb2RlbFxuICogdG8gcG93ZXIgdGhlIExvY2F0aW9uQmlhcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25CaWFzIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gYmlhcyBhY2N1cmFjeSB3aGljaCBhcmUgSVAsIERFVklDRSBhbmQgVU5LTldPTlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hY2N1cmFjeSA9IGRhdGEuYWNjdXJhY3kgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXRpdHVkZSB1c2VkIGZvciBsb2NhdGlvbiBiaWFzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhdGl0dWRlID0gZGF0YS5sYXRpdHVkZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvbmdpdHVkZSB1c2VkIGZvciBsb2NhdGlvbiBiaWFzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvbmdpdHVkZSA9IGRhdGEubG9uZ2l0dWRlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gZGlzcGxheSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxvY2F0aW9uRGlzcGxheU5hbWUgPSBkYXRhLmxvY2F0aW9uRGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhdGlvbiBiaWFzIG1vZGVsIGZyb20gdGhlIHByb3ZpZGVkIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIFRoZSBsb2NhdGlvbiBiaWFzIHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gbmV3IExvY2F0aW9uQmlhcyh7XG4gICAgICAgIGFjY3VyYWN5OiAnVU5LTk9XTidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9jYXRpb25CaWFzKHtcbiAgICAgIGFjY3VyYWN5OiByZXNwb25zZS5hY2N1cmFjeSxcbiAgICAgIGxhdGl0dWRlOiByZXNwb25zZS5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogcmVzcG9uc2UubG9uZ2l0dWRlLFxuICAgICAgbG9jYXRpb25EaXNwbGF5TmFtZTogcmVzcG9uc2UubG9jYXRpb25EaXNwbGF5TmFtZVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hEYXRhVHJhbnNmb3JtZXIgKi9cblxuaW1wb3J0IFVuaXZlcnNhbFJlc3VsdHMgZnJvbSAnLi4vbW9kZWxzL3VuaXZlcnNhbHJlc3VsdHMnO1xuaW1wb3J0IERpcmVjdEFuc3dlciBmcm9tICcuLi9tb2RlbHMvZGlyZWN0YW5zd2VyJztcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uL21vZGVscy9uYXZpZ2F0aW9uJztcbmltcG9ydCBWZXJ0aWNhbFJlc3VsdHMgZnJvbSAnLi4vbW9kZWxzL3ZlcnRpY2FscmVzdWx0cyc7XG5pbXBvcnQgU3BlbGxDaGVjayBmcm9tICcuLi9tb2RlbHMvc3BlbGxjaGVjayc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgRHluYW1pY0ZpbHRlcnMgZnJvbSAnLi4vbW9kZWxzL2R5bmFtaWNmaWx0ZXJzJztcbmltcG9ydCBTZWFyY2hJbnRlbnRzIGZyb20gJy4uL21vZGVscy9zZWFyY2hpbnRlbnRzJztcbmltcG9ydCBMb2NhdGlvbkJpYXMgZnJvbSAnLi4vbW9kZWxzL2xvY2F0aW9uYmlhcyc7XG5cbi8qKlxuICogQSBEYXRhIFRyYW5zZm9ybWVyIHRoYXQgdGFrZXMgdGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIGEgU2VhcmNoIHJlcXVlc3RcbiAqIEFuZCB0cmFuc2Zvcm1zIGluIHRvIGEgZnJvbnQtZW5kIG9yaWVudGVkIGRhdGEgc3RydWN0dXJlIHRoYXQgb3VyXG4gKiBjb21wb25lbnQgbGlicmFyeSBhbmQgY29yZSBzdG9yYWdlIHVuZGVyc3RhbmQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaERhdGFUcmFuc2Zvcm1lciB7XG4gIHN0YXRpYyB0cmFuc2Zvcm0gKGRhdGEsIHVybHMgPSB7fSwgZm9ybWF0dGVycykge1xuICAgIGxldCByZXNwb25zZSA9IGRhdGEucmVzcG9uc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTdG9yYWdlS2V5cy5RVUVSWV9JRF06IHJlc3BvbnNlLnF1ZXJ5SWQsXG4gICAgICBbU3RvcmFnZUtleXMuTkFWSUdBVElPTl06IE5hdmlnYXRpb24uZnJvbShyZXNwb25zZS5tb2R1bGVzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSXTogRGlyZWN0QW5zd2VyLmZyb20ocmVzcG9uc2UuZGlyZWN0QW5zd2VyLCBmb3JtYXR0ZXJzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU106IFVuaXZlcnNhbFJlc3VsdHMuZnJvbShyZXNwb25zZSwgdXJscywgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuSU5URU5UU106IFNlYXJjaEludGVudHMuZnJvbShyZXNwb25zZS5zZWFyY2hJbnRlbnRzKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS106IFNwZWxsQ2hlY2suZnJvbShyZXNwb25zZS5zcGVsbENoZWNrKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXTogTG9jYXRpb25CaWFzLmZyb20ocmVzcG9uc2UubG9jYXRpb25CaWFzKVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdHJhbnNmb3JtVmVydGljYWwgKGRhdGEsIGZvcm1hdHRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1N0b3JhZ2VLZXlzLlFVRVJZX0lEXTogZGF0YS5yZXNwb25zZS5xdWVyeUlkLFxuICAgICAgW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dOiBuZXcgTmF2aWdhdGlvbigpLCAvLyBWZXJ0aWNhbCBkb2Vzbid0IHJlc3BvbmQgd2l0aCBvcmRlcmluZywgc28gdXNlIGVtcHR5IG5hdi5cbiAgICAgIFtTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTXTogVmVydGljYWxSZXN1bHRzLmZyb20oZGF0YS5yZXNwb25zZSwgZm9ybWF0dGVycyksXG4gICAgICBbU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTXTogRHluYW1pY0ZpbHRlcnMuZnJvbShkYXRhLnJlc3BvbnNlKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5JTlRFTlRTXTogU2VhcmNoSW50ZW50cy5mcm9tKGRhdGEucmVzcG9uc2Uuc2VhcmNoSW50ZW50cyksXG4gICAgICBbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdOiBTcGVsbENoZWNrLmZyb20oZGF0YS5yZXNwb25zZS5zcGVsbENoZWNrKSxcbiAgICAgIFtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXTogTG9jYXRpb25CaWFzLmZyb20oZGF0YS5yZXNwb25zZS5sb2NhdGlvbkJpYXMpXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUXVlc3Rpb25TdWJtaXNzaW9uICovXG5cbi8qKlxuICogUXVlc3Rpb25TdWJtaXNzaW9uIGlzIHRoZSBjb3JlIHN0YXRlIG1vZGVsXG4gKiB0byBwb3dlciB0aGUgUXVlc3Rpb25TdWJtaXNzaW9uIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVzdGlvblN1Ym1pc3Npb24ge1xuICBjb25zdHJ1Y3RvciAocXVlc3Rpb24gPSB7fSwgZXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGF1dGhvciBvZiB0aGUgcXVlc3Rpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IHF1ZXN0aW9uLm5hbWUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSBxdWVzdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5lbWFpbCA9IHF1ZXN0aW9uLmVtYWlsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwcml2YWN5IHBvbGljeSB3YXMgYXBwcm92ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByaXZhY3lQb2xpY3kgPSBxdWVzdGlvbi5wcml2YWN5UG9saWN5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlc3Rpb24gdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uVGV4dCA9IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQWx0ZXJuYXRpdmUgcXVlc3Rpb24gbWV0YSBpbmZvcm1hdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvbkRlc2NyaXB0aW9uID0gcXVlc3Rpb24ucXVlc3Rpb25EZXNjcmlwdGlvbiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZm9ybSBpcyBleHBhbmRlZCBvciBub3QuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgdGhpcy5xdWVzdGlvbkV4cGFuZGVkID0gdHlwZW9mIHF1ZXN0aW9uLmV4cGFuZGVkICE9PSAnYm9vbGVhbicgfHwgcXVlc3Rpb24uZXhwYW5kZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhbnkgZXJyb3JzIGFib3V0IHRoZSBxdWVzdGlvbiBzdWJtaXNzaW9uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycyB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZm9ybSBoYXMgYmVlbiBzdWJtaXR0ZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXN0aW9uU3VibWl0dGVkID0gcXVlc3Rpb24uc3VibWl0dGVkIHx8IGZhbHNlO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBzdWJtaXR0ZWQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBxdWVzdGlvblN1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgIHF1ZXN0aW9uRXhwYW5kZWQ6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGVycm9ycyAocXVlc3Rpb24sIGVycm9ycykge1xuICAgIHJldHVybiBRdWVzdGlvblN1Ym1pc3Npb24ocXVlc3Rpb24sIGVycm9ycyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlciAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXBpIGZpbHRlciBhbmQgcHJvdmlkZXMgc3RhdGljIG1ldGhvZHMgZm9yIGVhc2lseSBjb25zdHJ1Y3RpbmcgRmlsdGVycy5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci55ZXh0LmNvbS9kb2NzL2FwaS1yZWZlcmVuY2UvI29wZXJhdGlvbi9saXN0RW50aXRpZXMgZm9yIHN0cnVjdHVyZSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yIChkYXRhID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBKU09OIGZvcm1hdCBmaWx0ZXIgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGludG8gYSBGaWx0ZXJcbiAgICogQHBhcmFtIHsqfSByZXNwb25zZUZpbHRlciBBIGZpbHRlciBpbiBKU09OIGZvcm1hdCByZXR1cm5lZCBmcm9tIHRoZSBiYWNrZW5kXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlc3BvbnNlIChyZXNwb25zZUZpbHRlcikge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKEpTT04ucGFyc2UocmVzcG9uc2VGaWx0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgRmlsdGVyIHJlcHJlc2VudGluZyB0aGUgT1Igb2YgYWxsIHByb3ZpZGVkIGZpbHRlcnNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIE9SIHRvZ2V0aGVyXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgb3IgKC4uLmZpbHRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcih7XG4gICAgICAnJG9yJzogZmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBGaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSBBTkQgb2YgYWxsIHByb3ZpZGVkIGZpbHRlcnNcbiAgICogQHBhcmFtICB7Li4uRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIEFORCB0b2dldGhlclxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGFuZCAoLi4uZmlsdGVycykge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgICckYW5kJzogZmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9SIGZpbHRlcnMgd2l0aCB0aGUgc2FtZSBrZXlzLCB0aGVuIEFORCB0aGUgcmVzdWx0aW5nIGdyb3Vwc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gZ3JvdXBcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBncm91cCAoLi4uZmlsdGVycykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKGZpbHRlcilbMF07XG4gICAgICBpZiAoIWdyb3Vwc1trZXldKSB7XG4gICAgICAgIGdyb3Vwc1trZXldID0gW107XG4gICAgICB9XG4gICAgICBncm91cHNba2V5XS5wdXNoKGZpbHRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBGaWx0ZXJzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3Qua2V5cyhncm91cHMpKSB7XG4gICAgICBncm91cEZpbHRlcnMucHVzaChncm91cHNbZmllbGRdLmxlbmd0aCA+IDEgPyBGaWx0ZXIub3IoLi4uZ3JvdXBzW2ZpZWxkXSkgOiBncm91cHNbZmllbGRdWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBGaWx0ZXJzLmxlbmd0aCA+IDEgPyBGaWx0ZXIuYW5kKC4uLmdyb3VwRmlsdGVycykgOiBncm91cEZpbHRlcnNbMF07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwiZXF1YWwgdG9cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBlcXVhbCB0b1xuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGVxdWFsIChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLl9mcm9tTWF0Y2hlcihmaWVsZCwgJyRlcScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgXCJsZXNzIHRoYW5cIiBmaWx0ZXIgZm9yIGEgZmllbGRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBzdWJqZWN0IGZpZWxkIG9mIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW5cbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBsZXNzVGhhbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckbHQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwibGVzcyB0aGFuIG9yIGVxdWFsIHRvXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgbGVzc1RoYW5FcXVhbCAoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoZmllbGQsICckbGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFwiZ3JlYXRlciB0aGFuXCIgZmlsdGVyIGZvciBhIGZpZWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ3JlYXRlclRoYW4gKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGd0JywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBcImdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1wiIGZpbHRlciBmb3IgYSBmaWVsZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIHN1YmplY3QgZmllbGQgb2YgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKi9cbiAgc3RhdGljIGdyZWF0ZXJUaGFuRXF1YWwgKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBGaWx0ZXIuX2Zyb21NYXRjaGVyKGZpZWxkLCAnJGdlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmNsdXNpdmUgcmFuZ2UgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgaW5jbHVzaXZlUmFuZ2UgKGZpZWxkLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgJyRnZSc6IG1pbixcbiAgICAgICAgJyRsZSc6IG1heFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBleGNsdXNpdmUgcmFuZ2UgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7Kn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZXhjbHVzaXZlUmFuZ2UgKGZpZWxkLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgJyRndCc6IG1pbixcbiAgICAgICAgJyRsdCc6IG1heFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiBmaWx0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgb2YgdGhlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsbmcgVGhlIGxvbmdpdHVkZSBvZiB0aGUgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc2VhcmNoIHJhZGl1cyAoaW4gbWV0ZXJzKVxuICAgKi9cbiAgc3RhdGljIHBvc2l0aW9uIChsYXQsIGxuZywgcmFkaXVzKSB7XG4gICAgcmV0dXJuIEZpbHRlci5fZnJvbU1hdGNoZXIoJ2J1aWx0aW4ubG9jYXRpb24nLCAnJG5lYXInLCB7IGxhdCwgbG5nLCByYWRpdXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZpbHRlciB3aXRoIHRoZSBnaXZlbiBtYXRjaGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgc3ViamVjdCBmaWVsZCBvZiB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaGVyIFRoZSBtYXRjaGVyIGZvciB0aGUgZmlsZXJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBmaWx0ZXJcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIHN0YXRpYyBfZnJvbU1hdGNoZXIgKGZpZWxkLCBtYXRjaGVyLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKHtcbiAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgW21hdGNoZXJdOiB2YWx1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBDb3JlICovXG5cbmltcG9ydCBTZWFyY2hEYXRhVHJhbnNmb3JtZXIgZnJvbSAnLi9zZWFyY2gvc2VhcmNoZGF0YXRyYW5zZm9ybWVyJztcblxuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgVmVydGljYWxSZXN1bHRzIGZyb20gJy4vbW9kZWxzL3ZlcnRpY2FscmVzdWx0cyc7XG5pbXBvcnQgVW5pdmVyc2FsUmVzdWx0cyBmcm9tICcuL21vZGVscy91bml2ZXJzYWxyZXN1bHRzJztcbmltcG9ydCBRdWVzdGlvblN1Ym1pc3Npb24gZnJvbSAnLi9tb2RlbHMvcXVlc3Rpb25zdWJtaXNzaW9uJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9tb2RlbHMvZmlsdGVyJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2VydmljZXMvc2VhcmNoc2VydmljZScpLmRlZmF1bHR9IFNlYXJjaFNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NlcnZpY2VzL2F1dG9jb21wbGV0ZXNlcnZpY2UnKS5kZWZhdWx0fSBBdXRvQ29tcGxldGVTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zZXJ2aWNlcy9xdWVzdGlvbmFuc3dlcnNlcnZpY2UnKS5kZWZhdWx0fSBRdWVzdGlvbkFuc3dlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBDb3JlIGlzIHRoZSBtYWluIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBuZXR3b3JrIGFuZCBzdG9yYWdlXG4gKiByZWxhdGVkIGJlaGF2aW9ycyBvZiB0aGUgYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmUge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2xpZW50IEFQSSBLZXkgdXNlZCBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2xpZW50IEFuc3dlcnMgS2V5IHVzZWQgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlS2V5ID0gY29uZmlnLmV4cGVyaWVuY2VLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGllbnQgbG9jYWxlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cy4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gXCJlblwiIChmb3JcbiAgICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBmaWVsZCBmb3JtYXR0ZXJzIHVzZWQgdG8gZm9ybWF0IHJlc3VsdHMsIGlmIHByZXNlbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkRm9ybWF0dGVycyA9IGNvbmZpZy5maWVsZEZvcm1hdHRlcnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29yZSBkYXRhIHN0b3JhZ2UgdGhhdCBwb3dlcnMgdGhlIFVJXG4gICAgICogQHR5cGUge0dsb2JhbFN0b3JhZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2UgPSBjb25maWcuZ2xvYmFsU3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqIEB0eXBlIHtQZXJzaXN0ZW50U3RvcmFnZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGVyc2lzdGVudFN0b3JhZ2UgPSBjb25maWcucGVyc2lzdGVudFN0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiBjb250YWluaW5nIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBSRVNUZnVsIHNlYXJjaCBBUElcbiAgICAgKiBGb3IgYm90aCB2ZXJ0aWNhbCBhbmQgdW5pdmVyc2FsIHNlYXJjaFxuICAgICAqIEB0eXBlIHtTZWFyY2hTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2VhcmNoZXIgPSBjb25maWcuc2VhcmNoU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFic3RyYWN0aW9uIGNvbnRhaW5pbmcgdGhlIGludGVncmF0aW9uIHdpdGggdGhlIFJFU1RmdWwgYXV0b2NvbXBsZXRlIEFQSVxuICAgICAqIEZvciBmaWx0ZXIgc2VhcmNoLCB2ZXJ0aWNhbCBhdXRvY29tcGxldGUsIGFuZCB1bml2ZXJzYWwgYXV0b2NvbXBsZXRlXG4gICAgICogQHR5cGUge0F1dG9Db21wbGV0ZVNlcnZpY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hdXRvQ29tcGxldGUgPSBjb25maWcuYXV0b0NvbXBsZXRlU2VydmljZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFic3RyYWN0aW9uIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBRJkEgcmVzdCBpbnRlcmZhY2VcbiAgICAgKiBAdHlwZSB7UXVlc3Rpb25BbnN3ZXJTZXJ2aWNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcXVlc3Rpb25BbnN3ZXIgPSBjb25maWcucXVlc3Rpb25BbnN3ZXJTZXJ2aWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBpbiB0aGUgY29udGV4dCBvZiBhIHZlcnRpY2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSB2ZXJ0aWNhbCBJRCBmb3IgdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgVGhlIHF1ZXJ5IGRldGFpbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmlucHV0IFRoZSBpbnB1dCB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeS5maWx0ZXIgVGhlIGZpbHRlciB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkuZmFjZXRGaWx0ZXIgVGhlIGZhY2V0IGZpbHRlciB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKiBAcGFyYW0ge251bWJlcn0gcXVlcnkubGltaXQgVGhlIG1heCBudW1iZXIgb2YgcmVzdWx0cyB0byBpbmNsdWRlLCBtYXggb2YgNTBcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1ZXJ5Lm9mZnNldCBUaGUgcmVzdWx0cyBvZmZzZXQsIGZvciBmZXRjaGluZyBtb3JlIHJlc3VsdHMgb2YgdGhlIHNhbWUgcXVlcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5LmlkIFRoZSBxdWVyeSBJRCB0byB1c2UuIElmIHBhZ2luZyB3aXRoaW4gYSBxdWVyeSwgdGhlIHNhbWUgSUQgc2hvdWxkIGJlIHVzZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBxdWVyeS5hcHBlbmQgSWYgdHJ1ZSwgYWRkcyB0aGUgcmVzdWx0cyBvZiB0aGlzIHF1ZXJ5IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmVzdWx0cywgZGVmYXVsdHMgZmFsc2VcbiAgICovXG4gIHZlcnRpY2FsU2VhcmNoICh2ZXJ0aWNhbEtleSwgcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5LmFwcGVuZCkge1xuICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTLCBWZXJ0aWNhbFJlc3VsdHMuc2VhcmNoTG9hZGluZygpKTtcbiAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0ssIHt9KTtcbiAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUywge30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZWFyY2hlclxuICAgICAgLnZlcnRpY2FsU2VhcmNoKHZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGxpbWl0OiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQsXG4gICAgICAgIGdlb2xvY2F0aW9uOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04pLFxuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQ6IHRoaXMuX2lzRHluYW1pY0ZpbHRlcnNFbmFibGVkLFxuICAgICAgICBza2lwU3BlbGxDaGVjazogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdza2lwU3BlbGxDaGVjaycpLFxuICAgICAgICBxdWVyeVRyaWdnZXI6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZSgncXVlcnlUcmlnZ2VyJyksXG4gICAgICAgIHNlc3Npb25UcmFja2luZ0VuYWJsZWQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRVNTSU9OU19PUFRfSU4pXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gU2VhcmNoRGF0YVRyYW5zZm9ybWVyLnRyYW5zZm9ybVZlcnRpY2FsKHJlc3BvbnNlLCB0aGlzLl9maWVsZEZvcm1hdHRlcnMpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIGRhdGFbU3RvcmFnZUtleXMuUVVFUllfSURdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OLCBkYXRhW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5JTlRFTlRTLCBkYXRhW1N0b3JhZ2VLZXlzLklOVEVOVFNdKTtcblxuICAgICAgICBpZiAocXVlcnkuYXBwZW5kKSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkUmVzdWx0cyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTKVxuICAgICAgICAgICAgLmFwcGVuZChkYXRhW1N0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFNdKTtcbiAgICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMsIG1lcmdlZFJlc3VsdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVtTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlMsIGRhdGFbU3RvcmFnZUtleXMuRFlOQU1JQ19GSUxURVJTXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbU3RvcmFnZUtleXMuU1BFTExfQ0hFQ0tdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TUEVMTF9DSEVDSywgZGF0YVtTdG9yYWdlS2V5cy5TUEVMTF9DSEVDS10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCBkYXRhW1N0b3JhZ2VLZXlzLkxPQ0FUSU9OX0JJQVNdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdza2lwU3BlbGxDaGVjaycpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKCdxdWVyeVRyaWdnZXInKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhZ2Ugd2l0aGluIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSBUaGUgdmVydGljYWwga2V5IHRvIHVzZSBpbiB0aGUgc2VhcmNoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB0byB1c2UgaW4gdGhlIHNlYXJjaFxuICAgKi9cbiAgdmVydGljYWxQYWdlICh2ZXJ0aWNhbEtleSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICBjb25zdCB0b3RhbEZpbHRlciA9IGFsbEZpbHRlcnMubGVuZ3RoID4gMVxuICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgdGhpcy52ZXJ0aWNhbFNlYXJjaCh2ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSksXG4gICAgICBpZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZX0lEKSxcbiAgICAgIGZpbHRlcjogSlNPTi5zdHJpbmdpZnkodG90YWxGaWx0ZXIpLFxuICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKSxcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG5cbiAgc2VhcmNoIChxdWVyeVN0cmluZywgdXJscykge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuRElSRUNUX0FOU1dFUiwge30pO1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFMsIFVuaXZlcnNhbFJlc3VsdHMuc2VhcmNoTG9hZGluZygpKTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT04sIHt9KTtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCB7fSk7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTLCB7fSk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoZXJcbiAgICAgIC51bml2ZXJzYWxTZWFyY2gocXVlcnlTdHJpbmcsIHtcbiAgICAgICAgZ2VvbG9jYXRpb246IHRoaXMuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiksXG4gICAgICAgIHNraXBTcGVsbENoZWNrOiB0aGlzLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoJ3NraXBTcGVsbENoZWNrJyksXG4gICAgICAgIHF1ZXJ5VHJpZ2dlcjogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKCdxdWVyeVRyaWdnZXInKSxcbiAgICAgICAgc2Vzc2lvblRyYWNraW5nRW5hYmxlZDogdGhpcy5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFU1NJT05TX09QVF9JTilcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBTZWFyY2hEYXRhVHJhbnNmb3JtZXIudHJhbnNmb3JtKHJlc3BvbnNlLCB1cmxzLCB0aGlzLl9maWVsZEZvcm1hdHRlcnMpKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUllfSUQsIGRhdGFbU3RvcmFnZUtleXMuUVVFUllfSURdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5OQVZJR0FUSU9OLCBkYXRhW1N0b3JhZ2VLZXlzLk5BVklHQVRJT05dKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5ESVJFQ1RfQU5TV0VSLCBkYXRhW1N0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVJdKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUUywgZGF0YVtTdG9yYWdlS2V5cy5VTklWRVJTQUxfUkVTVUxUU10sIHVybHMpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLklOVEVOVFMsIGRhdGFbU3RvcmFnZUtleXMuSU5URU5UU10pO1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLLCBkYXRhW1N0b3JhZ2VLZXlzLlNQRUxMX0NIRUNLXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUywgZGF0YVtTdG9yYWdlS2V5cy5MT0NBVElPTl9CSUFTXSk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3NraXBTcGVsbENoZWNrJyk7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5kZWxldGUoJ3F1ZXJ5VHJpZ2dlcicpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHF1ZXJ5IGZvciBhIGxpc3Qgb2Ygc2ltaWxhciByZXN1bHRzIGFuZCBzZXQgaW50byBzdG9yYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAgICAgdGhlIHN0cmluZyB0byBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqL1xuICBhdXRvQ29tcGxldGVVbml2ZXJzYWwgKGlucHV0LCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlXG4gICAgICAucXVlcnlVbml2ZXJzYWwoaW5wdXQpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5BVVRPQ09NUExFVEV9LiR7bmFtZXNwYWNlfWAsIGRhdGEpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW4gaW5wdXQsIHF1ZXJ5IGZvciBhIGxpc3Qgb2Ygc2ltaWxhciByZXN1bHRzIGluIHRoZSBwcm92aWRlZCB2ZXJ0aWNhbFxuICAgKiBhbmQgc2V0IGludG8gc3RvcmFnZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgICAgICAgdGhlIHN0cmluZyB0byBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIHN0b3JhZ2Uga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0aWNhbEtleSB0aGUgdmVydGljYWwga2V5IGZvciB0aGUgZXhwZXJpZW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFyS2V5ICAgICAgdGhlIGJhciBrZXkgZm9yIHRoZSBleHBlcmllbmNlXG4gICAqL1xuICBhdXRvQ29tcGxldGVWZXJ0aWNhbCAoaW5wdXQsIG5hbWVzcGFjZSwgdmVydGljYWxLZXksIGJhcktleSkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvQ29tcGxldGVcbiAgICAgIC5xdWVyeVZlcnRpY2FsKGlucHV0LCB2ZXJ0aWNhbEtleSwgYmFyS2V5KVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuQVVUT0NPTVBMRVRFfS4ke25hbWVzcGFjZX1gLCBkYXRhKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIGlucHV0LCBwcm92aWRlIGEgbGlzdCBvZiBzdWl0YWJsZSBmaWx0ZXJzIGZvciBhdXRvY29tcGxldGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgIHRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvciBmaWx0ZXJzIHdpdGhcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAgdGhlIGNvbmZpZyB0byBzZXJhY2ggZm9yIGZpbHRlcnMgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLm5hbWVzcGFjZSAgdGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBzdG9yYWdlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnZlcnRpY2FsS2V5IHRoZSB2ZXJ0aWNhbCBrZXkgZm9yIHRoZSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5iYXJLZXkgIHRoZSBiYXIga2V5IGZvciB0aGUgY29uZmlnIHYxXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcuc2VhcmNoUGFyYW1ldGVycyAgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIGZvciB0aGUgY29uZmlnIHYyXG4gICAqL1xuICBhdXRvQ29tcGxldGVGaWx0ZXIgKGlucHV0LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0NvbXBsZXRlXG4gICAgICAucXVlcnlGaWx0ZXIoaW5wdXQsIGNvbmZpZylcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KGAke1N0b3JhZ2VLZXlzLkFVVE9DT01QTEVURX0uJHtjb25maWcubmFtZXNwYWNlfWAsIGRhdGEpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhIHF1ZXN0aW9uIHRvIHRoZSBzZXJ2ZXIgYW5kIHVwZGF0ZXMgdGhlIHVuZGVybHlpbmcgcXVlc3Rpb24gbW9kZWxcbiAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXN0aW9uIFRoZSBxdWVzdGlvbiBvYmplY3QgdG8gc3VibWl0IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1ZXN0aW9uLmVudGl0eUlkIFRoZSBlbnRpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHF1ZXN0aW9uIChyZXF1aXJlZClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLmxhbnVhZ2UgVGhlIGxhbmd1YWdlIG9mIHRoZSBxdWVzdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24uc2l0ZSBUaGUgXCJwdWJsaXNoZXJcIiBvZiB0aGUgKGUuZy4gJ0ZJUlNUX1BBUlRZJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXN0aW9uLm5hbWUgVGhlIG5hbWUgb2YgdGhlIGF1dGhvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24uZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIGF1dGhvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24ucXVlc3Rpb25UZXh0IFRoZSBxdWVzdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlc3Rpb24ucXVlc3Rpb25EZXNjcmlwdGlvbiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBxdWVzdGlvblxuICAgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXN0aW9uQW5zd2VyXG4gICAgICAuc3VibWl0UXVlc3Rpb24ocXVlc3Rpb24pXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChcbiAgICAgICAgICBTdG9yYWdlS2V5cy5RVUVTVElPTl9TVUJNSVNTSU9OLFxuICAgICAgICAgIFF1ZXN0aW9uU3VibWlzc2lvbi5zdWJtaXR0ZWQoKSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIHF1ZXJ5IGludG8gc3RvcmFnZSwgdG8gYmUgdXNlZCBmb3IgdGhlIG5leHQgc2VhcmNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgcXVlcnkgdG8gc3RvcmVcbiAgICovXG4gIHNldFF1ZXJ5IChxdWVyeSkge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUlksIHF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIHByb3ZpZGVkIHF1ZXJ5IElELCB0byBiZSB1c2VkIGluIGFuYWx5dGljc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlJZCBUaGUgcXVlcnkgaWQgdG8gc3RvcmVcbiAgICovXG4gIHNldFF1ZXJ5SWQgKHF1ZXJ5SWQpIHtcbiAgICB0aGlzLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZX0lELCBxdWVyeUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIGZpbHRlciBpbnRvIHN0b3JhZ2UsIHRvIGJlIHVzZWQgZm9yIHRoZSBuZXh0IHNlYXJjaFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIHRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgc3RvcmFnZSBrZXlcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlciAgICB0aGUgZmlsdGVyIHRvIHNldFxuICAgKi9cbiAgc2V0RmlsdGVyIChuYW1lc3BhY2UsIGZpbHRlcikge1xuICAgIHRoaXMuZ2xvYmFsU3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke25hbWVzcGFjZX1gLCBmaWx0ZXIpO1xuICB9XG5cbiAgc2V0RmFjZXRGaWx0ZXIgKG5hbWVzcGFjZSwgZmlsdGVyKSB7XG4gICAgdGhpcy5nbG9iYWxTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5GQUNFVF9GSUxURVJ9LiR7bmFtZXNwYWNlfWAsIGZpbHRlcik7XG4gIH1cblxuICBlbmFibGVEeW5hbWljRmlsdGVycyAoKSB7XG4gICAgdGhpcy5faXNEeW5hbWljRmlsdGVyc0VuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgb24gKGV2dCwgbW9kdWxlSWQsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsU3RvcmFnZS5vbihldnQsIG1vZHVsZUlkLCBjYik7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIERPTSAqL1xuXG4vKiBnbG9iYWwgSFRNTEVsZW1lbnQsIEhUTUxEb2N1bWVudCwgV2luZG93LCBFdmVudCAqL1xuXG5sZXQgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbi8qKlxuICogU3RhdGljIGludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIEFQSS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NIHtcbiAgc3RhdGljIHNldHVwIChkLCBwKSB7XG4gICAgZG9jdW1lbnQgPSBkO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIEhUTUxFbGVtZW50IGZyb20gYW5kIEhUTUwgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIFRoZSBIVE1MIHRvIHBhcnNlIHRvIGEgRE9NIG5vZGUuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSAoaHRtbCkge1xuICAgIGlmICgnY3JlYXRlUmFuZ2UnIGluIGRvY3VtZW50KSB7XG4gICAgICAvLyBwcmVmZXIgdGhpcyBpbXBsZW1lbnRhdGlvbiBhcyBpdCBoYXMgd2lkZXIgYnJvd3NlciBzdXBwb3J0XG4gICAgICAvLyBhbmQgaXQncyBiZXR0ZXIgcGVyZm9ybWluZy5cbiAgICAgIC8vIHNlZSBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9jb252ZXJ0LWh0bWwtc3RpbmdzLWRvbS1ub2Rlc1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIHRvIHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBqc2RvbSB0aGF0IGNhdXNlcyB0ZXN0cyB0byBmYWlsXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vanNkb20vanNkb20vaXNzdWVzLzM5OVxuICAgIHJldHVybiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKS5ib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIHF1ZXJ5IHRoZSBET00gZm9yIGEgZ2l2ZW4gY3NzIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBPcHRpb25hbCBjb250ZXh0IHRvIHVzZSBmb3IgYSBzZWFyY2guIERlZmF1bHRzIHRvIGRvY3VtZW50IGlmIG5vdCBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIHRoZSBDU1Mgc2VsZWN0b3IgdG8gcXVlcnkgZm9yXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdGhlIEZJUlNUIG5vZGUgaXQgZmluZHMsIGlmIGFueVxuICAgKi9cbiAgc3RhdGljIHF1ZXJ5IChwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgLy8gRmFjYWRlLCBzaGlmdGluZyB0aGUgc2VsZWN0b3IgdG8gdGhlIHBhcmVudCBhcmd1bWVudCBpZiBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50IGlzIHByb3ZpZGVkXG4gICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbGVjdG9yID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgc2VsZWN0b3IgaW5zdGFuY2VvZiBXaW5kb3cgfHwgc2VsZWN0b3IgaW5zdGFuY2VvZiBIVE1MRG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIHF1ZXJ5IHRoZSBET00gZm9yIGEgZ2l2ZW4gY3NzIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBPcHRpb25hbCBjb250ZXh0IHRvIHVzZSBmb3IgYSBzZWFyY2guIERlZmF1bHRzIHRvIGRvY3VtZW50IGlmIG5vdCBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIHRoZSBDU1Mgc2VsZWN0b3IgdG8gcXVlcnkgZm9yXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIEZJUlNUIG5vZGUgaXQgZmluZHMsIGlmIGFueVxuICAgKi9cbiAgc3RhdGljIHF1ZXJ5QWxsIChwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgLy8gRmFjYWRlLCBzaGlmdGluZyB0aGUgc2VsZWN0b3IgdG8gdGhlIHBhcmVudCBhcmd1bWVudCBpZiBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50IGlzIHByb3ZpZGVkXG4gICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbGVjdG9yID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGNsaWVudCBjb2RlIGlzIHVzaW5nIGEgcG9pbnRlciB0byBhIGRvbSBub2RlIGFuZCBpdCdzIG51bGwsIGUuZy4gdGhpcy5fY29udGFpbmVyXG4gICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgcmV0dXJuIFtzZWxlY3Rvcl07XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgfVxuXG4gIHN0YXRpYyBvblJlYWR5IChjYikge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpIHtcbiAgICAgIGNiKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRE9NLm9uKGRvY3VtZW50LCAnRE9NQ29udGVudExvYWRlZCcsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGVFbGUgd2lsbCBjcmVhdGUgYSB7SFRNTEVsZW1lbnR9IGFuZCBhcHBseSB0aGUgcHJvcGVydGllcyBhdHRyaWJ1dGVzIHRocm91Z2ggYW4gb2JqZWN0IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWwgVGhlIGVsZW1lbnQgYHRhZ2AgbmFtZSB0byBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNfZGF0YSBPcHRpb25hbCBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBuZXcgSFRNTEVsZW1lbnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVFbCAoZWwsIG9wdHNfZGF0YSA9IHt9KSB7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsKTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3Qua2V5cyhvcHRzX2RhdGEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BzW2ldID09PSAnY2xhc3MnKSB7XG4gICAgICAgIERPTS5hZGRDbGFzcyhub2RlLCBvcHRzX2RhdGFbcHJvcHNbaV1dKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGVbcHJvcHNbaV1dID0gb3B0c19kYXRhW3Byb3BzW2ldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmQgKHBhcmVudCwgbm9kZSkge1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmVudCA9IERPTS5xdWVyeShwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgSFRNTCBpbmplY3Rpb24gYXMgd2VsbCBhcyBIVE1MRWxlbWVudCBhcHBlbmRzXG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyZW50Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJCZWdpbicsIG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFkZENsYXNzIChub2RlLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnLCcpO1xuICAgIGxldCBsZW4gPSBjbGFzc2VzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZW1wdHkgKHBhcmVudCkge1xuICAgIHBhcmVudC5pbm5lckhUTUwgPSAnJztcbiAgfVxuXG4gIHN0YXRpYyBjc3MgKHNlbGVjdG9yLCBzdHlsZXMpIHtcbiAgICBsZXQgbm9kZSA9IERPTS5xdWVyeShzZWxlY3Rvcik7XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIHN0eWxlcykge1xuICAgICAgbm9kZS5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXR0ciAoc2VsZWN0b3IsIGF0dHIsIHZhbCkge1xuICAgIERPTS5xdWVyeShzZWxlY3Rvcikuc2V0QXR0cmlidXRlKGF0dHIsIHZhbCk7XG4gIH1cblxuICBzdGF0aWMgYXR0cmlidXRlcyAoc2VsZWN0b3IsIGF0dHJzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cnMpXG4gICAgICAuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IHRoaXMuYXR0cihzZWxlY3RvciwgYXR0ciwgdmFsKSk7XG4gIH1cblxuICBzdGF0aWMgdHJpZ2dlciAoc2VsZWN0b3IsIGV2ZW50LCBzZXR0aW5ncykge1xuICAgIGxldCBlID0gbmV3IEV2ZW50KGV2ZW50LCBPYmplY3QuYXNzaWduKHtcbiAgICAgICdidWJibGVzJzogdHJ1ZSxcbiAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZVxuICAgIH0sIHNldHRpbmdzIHx8IHt9KSk7XG5cbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICBzdGF0aWMgb24gKHNlbGVjdG9yLCBldnQsIGhhbmRsZXIpIHtcbiAgICBET00ucXVlcnkoc2VsZWN0b3IpLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBvbmNlIChzZWxlY3RvciwgZXZ0LCBoYW5kbGVyKSB7XG4gICAgRE9NLnF1ZXJ5KHNlbGVjdG9yKS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICB9XG5cbiAgc3RhdGljIG9mZiAoc2VsZWN0b3IsIGV2dCwgaGFuZGxlcikge1xuICAgIERPTS5xdWVyeShzZWxlY3RvcikucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgc3RhdGljIGRlbGVnYXRlIChjdHh0LCBzZWxlY3RvciwgZXZ0LCBoYW5kbGVyKSB7XG4gICAgbGV0IGVsID0gRE9NLnF1ZXJ5KGN0eHQpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICB3aGlsZSAoIXRhcmdldC5pc0VxdWFsTm9kZShlbCkpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGhhbmRsZXIoZXZlbnQsIHRhcmdldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFNlYXJjaFBhcmFtcyAqL1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG5cbi8qKlxuICogU2VhcmNoUGFyYW1zIGlzIGEgY2xhc3MgdG8gZ2V0IHRoZSBzZWFyY2ggcGFyYW1zIGluIGEgVVJMLlxuICogSXQgaXMgYSByZXBsYWNlbWVudCBmb3IgVVJMLnNlYXJjaFBhcmFtcyBhbmQgVVJMU2VhcmNoUGFyYW1zIGZvciBicm93c2VycyBsaWtlIElFMTFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoUGFyYW1zIHtcbiAgY29uc3RydWN0b3IgKHVybCkge1xuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgb2YgYWxsIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIHVybCwgcXVlcnkgcGFyYW0gLT4gdmFsdWVcbiAgICAgKiBPbmx5IHVzZWQgaWYgVVJMU2VhcmNoUGFyYW1zIGRvZXMgbm90IGV4aXN0IGluIHRoZSB3aW5kb3dcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0ge307XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5VUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmFtcyA9IHRoaXMucGFyc2UodXJsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgY3JlYXRlcyBhIG1hcHBpbmcgb2YgYWxsIHF1ZXJ5IHBhcmFtcyBpbiBhIGdpdmVuIHVybFxuICAgKiBUaGUgcXVlcnkgcGFyYW0gdmFsdWVzIGFyZSBkZWNvZGVkIGJlZm9yZSBiZWluZyBwdXQgaW4gdGhlIG1hcFxuICAgKiBUaHJlZSB0eXBlcyBvZiBpbnB1dCBhcmUgc3VwcG9ydGVkXG4gICAqICAgKDEpIGZ1bGwgVVJMIGUuZy4gaHR0cDovL3d3dy55ZXh0LmNvbS8/cT1oZWxsb1xuICAgKiAgICgyKSBwYXJhbXMgd2l0aCA/IGUuZy4gP3E9aGVsbG9cbiAgICogICAoMSkgcGFyYW1zIHdpdGhvdXQgPyBlLmcuIHE9aGVsbG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG1hcHBpbmcgZnJvbSBxdWVyeSBwYXJhbSAtPiB2YWx1ZSB3aGVyZSB2YWx1ZSBpcyAnJyBpZiBubyB2YWx1ZSBpcyBwcm92aWRlZFxuICAgKi9cbiAgcGFyc2UgKHVybCkge1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgc2VhcmNoID0gdXJsO1xuXG4gICAgaWYgKHNlYXJjaCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGFsbCB1cmwgaW5wdXRzIHRvIHN0cmluZyBvZiBxdWVyeSBwYXJhbXMgc2VwYXJhdGVkIGJ5ICZcbiAgICBpZiAodXJsLmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICBzZWFyY2ggPSB1cmwuc2xpY2UodXJsLmluZGV4T2YoJz8nKSArIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBzZWFyY2guc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWRQYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleVZhbCA9IGVuY29kZWRQYXJhbXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChrZXlWYWwubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJhbXNba2V5VmFsWzBdXSA9IFNlYXJjaFBhcmFtcy5kZWNvZGUoa2V5VmFsWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtc1trZXlWYWxbMF1dID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHF1ZXJ5IHBhcmFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgcXVlcnkgcGFyYW0ga2V5IHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXJhbSB2YWx1ZSwgbnVsbCBvdGhlcndpc2VcbiAgICovXG4gIGdldCAocXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BhcmFtc1tTdHJpbmcocXVlcnkpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zW3F1ZXJ5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBxdWVyeSBwYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcXVlcnkgcGFyYW0ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIHF1ZXJ5IHBhcmFtIHVwZGF0ZSB3aXRoXG4gICAqL1xuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fcGFyYW1zW1N0cmluZyhuYW1lKV0gPSBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhhcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBnaXZlbiBxdWVyeSBwYXJhbSBrZXkgZXhpc3RzIGluIHRoZSBwYXJhbXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgcXVlcnkgcGFyYW0gdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgcXVlcnkgcGFyYW0gaXMgaW4gdGhlIHBhcmFtcyBvYmplY3QsIGZhbHNlIG8vd1xuICAgKi9cbiAgaGFzIChxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeSBpbiB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogdG9TdHJpbmcgcmV0dXJucyBhIHVybCB3aXRoIGFsbCB0aGUgcXVlcnkgcGFyYW1zIGluIHRoZSBwYXJhbXMgb2JqZWN0ICh3aXRob3V0IGEgPylcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICBzdHJpbmcucHVzaChgJHtrZXl9PSR7U2VhcmNoUGFyYW1zLmVuY29kZSh0aGlzLl9wYXJhbXNba2V5XSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmcuam9pbignJicpO1xuICB9XG5cbiAgZW50cmllcyAoKSB7XG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICBlbnRyaWVzLnB1c2goW2tleSwgdGhpcy5fcGFyYW1zW2tleV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICAvKipcbiAgICogZGVjb2RlIHJldHVybnMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgdG8gZGVjb2RlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKHN0cmluZykge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyaW5nLnJlcGxhY2UoL1sgK10vZywgJyUyMCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGUgcmV0dXJucyB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nIChlLmcuICsgLT4gJTJCKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUgKHN0cmluZykge1xuICAgIGxldCByZXBsYWNlID0ge1xuICAgICAgJyEnOiAnJTIxJyxcbiAgICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAgICcoJzogJyUyOCcsXG4gICAgICAnKSc6ICclMjknLFxuICAgICAgJyUyMCc6ICcrJ1xuICAgIH07XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpLnJlcGxhY2UoL1shJygpXXwlMjAvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlbmRlcmVyICovXG5cbi8qKlxuICogUmVuZGVyZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBhbGwgUmVuZGVyZXJzIHNob3VsZCBleHRlbmQgYW5kIGltcGxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciB7XG4gIC8qKlxuICAgKiByZW5kZXIgaXMgYSBjb3JlIG1ldGhvZCBmb3IgYWxsIHJlbmRlcmVycy5cbiAgICogQWxsIGltcGxlbWVudGF0aW9ucyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICovXG4gIHJlbmRlciAodGVtcGxhdGUsIGRhdGEpIHtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICByZWdpc3RlckhlbHBlciAobmFtZSwgY2IpIHtcblxuICB9XG5cbiAgY29tcGlsZSAodGVtcGxhdGUpIHtcblxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBIYW5kbGViYXJzUmVuZGVyZXIgKi9cblxuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXInO1xuXG4vKipcbiAqIEhhbmRsZWJhcnNSZW5kZXJlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmF0ZSBoYW5kbGViYXJzIHJlbmRlcmVyLlxuICogQGV4dGVuZHMgUmVuZGVyZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGFuZGxlYmFyc1JlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvciAodGVtcGxhdGVzID0ge30sIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgaGFuZGxlYmFycyBjb21waWxlclxuICAgICAqIEB0eXBlIHtIYW5kbGViYXJzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGFuZGxlYmFycyA9IHRlbXBsYXRlcy5faGIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBwcmUtY29tcGlsZWQgaGFuZGxlYmFycyB0ZW1wbGF0ZXNcbiAgICAgKiBAdHlwZSB7SGFuZGxlYmFyc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCB7fTtcbiAgfVxuXG4gIGluaXQgKHRlbXBsYXRlcykge1xuICAgIC8vIEFzc2lnbiB0aGUgaGFuZGxlYmFycyBjb21waWxlciBhbmQgdGVtcGxhdGVzIGJhc2VkIG9uXG4gICAgLy8gaW5mb3JtYXRpb24gcHJvdmlkZWQgZnJvbSBleHRlcm5hbCBkZXAgKGluIGRlZmF1bHQgY2FzZSwgaXQgY29tZXMgZnJvbSBleHRlcm5hbCBzZXJ2ZXIgcmVxdWVzdClcbiAgICB0aGlzLl9oYW5kbGViYXJzID0gdGVtcGxhdGVzLl9oYjtcbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG5cbiAgICAvLyBUT0RPKGJpbGx5KSBPbmNlIHdlIHJlLXdyaXRlIHRlbXBsYXRlcyB1c2luZyB0aGUgbmV3IGhlbHBlcnMgbGlicmFyeVxuICAgIC8vIHdlIHByb2JhYmx5IGRvbid0IG5lZWQgdGhlc2UgY3VzdG9tIGhlbHBlcnMgYW55bW9yZVxuICAgIHRoaXMuX3JlZ2lzdGVyQ3VzdG9tSGVscGVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVySGVscGVyIGlzIGEgcHVibGljIGludGVyZmFjZSBmb3IgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIHRvXG4gICAqIHJlZ2lzdGVyIHRoZWlyIG93biBjdXN0b20gaGVscGVycyB0byBvdXIgaW50ZXJuYWwgSGFuZGxlYmFycyBDb21waWxlclxuICAgKi9cbiAgcmVnaXN0ZXJIZWxwZXIgKG5hbWUsIGNiKSB7XG4gICAgdGhpcy5faGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogY29tcGlsZSBhIGhhbmRsZWJhcnMgdGVtcGxhdGUgc28gdGhhdCBpdCBjYW4gYmUgcmVuZGVyZWQsXG4gICAqIHVzaW5nIHRoZSB7SGFuZGxlYmFyc30gY29tcGlsZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBzdHJpbmcgdG8gY29tcGlsZVxuICAgKi9cbiAgY29tcGlsZSAodGVtcGxhdGUpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGFuZGxlYmFycy5jb21waWxlKHRlbXBsYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW5kZXIgd2lsbCByZW5kZXIgYSB0ZW1wbGF0ZSB3aXRoIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBQcm92aWRlIGVpdGhlciBhIHRlbXBsYXRlTmFtZSBvciBhIHByZS1jb21waWxlZCB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBwcm92aWRlIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVuZGVyIChjb25maWcsIGRhdGEpIHtcbiAgICAvLyBJZiBhIGN1c3RvbSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCwgdXNlIGl0LFxuICAgIC8vIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIHRlbXBsYXRlIG5hbWVcbiAgICAvLyBUT0RPKGJpbGx5KSBUaGlzIGludGVyZmFjZSBzaG91bGQgcHJvYmFibHkgYmUgbGVzcyB1Z2x5XG4gICAgaWYgKGNvbmZpZy50ZW1wbGF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy50ZW1wbGF0ZShkYXRhKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlc1tjb25maWcudGVtcGxhdGVOYW1lXShkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZmluZC9yZW5kZXIgdGVtcGxhdGU6ICcgKyBjb25maWcudGVtcGxhdGVOYW1lLCBlKTtcbiAgICB9XG4gIH1cblxuICBfcmVnaXN0ZXJDdXN0b21IZWxwZXJzICgpIHtcbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyKCdpZmVxJywgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoYXJnMSA9PT0gYXJnMikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignaWZub3RlcScsIGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKGFyZzEgIT09IGFyZzIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2Zvcm1hdFBob25lTnVtYmVyJywgZnVuY3Rpb24gKHBob25lTnVtYmVyU3RyaW5nKSB7XG4gICAgICB2YXIgY2xlYW5lZCA9ICgnJyArIHBob25lTnVtYmVyU3RyaW5nKS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgdmFyIG1hdGNoID0gY2xlYW5lZC5tYXRjaCgvXigxfCk/KFxcZHszfSkoXFxkezN9KShcXGR7NH0pJC8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBpbnRsQ29kZSA9IChtYXRjaFsxXSA/ICcrMSAnIDogJycpO1xuICAgICAgICByZXR1cm4gW2ludGxDb2RlLCAnKCcsIG1hdGNoWzJdLCAnKSAnLCBtYXRjaFszXSwgJy0nLCBtYXRjaFs0XV0uam9pbignJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXJIZWxwZXIoJ2Fzc2lnbicsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgbGV0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuZGF0YS5yb290KSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YS5yb290ID0ge307XG4gICAgICB9XG5cbiAgICAgIGxldCB2ID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHYgPSB2ICsgYXJnc1tpXTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5kYXRhLnJvb3RbbmFtZV0gPSB2O1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckhlbHBlcignanNvbicsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5hbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICcnXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkobmFtZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlICovXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyJztcbmltcG9ydCBIYW5kbGViYXJzUmVuZGVyZXIgZnJvbSAnLi9oYW5kbGViYXJzcmVuZGVyZXInO1xuXG4vLyBJbiB0aGUgZnV0dXJlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgZGlmZmVyZW50IHR5cGVzIG9mIHJlbmRlcmVyc1xuLy8gRS5nLiBNdXN0YWNoZSwgU09ZLCBIYW5kbGVCYXJzLCBSZWFjdCwgZXRjLlxuZXhwb3J0IGNvbnN0IFJlbmRlcmVycyA9IHtcbiAgU09ZOiBSZW5kZXJlcixcbiAgSGFuZGxlYmFyczogSGFuZGxlYmFyc1JlbmRlcmVyXG59O1xuIiwiLyoqIEBtb2R1bGUgKi9cblxuLyoqIFRoZSBjdXJyZW50IGxpYiB2ZXJzaW9uLCByZXBvcnRlZCB3aXRoIGVycm9ycyBhbmQgYW5hbHl0aWNzICovXG5leHBvcnQgY29uc3QgTElCX1ZFUlNJT04gPSAndjAuMTEuMCc7XG5cbi8qKiBUaGUgYmFzZSB1cmwgZm9yIHRoZSBsaXZlIGFwaSBiYWNrZW5kICovXG5leHBvcnQgY29uc3QgTElWRV9BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9saXZlYXBpLnlleHQuY29tJztcblxuLyoqIFRoZSBiYXNlIHVybCBmb3IgdGhlIGtub3dsZWRnZSBhcGkgYmFja2VuZCAqL1xuZXhwb3J0IGNvbnN0IEFQSV9CQVNFX1VSTCA9ICdodHRwczovL2FwaS55ZXh0LmNvbSc7XG5cbi8qKiBUaGUgZGVmYXVsdCB1cmwgZm9yIGNvbXBpbGVkIGNvbXBvbmVudCB0ZW1wbGF0ZXMgKi9cbmV4cG9ydCBjb25zdCBDT01QSUxFRF9URU1QTEFURVNfVVJMID0gYGh0dHBzOi8vYXNzZXRzLnNpdGVzY2RuLm5ldC9hbnN3ZXJzLyR7TElCX1ZFUlNJT059L2Fuc3dlcnN0ZW1wbGF0ZXMuY29tcGlsZWQubWluLmpzYDtcblxuLyoqIFRoZSBiYXNlIHVybHMgZm9yIHRoZSBhbmFseXRpY3MgYmFja2VuZCAgKi9cbmV4cG9ydCBjb25zdCBBTkFMWVRJQ1NfQkFTRV9VUkwgPSAnaHR0cHM6Ly9yZWFsdGltZWFuYWx5dGljcy55ZXh0LmNvbSc7XG5leHBvcnQgY29uc3QgQU5BTFlUSUNTX0JBU0VfVVJMX05PX0NPT0tJRSA9ICdodHRwczovL2Fuc3dlcnMueWV4dC1waXhlbC5jb20nO1xuIiwiLyoqIEBtb2R1bGUgVGVtcGxhdGVMb2FkZXIgKi9cblxuaW1wb3J0IERPTSBmcm9tICcuLi9kb20vZG9tJztcbmltcG9ydCB7IENPTVBJTEVEX1RFTVBMQVRFU19VUkwgfSBmcm9tICcuLi8uLi9jb3JlL2NvbnN0YW50cyc7XG5cbi8qKlxuICogVGVtcGxhdGVMb2FkZXIgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIGxvYWRpbmcgdGVtcGxhdGVzIGFzeW5jaHJvbm91c2x5XG4gKiBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHJlZ2lzdGVycyB0aGVtIHdpdGggdGhlIHByb3BlciByZW5kZXJlci5cbiAqIEl0IGFsc28gYWxsb3dzIHlvdSB0byBhc3NpZ24gdGhlbSBzeW5jaHJvbm91c2x5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICBpZiAoIVRlbXBsYXRlTG9hZGVyLnNldEluc3RhbmNlKHRoaXMpKSB7XG4gICAgICByZXR1cm4gVGVtcGxhdGVMb2FkZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgdXJsIHRvIGZldGNoIGNvbXBpbGVkIHRlbXBsYXRlcyBmcm9tXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8IENPTVBJTEVEX1RFTVBMQVRFU19VUkw7XG5cbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB7fTtcbiAgICB0aGlzLl9vbkxvYWRlZCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRJbnN0YW5jZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG5cbiAgX2luaXQgKCkge1xuICAgIHRoaXMuZmV0Y2hUZW1wbGF0ZXMoKTtcbiAgfVxuXG4gIGZldGNoVGVtcGxhdGVzICgpIHtcbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGVtcGxhdGVzIGxvYWRlZCwgZG8gbm90aGluZ1xuICAgIGxldCBub2RlID0gRE9NLnF1ZXJ5KCcjeWV4dC1hbnN3ZXJzLXRlbXBsYXRlcycpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGEgc2NyaXB0IHRvIGZldGNoIHRoZSBjb21waWxlZCB0ZW1wbGF0ZXMsXG4gICAgLy8gd3JhcHBpbmcgaXQgYSBQcm9taXNlIGZvciBjbGVhbmxpbmVzc1xuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzY3JpcHQgPSBET00uY3JlYXRlRWwoJ3NjcmlwdCcsIHtcbiAgICAgICAgaWQ6ICd5ZXh0LWFuc3dlcnMtdGVtcGxhdGVzJyxcbiAgICAgICAgb25sb2FkOiByZXNvbHZlLFxuICAgICAgICBvbmVycm9yOiByZWplY3QsXG4gICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICBzcmM6IHRoaXMuX3RlbXBsYXRlVXJsXG4gICAgICB9KTtcblxuICAgICAgRE9NLmFwcGVuZCgnYm9keScsIHNjcmlwdCk7XG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETyhiaWxseSkgSW1wbG1lbmV0IGVycm9yIGhhbmRsaW5nIGhlcmUgKGUuZy4gcmVxdWVzdCBjb3VsZCBmYWlsKVxuICAgICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGVzIGxvYWRlZCBzdWNjZXNzZnVsbHkhJyk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiByZWdpc3RlciB0aGUgdGVtcGxhdGVzIGludGVybmFsbHkgc28gdGhhdCB0aGV5IGNhbiBiZSBsYXRlciBjb25zdW1lZFxuICAgKiAoZS5nLiBieSBjb21wb25lbnRzIGFuZCByZW5kZXJlcnMpIHdpdGggY29udmllbmllbmNlLlxuICAgKlxuICAgKiBgZmV0Y2hUZW1wbGF0ZXNgIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHRoaXMsIHByb3ZpZGluZyB0aGUgY29tcGlsZWQgdGVtcGxhdGVzIGZyb20gdGhlIHNlcnZlci5cbiAgICovXG4gIHJlZ2lzdGVyICh0ZW1wbGF0ZXMpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG5cbiAgICAvLyBOb3RpZnkgb3VyIGNvbnN1bWVycyB0aGF0IHRoZSB0ZW1wbGF0ZXMgYXJlIGhlcmUgOilcbiAgICB0aGlzLl9vbkxvYWRlZCh0aGlzLl90ZW1wbGF0ZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25Mb2FkZWQgKGNiKSB7XG4gICAgdGhpcy5fb25Mb2FkZWQgPSBjYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCAodGVtcGxhdGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gVGhlIGludGVybmFsIHRlbXBsYXRlIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldFRlbXBsYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlcztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBET00gfSBmcm9tICcuL2RvbS9kb20nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWFyY2hQYXJhbXMgfSBmcm9tICcuL2RvbS9zZWFyY2hwYXJhbXMnO1xuXG5leHBvcnQgeyBSZW5kZXJlcnMgfSBmcm9tICcuL3JlbmRlcmluZy9jb25zdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlbXBsYXRlTG9hZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvdGVtcGxhdGVsb2FkZXInO1xuIiwiLyoqIEBtb2R1bGUgRXZlbnRFbWl0dGVyICovXG5cbi8qKlxuICogRXZlbnRFbWl0dGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgYW55IG9iamVjdCB0aGF0IHdhbnRzIHRvIGV4cG9zZVxuICogYSBwdWIvc3ViIGludGVyZmFjZSwgZm9yIGVtaXR0aW5nIG1lc3NhZ2VzIGFuZCBwcm92aWRpbmcgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN1YnNjcmliZXJzIG9mIG1lc3NhZ2VzXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cblxuICAvKipcbiAgICogb24gaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIHN1YnNjcmliaW5nIGV2ZW50cyB0aGF0IGFyZSBlbWl0dGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0IHRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIHtldnR9IGlzIGVtaXR0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIE9wdGlvbmFsIHZhbHVlIHdoaWNoIHdpbGwgb25seSBoYW5kbGUgdGhlIG1lc3NhZ2Ugb25jZVxuICAgKi9cbiAgb24gKGV2dCwgY2IsIG9uY2UpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGhhbmRsZXIgc2hvdWxkIGJlIG9mIHR5cGUge2Z1bmN0aW9ufScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2dCxcbiAgICAgIGNiOiBjYixcbiAgICAgIG9uY2U6IG9uY2UgfHwgZmFsc2VcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uY2UgaXMgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZm9yIHN1YnNjcmliaW5nIGV2ZW50cyB0aGF0IGFyZSBlbWl0dGVkLlxuICAgKiBUaGUgaGFuZGxlciB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIG9uY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUge2V2dH0gaXMgZW1pdHRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgT3B0aW9uYWwgdmFsdWUgd2hpY2ggd2lsbCBvbmx5IGhhbmRsZSB0aGUgbWVzc2FnZSBvbmNlXG4gICAqL1xuICBvbmNlIChldnQsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZ0LCBjYiwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogb2ZmIGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dCB0aGUgZXZlbnQgbmFtZSB0byB1bnN1YnNjcmliZSBmcm9tXG4gICAqL1xuICBvZmYgKGV2dCkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBlbWl0IGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciBicm9hZGNhc3RpbmcgbWVzc2FnZXMvZXZlbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnQgdGhlIGV2ZW50IG5hbWUgdG8gcHVibGlzaCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHNlbmQgYWxvbmcgdG8gdGhlIHN1YnNjcmliZXJzXG4gICAqL1xuICBlbWl0IChldnQsIGRhdGEpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIGVhY2ggb2YgYWxsIHRoZSBsaXN0ZW5lciBoYW5kbGVycyBhbmQgcmVtb3ZlIHRoZSBvbmVzIHRoYXQgc2hvdWxkIGZpcmUgb25seSBvbmNlLlxuICAgIGxldCBrZWVwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5jYihkYXRhKTtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5zdGVhZCBvZiBoYXZpbmcgYSAnZGlydHknIGFycmF5IHdpdGggZGVsZXRlZCBvciAndW5kZWZpbmVkJyBlbnRyaWVzLFxuICAgICAgLy8gd2UganVzdCBjcmVhdGUgYSBicmFuZCBuZXcgYXJyYXkgd2l0aG91dCB0aGUgbGlzdGVuZXJzIHRoYXQgd2VyZSByZW1vdmVkXG4gICAgICBrZWVwLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgb3VyIG9sZCBsaXN0IG9mIGxpc3RlbmVycyB0byB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxuICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0ga2VlcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgU3RhdGUgKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi9jb3JlL2V2ZW50ZW1pdHRlci9ldmVudGVtaXR0ZXInO1xuXG4vKipcbiAqIFN0YXRlIGNvbnRhaW5zIHRoZSBkYXRhIGZvciB0aGUgY29tcG9uZW50XG4gKiBhbmQgZXhwb3NlcyBhbiB7RXZlbnRFbWl0dGVyfSBpbnRlcmZhY2Ugc28gdGhhdCBleHRlcm5hbFxuICogZGVwZW5kZW5jaWVzIGNhbiBsaXN0ZW4vaG9vayBzdWJzY3JpYmUgdG8gbWVzc2FnZXMvdXBkYXRlcy5cbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhdGUgPSBkYXRhIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBOT1RFKGJpbGx5KTogRG9lcyBub3QgZmlyZSBhbiB1cGRhdGUgbWVzc2FnZVxuICAgKi9cbiAgaW5pdCAocHJvcCwgb3B0VmFsKSB7XG4gICAgdGhpcy5fc2V0KHByb3AsIG9wdFZhbCk7XG4gIH1cblxuICAvKipcbiAgICogc2V0dGVyIGZvciB0aGUgc3RhdGVcbiAgICogQHBhcmFtIHByb3Age3N0cmluZ3xPYmplY3R9IFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIG9wdFZhbCBPcHRpb25hbCwgaWYgcHJvcCBpcyBhIHtzdHJpbmd9LCBpdCB3aWxsIGFzc2lnbiB0aGUgdmFsdWUgdG8gdGhhdCBwcm9wZXJ0eVxuICAgKi9cbiAgc2V0IChwcm9wLCBvcHRWYWwpIHtcbiAgICB0aGlzLl9zZXQocHJvcCwgb3B0VmFsKTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldHRlciBmb3IgdGhlIHN0YXRlIGVuYWJsZXMgeW91IHRvIHVwZGF0ZSBhIHNpbmdsZSBwcm9wZXJ0eSwgb3IgY29tcGxldGUgc3RhdGVcbiAgICogZGVwZW5kaW5nIG9uIHRoZSBhcmd1bWVudHMgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBwcm9wIHtzdHJpbmd8T2JqZWN0fSBUaGUgcHJvcGVydHkgdG8gc2V0XG4gICAqIEBwYXJhbSBvcHRWYWwgSWYgcHJvcCBpcyBhIHtzdHJpbmd9LCBwcm92aWRlIGl0cyB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldCAocHJvcCwgb3B0VmFsKSB7XG4gICAgaWYgKG9wdFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlW3Byb3BdID0gb3B0VmFsO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSAoZGF0YSkge1xuICAgIHRoaXMuX3N0YXRlID0gZGF0YTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgcHJvcGVydGllcyB2YWx1ZSBmcm9tIHRoZSBzdGF0ZVxuICAgKiBJZiBubyBwcm9wZXJ0eSBwcm92aWRlZCwgcmV0dXJuIHRoZSBmdWxsIHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRQcm9wIG9wdGlvbmFsIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqL1xuICBnZXQgKG9wdFByb3ApIHtcbiAgICBpZiAob3B0UHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZVtvcHRQcm9wXTtcbiAgfVxuXG4gIGhhcyAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXNKU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEh0dHBSZXF1ZXN0ZXIgKi9cblxuLyogZ2xvYmFsIGZldGNoICovXG5cbi8qKlxuICogVHlwZXMgb2YgSFRUUCByZXF1ZXN0c1xuICovXG5jb25zdCBNZXRob2RzID0ge1xuICBHRVQ6ICdnZXQnLFxuICBQT1NUOiAncG9zdCcsXG4gIFBVVDogJ3B1dCcsXG4gIERFTEVURTogJ2RlbGV0ZSdcbn07XG5cbi8qKlxuICogSHR0cFJlcXVlc3RlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQUpBWFxuICogcmVsYXRlZCBtYXR0ZXJzLiBJdCdzIHVzZWQgdG8gbWFrZSBhbGwgdHlwZXMgb2YgbmV0d29yayByZXF1ZXN0c1xuICogYW5kIGV4cG9zZXMgYSBwcm9taXNlIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHR0cFJlcXVlc3RlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBHRVQgSFRUUCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBwcm92aWRlIChnZXRzIGVuY29kZWQgaW50byB0aGUgVVJMKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgKi9cbiAgZ2V0ICh1cmwsIGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE1ldGhvZHMuR0VULCB0aGlzLmVuY29kZVBhcmFtcyh1cmwsIGRhdGEpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBQT1NUIEhUVFAgcmVxdWVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdG8gbWFrZSBhIHJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHVybFBhcmFtcyBUaGUgcGFyYW1zIHRvIGVuY29kZSBpbnRvIHRoZSBVUkxcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb25Cb2R5IFRoZSByZXF1ZXN0IGJvZHkgKGpzb24pIHRvIHByb3ZpZGUgd2l0aCB0aGUgUE9TVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0Q29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAqL1xuICBwb3N0ICh1cmwsIHVybFBhcmFtcywganNvbkJvZHksIHJlcXVlc3RDb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgTWV0aG9kcy5QT1NULFxuICAgICAgdGhpcy5lbmNvZGVQYXJhbXModXJsLCB1cmxQYXJhbXMpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uQm9keSksXG4gICAgICAgIGNyZWRlbnRpYWxzOiB1bmRlZmluZWRcbiAgICAgIH0sIHJlcXVlc3RDb25maWcpXG4gICAgKTtcbiAgfVxuXG4gIHJlcXVlc3QgKG1ldGhvZCwgdXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVxQXJncyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICdtZXRob2QnOiBtZXRob2QsXG4gICAgICAnY3JlZGVudGlhbHMnOiAnaW5jbHVkZSdcbiAgICB9LCBvcHRzKTtcblxuICAgIHJldHVybiBmZXRjaCh1cmwsIHJlcUFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBiZWFjb24gdG8gdGhlIHByb3ZpZGVkIHVybCB3aGljaCB3aWxsIHNlbmQgYSBub24tYmxvY2tpbmcgcmVxdWVzdFxuICAgKiB0byB0aGUgc2VydmVyIHRoYXQgaXMgZ3VhcmFudGVlZCB0byBzZW5kIGJlZm9yZSBwYWdlIGxvYWQuIE5vIHJlc3BvbnNlIGlzIHJldHVybmVkLFxuICAgKiBzbyBiZWFjb25zIGFyZSBwcmltYXJpbHkgdXNlZCBmb3IgYW5hbHl0aWNzIHJlcG9ydGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIHNlbmQgdGhlIGJlYWNvbiB0b1xuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgZGF0YSBwYXlsb2FkIHRvIHNlbmQgaW4gdGhlIGJlYWNvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWxseSBxdWV1ZWRcbiAgICovXG4gIGJlYWNvbiAodXJsLCBkYXRhKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICB9XG5cbiAgZW5jb2RlUGFyYW1zICh1cmwsIHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNQYXJhbSA9IHVybC5pbmRleE9mKCc/JykgPiAtMTtcblxuICAgIGxldCBzZWFyY2hRdWVyeSA9ICcnO1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmICghaGFzUGFyYW0pIHtcbiAgICAgICAgaGFzUGFyYW0gPSB0cnVlO1xuICAgICAgICBzZWFyY2hRdWVyeSArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2hRdWVyeSArPSAnJic7XG4gICAgICB9XG5cbiAgICAgIHNlYXJjaFF1ZXJ5ICs9IGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB1cmwgKyBzZWFyY2hRdWVyeTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgQXBpUmVxdWVzdCAqL1xuXG5pbXBvcnQgSHR0cFJlcXVlc3RlciBmcm9tICcuL2h0dHByZXF1ZXN0ZXInO1xuaW1wb3J0IHsgTElWRV9BUElfQkFTRV9VUkwsIExJQl9WRVJTSU9OIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vdWkvZG9tL3NlYXJjaHBhcmFtcyc7IC8vIFRPRE8gaWRlYWxseSB0aGlzIHdvdWxkIGJlIHBhc3NlZCBpbiBhcyBhIHBhcmFtXG5cbi8qKlxuICogQXBpUmVxdWVzdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEFQSSByZXF1ZXN0cy5cbiAqIEl0IGRlZmluZXMgYWxsIG9mIHRoZSBjb3JlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gbWFrZSBhIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBpUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBBbiBhYnN0cmFjdGlvbiB1c2VkIGZvciBtYWtpbmcgbmV0d29yayByZXF1ZXN0IGFuZCBoYW5kbGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7SHR0cFJlcXVlc3Rlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlcXVlc3RlciA9IG5ldyBIdHRwUmVxdWVzdGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZVVybCB0byB1c2UgZm9yIG1ha2luZyBhIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFzZVVybCA9IG9wdHMuYmFzZVVybCB8fCBMSVZFX0FQSV9CQVNFX1VSTDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmRwb2ludCB0byB1c2UgaW4gdGhlIHVybCAoYXBwZW5kZWQgdG8gdGhlIHtiYXNlVXJsfSlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW5kcG9pbnQgPSBvcHRzLmVuZHBvaW50IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IG9wdHMuYXBpS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgQVBJIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSBvcHRzLnZlcnNpb24gfHwgMjAxOTAxMDE7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGRhdGEgcGFyYW1zIHRoYXQgYXJlIHNlbnQgYWxvbmcgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBvcHRzLnBhcmFtcyB8fCB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgY3JlYXRlcyBhIG5ldyBgR0VUYCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHJlcXVlc3QgY2xhc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdGVyLmdldChcbiAgICAgIHRoaXMuX2Jhc2VVcmwgKyB0aGlzLl9lbmRwb2ludCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVBhcmFtcygpLCB0aGlzLnNhbml0aXplUGFyYW1zKHRoaXMuX3BhcmFtcykpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAqL1xuICBwb3N0IChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Rlci5wb3N0KFxuICAgICAgdGhpcy5fYmFzZVVybCArIHRoaXMuX2VuZHBvaW50LFxuICAgICAgdGhpcy5iYXNlUGFyYW1zKCkgLyogdXJsUGFyYW1zICovLFxuICAgICAgdGhpcy5zYW5pdGl6ZVBhcmFtcyh0aGlzLl9wYXJhbXMpIC8qIGpzb25Cb2R5ICovLFxuICAgICAgb3B0cyAvKiByZXF1ZXN0Q29uZmlnICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmFzZVBhcmFtcyAoKSB7XG4gICAgbGV0IGJhc2VQYXJhbXMgPSB7XG4gICAgICAndic6IHRoaXMuX3ZlcnNpb24sXG4gICAgICAnYXBpX2tleSc6IHRoaXMuX2FwaUtleSxcbiAgICAgICdqc0xpYlZlcnNpb24nOiBMSUJfVkVSU0lPTlxuICAgIH07XG5cbiAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICBpZiAodXJsUGFyYW1zLmhhcygnYmV0YScpKSB7XG4gICAgICBiYXNlUGFyYW1zWydiZXRhJ10gPSB1cmxQYXJhbXMuZ2V0KCdiZXRhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VQYXJhbXM7XG4gIH1cblxuICBzYW5pdGl6ZVBhcmFtcyAocGFyYW1zID0ge30pIHtcbiAgICAvLyBSZW1vdmUgYW55IHBhcmFtYXRlcnMgd2hvcyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAgICAvL1xuICAgIC8vIE5PVEUoYmlsbHkpIFByb2JhYmx5IGJldHRlciB0byBiZSBleHBsaWNpdCBhYm91dCBob3cgdG8gaGFuZGxlIHRoaXMgYXQgdGhlIHJlcXVlc3QgYnVpbGRpbmcgbGV2ZWwsXG4gICAgLy8gYnV0IEkgY2FuJ3Qgc2VlIGFueSBjYXNlcyB3aGVyZSB3ZSdkIGV2ZXIgd2FudCB0byBzZW5kICd1bmRlZmluZWQnIGFzIGEgdmFsdWUgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBTbyBpdCdzIHByb2JhYmx5IGZpbmUgdG8gJ2NsZWFuJyB0aGUgcGFyYW1zIG9iamVjdCBoZXJlXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAocGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZCB8fCBwYXJhbXNba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcGFyYW1zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hBcGkgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2VhcmNoc2VydmljZScpLmRlZmF1bHR9IFNlYXJjaFNlcnZpY2UgKi9cblxuaW1wb3J0IEFwaVJlcXVlc3QgZnJvbSAnLi4vaHR0cC9hcGlyZXF1ZXN0JztcbmltcG9ydCB7IEFuc3dlcnNCYXNpY0Vycm9yLCBBbnN3ZXJzQ29yZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5cbi8qKlxuICogU2VhcmNoQXBpIGlzIHRoZSBBUEkgZm9yIGRvaW5nIHZhcmlvdXMgdHlwZXMgb2Ygc2VhcmNoXG4gKiBvdmVyIHRoZSBuZXR3b3JrIChlLmcuIHZlcnRpY2FsIG9yIHVuaXZlcnNhbClcbiAqXG4gKiBAaW1wbGVtZW50cyB7U2VhcmNoU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQXBpIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIEFQSSBLZXkgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignQXBpIEtleSBpcyByZXF1aXJlZCcsICdTZWFyY2gnKTtcbiAgICB9XG4gICAgdGhpcy5fYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBBbnN3ZXJzIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmV4cGVyaWVuY2VLZXkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignQW5zd2VycyBLZXkgaXMgcmVxdWlyZWQnLCAnU2VhcmNoJyk7XG4gICAgfVxuICAgIHRoaXMuX2V4cGVyaWVuY2VLZXkgPSBjb25maWcuZXhwZXJpZW5jZUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbnN3ZXJzIGNvbmZpZyB2ZXJzaW9uIHRvIHVzZSBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uID0gY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIEFQSSB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gfHwgMjAxOTAxMDEgfHwgMjAxOTAzMDE7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgbG9jYWxlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcubG9jYWxlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0Jhc2ljRXJyb3IoJ0xvY2FsZSBpcyByZXF1aXJlZCcsICdTZWFyY2gnKTtcbiAgICB9XG4gICAgdGhpcy5fbG9jYWxlID0gY29uZmlnLmxvY2FsZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2ZXJ0aWNhbFNlYXJjaCAodmVydGljYWxLZXksIHsgaW5wdXQsIGZpbHRlciwgZmFjZXRGaWx0ZXIsIGxpbWl0LCBvZmZzZXQsIGlkLCBnZW9sb2NhdGlvbiwgaXNEeW5hbWljRmlsdGVyc0VuYWJsZWQsIHNraXBTcGVsbENoZWNrLCBxdWVyeVRyaWdnZXIsIHNlc3Npb25UcmFja2luZ0VuYWJsZWQgfSkge1xuICAgIGlmIChsaW1pdCA+IDUwKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvcmVFcnJvcignUHJvdmlkZWQgc2VhcmNoIGxpbWl0IHVuc3VwcG9ydGVkJywgJ1NlYXJjaEFwaScpO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3Qoe1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9xdWVyeScsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogaW5wdXQsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ2ZpbHRlcnMnOiBmaWx0ZXIsXG4gICAgICAgICdmYWNldEZpbHRlcnMnOiBmYWNldEZpbHRlcixcbiAgICAgICAgJ3ZlcnRpY2FsS2V5JzogdmVydGljYWxLZXksXG4gICAgICAgICdsaW1pdCc6IGxpbWl0LFxuICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0LFxuICAgICAgICAnbG9jYXRpb24nOiBnZW9sb2NhdGlvbiA/IGAke2dlb2xvY2F0aW9uLmxhdH0sJHtnZW9sb2NhdGlvbi5sbmd9YCA6IG51bGwsXG4gICAgICAgICdyYWRpdXMnOiBnZW9sb2NhdGlvbiA/IGdlb2xvY2F0aW9uLnJhZGl1cyA6IG51bGwsXG4gICAgICAgICdxdWVyeUlkJzogaWQsXG4gICAgICAgICdyZXRyaWV2ZUZhY2V0cyc6IGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkLFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2tpcFNwZWxsQ2hlY2snOiBza2lwU3BlbGxDaGVjayxcbiAgICAgICAgJ3F1ZXJ5VHJpZ2dlcic6IHF1ZXJ5VHJpZ2dlcixcbiAgICAgICAgJ3Nlc3Npb25UcmFja2luZ0VuYWJsZWQnOiBzZXNzaW9uVHJhY2tpbmdFbmFibGVkXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB1bml2ZXJzYWxTZWFyY2ggKHF1ZXJ5U3RyaW5nLCBwYXJhbXMpIHtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHtcbiAgICAgIGVuZHBvaW50OiAnL3YyL2FjY291bnRzL21lL2Fuc3dlcnMvcXVlcnknLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IHF1ZXJ5U3RyaW5nLFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICdsb2NhdGlvbic6IHBhcmFtcy5nZW9sb2NhdGlvbiA/IGAke3BhcmFtcy5nZW9sb2NhdGlvbi5sYXR9LCR7cGFyYW1zLmdlb2xvY2F0aW9uLmxuZ31gIDogbnVsbCxcbiAgICAgICAgJ3JhZGl1cyc6IHBhcmFtcy5nZW9sb2NhdGlvbiA/IHBhcmFtcy5nZW9sb2NhdGlvbi5yYWRpdXMgOiBudWxsLFxuICAgICAgICAndmVyc2lvbic6IHRoaXMuX2V4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2tpcFNwZWxsQ2hlY2snOiBwYXJhbXMuc2tpcFNwZWxsQ2hlY2ssXG4gICAgICAgICdxdWVyeVRyaWdnZXInOiBwYXJhbXMucXVlcnlUcmlnZ2VyLFxuICAgICAgICAnc2Vzc2lvblRyYWNraW5nRW5hYmxlZCc6IHBhcmFtcy5zZXNzaW9uVHJhY2tpbmdFbmFibGVkXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBNb2RlbCBmb3IgdGhlIGFuYWx5dGljcyBldmVudCB0eXBlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuYWx5dGljc0V2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGxhYmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVwb3J0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50VHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9wdGlvbmFsIGxhYmVsIHRvIGJlIHByb3ZpZGVkIGZvciB0aGUgZXZlbnRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBwcm92aWRlZCBvcHRpb25zIHRvIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBldmVudFxuICAgKi9cbiAgYWRkT3B0aW9ucyAob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBldmVudCBpbiB0aGUgYXBpIGZvcm1hdCwgdHlwaWNhbGx5IGZvciByZXBvcnRpbmcgdG8gdGhlIGFwaVxuICAgKi9cbiAgdG9BcGlFdmVudCAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBbmFseXRpY3NSZXBvcnRlciAqL1xuXG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi9hbmFseXRpY3NldmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCB7IEFOQUxZVElDU19CQVNFX1VSTCwgQU5BTFlUSUNTX0JBU0VfVVJMX05PX0NPT0tJRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgSHR0cFJlcXVlc3RlciBmcm9tICcuLi9odHRwL2h0dHByZXF1ZXN0ZXInO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvYW5hbHl0aWNzcmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gQW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcG9ydGluZyBhbmFseXRpY3MgZXZlbnRzIHRvIHRoZSBzZXJ2ZXIgdmlhIEhUVFBcbiAqXG4gKiBAaW1wbGVtZW50cyB7QW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmFseXRpY3NSZXBvcnRlciB7XG4gIGNvbnN0cnVjdG9yIChjb3JlLCBleHBlcmllbmNlS2V5LCBleHBlcmllbmNlVmVyc2lvbiwgYnVzaW5lc3NJZCwgZ2xvYmFsT3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIGJ1c2luZXNzIGlkZW50aWZpZXIgdXNlZCBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9idXNpbmVzc0lkID0gYnVzaW5lc3NJZDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IGFuYWx5dGljIGV2ZW50IHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGdsb2JhbE9wdGlvbnMsIHsgZXhwZXJpZW5jZUtleSB9KTtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgVVJMIGZvciB0aGUgYW5hbHl0aWNzIEFQSVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9iYXNlVXJsID0gQU5BTFlUSUNTX0JBU0VfVVJMX05PX0NPT0tJRTtcblxuICAgIGlmIChleHBlcmllbmNlVmVyc2lvbikge1xuICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5leHBlcmllbmNlVmVyc2lvbiA9IGV4cGVyaWVuY2VWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbiB0byBxdWVyeSBpZCB1cGRhdGVzXG4gICAgY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5RVUVSWV9JRCwgaWQgPT4gdGhpcy5zZXRRdWVyeUlkKGlkKSk7XG4gIH1cblxuICBzZXRRdWVyeUlkIChxdWVyeUlkKSB7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5xdWVyeUlkID0gcXVlcnlJZDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZXBvcnQgKGV2ZW50KSB7XG4gICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBBbmFseXRpY3NFdmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQW5hbHl0aWNzRXJyb3IoJ1RyaWVkIHRvIHNlbmQgaW52YWxpZCBhbmFseXRpY3MgZXZlbnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgZXZlbnQuYWRkT3B0aW9ucyh0aGlzLl9nbG9iYWxPcHRpb25zKTtcblxuICAgIHJldHVybiBuZXcgSHR0cFJlcXVlc3RlcigpLmJlYWNvbihcbiAgICAgIGAke3RoaXMuX2Jhc2VVcmx9L3JlYWx0aW1lYW5hbHl0aWNzL2RhdGEvYW5zd2Vycy8ke3RoaXMuX2J1c2luZXNzSWR9YCxcbiAgICAgIHtcbiAgICAgICAgJ2RhdGEnOiBldmVudC50b0FwaUV2ZW50KClcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQgKGlzRW5hYmxlZCkge1xuICAgIHRoaXMuX2Jhc2VVcmwgPSBpc0VuYWJsZWQgPyBBTkFMWVRJQ1NfQkFTRV9VUkwgOiBBTkFMWVRJQ1NfQkFTRV9VUkxfTk9fQ09PS0lFO1xuICB9XG59XG4iLCIvKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvYW5hbHl0aWNzcmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gQW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQGltcGxlbWVudHMge0FuYWx5dGljc1JlcG9ydGVyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9vcEFuYWx5dGljc1JlcG9ydGVyIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlcG9ydCAoZXZlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBzZXRDb252ZXJzaW9uVHJhY2tpbmdFbmFibGVkIChpc0VuYWJsZWQpIHt9XG59XG4iLCIvKiogQG1vZHVsZSBNb2R1bGVEYXRhICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vZXZlbnRlbWl0dGVyL2V2ZW50ZW1pdHRlcic7XG5cbi8qKlxuICogTW9kdWxlRGF0YSBpcyB1c2VkIGFzIGEgZ2VuZXJpYyBtb2RlbCBmb3IgU3RvcmFnZS5cbiAqIFR5cGljYWxseSBhbiBpbnN0YW5jZSBvZiBNb2R1bGVEYXRhIHBvd2VycyBhIHNpbmdsZSBjb21wb25lbnQuXG5cbiAqIEEgZGF0YSBtb2RlbCB0aGF0IGV4cG9zZXMgYW4gZXZlbnQgZW1pdHRlciBpbnRlcmZhY2UuXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kdWxlRGF0YSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChpZCwgZGF0YSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlcGxhY2VzIHRoZSBjdXJyZW50bHkgaGVsZCBkYXRhIHdpdGggdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtIHsqfSBkYXRhIHRoZSBkYXRhIHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgZGF0YVxuICAgKi9cbiAgc2V0IChkYXRhKSB7XG4gICAgdGhpcy5jYXB0dXJlUHJldmlvdXMoKTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShkYXRhKSB8fCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuX2RhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBzaGFsbG93IGVxdWFsaXR5XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9kYXRhW2tleV0gIT09IGRhdGFba2V5XSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl9kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmVQcmV2aW91cyAoKSB7XG4gICAgaWYgKHRoaXMuX2hpc3RvcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCArIDEgPiA1KSB7XG4gICAgICB0aGlzLl9oaXN0b3J5LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gSWYgZGF0YSBpcyBldmVyIHVuZGVmaW5lZCwgd2UgZGVmYXVsdCB0byBlbXB0eSBvYmplY3RcbiAgICB0aGlzLl9oaXN0b3J5LnB1c2goSlNPTi5zdHJpbmdpZnkodGhpcy5fZGF0YSB8fCB7fSkpO1xuICB9XG5cbiAgdW5kbyAoKSB7XG4gICAgbGV0IHByZXZpb3VzID0ge307XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByZXZpb3VzID0gSlNPTi5wYXJzZSh0aGlzLl9wcmV2aW91cy5wb3AoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YS5zZXQocHJldmlvdXMpO1xuICB9XG5cbiAgcmF3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgR2xvYmFsU3RvcmFnZSAqL1xuXG5pbXBvcnQgTW9kdWxlRGF0YSBmcm9tICcuL21vZHVsZWRhdGEnO1xuaW1wb3J0IHsgQW5zd2Vyc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4vc3RvcmFnZWtleXMnO1xuXG4vKipcbiAqIFN0b3JhZ2UgaXMgYSBjb250YWluZXIgYXJvdW5kIGFwcGxpY2F0aW9uIHN0YXRlLlxuICogSXQgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIENSVUQgb3BlcmF0aW9ucyBhcyB3ZWxsIGFzIGxpc3RlbmluZ1xuICogZm9yIHN0YXRlZnVsIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsb2JhbFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lciA9IHt9O1xuICAgIHRoaXMuX2Z1dHVyZUxpc3RlbmVycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGF0YSBpbiBzdG9yYWdlIHdpdGggdGhlIGdpdmVuIGtleSB0byB0aGUgcHJvdmlkZWQgZGF0YSxcbiAgICogY29tcGxldGVseSBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmcgZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgc3RvcmFnZSBrZXkgdG8gc2V0XG4gICAqIEBwYXJhbSB7Kn0gZGF0YSB0aGUgZGF0YSB0byBzZXRcbiAgICovXG4gIHNldCAoa2V5LCBkYXRhKSB7XG4gICAgdGhpcy5faW5pdERhdGFDb250YWluZXIoa2V5LCBkYXRhKTtcbiAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2tleV0uc2V0KGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbGwga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBwcm92aWRlZCBtYXAgdG8gdGhlIHN0b3JhZ2VcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBrZXkvdmFsdWUgcGFpcnMgdG8gc2V0IGluIHRoZSBzdG9yYWdlXG4gICAqL1xuICBzZXRBbGwgKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgIGlmIChrZXkgPT09IFN0b3JhZ2VLZXlzLlFVRVJZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXQoa2V5LCB2YWwpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBxdWVyeSBsYXN0IHNpbmNlIGl0IHRyaWdnZXJzIGEgc2VhcmNoXG4gICAgLy8gVE9ETzogbW92ZSBsaXN0ZW5lcnMgdXAgc28gYWxsIG9mIHN0b3JhZ2UgY2FuIGJlIHVwZGF0ZWQgYXQgdGhlIHNhbWUgdGltZVxuICAgIGlmIChkYXRhW1N0b3JhZ2VLZXlzLlFVRVJZXSkge1xuICAgICAgdGhpcy5zZXQoU3RvcmFnZUtleXMuUVVFUlksIGRhdGFbU3RvcmFnZUtleXMuUVVFUlldKTtcbiAgICB9XG4gIH1cblxuICBfaW5pdERhdGFDb250YWluZXIgKGtleSwgZGF0YSkge1xuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzU3RvcmFnZUVycm9yKCdJbnZhbGlkIHN0b3JhZ2Uga2V5IHByb3ZpZGVkJywga2V5LCBkYXRhKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignTm8gZGF0YSBwcm92aWRlZCcsIGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21vZHVsZURhdGFDb250YWluZXJba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2tleV0gPSBuZXcgTW9kdWxlRGF0YShrZXkpO1xuICAgICAgdGhpcy5fYXBwbHlGdXR1cmVMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gIH1cblxuICBnZXRTdGF0ZSAobW9kdWxlSWQpIHtcbiAgICBpZiAodGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXS5yYXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRBbGwgKGtleSkge1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRhdGFLZXkgb2YgT2JqZWN0LmtleXModGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcikpIHtcbiAgICAgIGlmIChkYXRhS2V5LnN0YXJ0c1dpdGgoa2V5KSAmJiB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2RhdGFLZXldLnJhdygpICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGEucHVzaCh0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW2RhdGFLZXldLnJhdygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBkYXRhIGluIHN0b3JhZ2Ugd2l0aCB0aGUgZ2l2ZW4ga2V5IHRvIHRoZSBwcm92aWRlZCBkYXRhLFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBzdG9yYWdlIGtleSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgLy8gTm90ZTogRG8gd2UgbmVlZCB0byBjbGVhbiB1cCBsaXN0ZW5lcnMgaGVyZT9cbiAgICBkZWxldGUgdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lcltrZXldO1xuICB9XG5cbiAgb24gKGV2dCwgbW9kdWxlSWQsIGNiKSB7XG4gICAgbGV0IG1vZHVsZURhdGEgPSB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXTtcbiAgICBpZiAobW9kdWxlRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZnV0dXJlTGlzdGVuZXJzW21vZHVsZUlkXS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2dCxcbiAgICAgICAgY2I6IGNiXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21vZHVsZURhdGFDb250YWluZXJbbW9kdWxlSWRdLm9uKGV2dCwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb2ZmIChldnQsIG1vZHVsZUlkLCBjYikge1xuICAgIGxldCBtb2R1bGVEYXRhID0gdGhpcy5fbW9kdWxlRGF0YUNvbnRhaW5lclttb2R1bGVJZF07XG4gICAgaWYgKG1vZHVsZURhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1dHVyZUxpc3RlbmVyc1ttb2R1bGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9tb2R1bGVEYXRhQ29udGFpbmVyW21vZHVsZUlkXS5vZmYoZXZ0LCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfYXBwbHlGdXR1cmVMaXN0ZW5lcnMgKG1vZHVsZUlkKSB7XG4gICAgbGV0IGZ1dHVyZXMgPSB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdO1xuICAgIGlmICghZnV0dXJlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnV0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGZ1dHVyZSA9IGZ1dHVyZXNbaV07XG4gICAgICB0aGlzLm9uKGZ1dHVyZS5ldmVudCwgbW9kdWxlSWQsIGZ1dHVyZS5jYik7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9mdXR1cmVMaXN0ZW5lcnNbbW9kdWxlSWRdO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlYXJjaEFwaSB9IGZyb20gJy4vc2VhcmNoL3NlYXJjaGFwaSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFuYWx5dGljc1JlcG9ydGVyIH0gZnJvbSAnLi9hbmFseXRpY3MvYW5hbHl0aWNzcmVwb3J0ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb29wQW5hbHl0aWNzUmVwb3J0ZXIgfSBmcm9tICcuL2FuYWx5dGljcy9ub29wYW5hbHl0aWNzcmVwb3J0ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNb2R1bGVEYXRhIH0gZnJvbSAnLi9zdG9yYWdlL21vZHVsZWRhdGEnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdG9yYWdlIH0gZnJvbSAnLi9zdG9yYWdlL2dsb2JhbHN0b3JhZ2UnO1xuIiwiLyoqIEBtb2R1bGUgQ29tcG9uZW50ICovXG5cbmltcG9ydCB7IFJlbmRlcmVycyB9IGZyb20gJy4uL3JlbmRlcmluZy9jb25zdCc7XG5cbmltcG9ydCBET00gZnJvbSAnLi4vZG9tL2RvbSc7XG5pbXBvcnQgU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XG5pbXBvcnQgeyBBbmFseXRpY3NSZXBvcnRlciB9IGZyb20gJy4uLy4uL2NvcmUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgQW5hbHl0aWNzRXZlbnQgZnJvbSAnLi4vLi4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcblxuLyoqXG4gKiBDb21wb25lbnQgaXMgYW4gYWJzdHJhY3Rpb24gdGhhdCBlbmNhcHN1bGF0ZXMgc3RhdGUsIGJlaGF2aW9yLFxuICogYW5kIHZpZXcgZm9yIGEgcGFydGljdWxhciBjaHVuayBvZiBmdW5jdGlvbmFsaXR5IG9uIHRoZSBwYWdlLlxuICpcbiAqIFRoZSBBUEkgZXhwb3NlcyBldmVudCBsaWZlIGN5Y2xlIGhvb2tzIGZvciB3aGVuIHRoaW5ncyBhcmUgcmVuZGVyZWQsXG4gKiBtb3VudGVkLCBjcmVhdGVkLCBldGMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLm1vZHVsZUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBuYW1lIG9mIHRoaXMgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICogVXNlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG90aGVyIGNvbXBvbmVudHMgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgdGhlIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gcHJvcG9nYXRlIHByb3Blcmx5IHRvIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcblxuICAgIC8qKlxuICAgICAqIEFuIGlkZW50aWZpZXIgdXNlZCB0byBjbGFzc2lmeSB0aGUgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICogVGhlIGNvbXBvbmVudCBtYW5hZ2VyIHVzZXMgdGhpcyBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBwZXJzaXN0IGFuZCBvcmdhbml6ZSBjb21wb25lbnRzXG4gICAgICogQHR5cGUge3N0cmluZ3xDb21wb25lbnRUeXBlfVxuICAgICAqL1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbXBvbmVudCwgaWYgZXhpc3RzXG4gICAgICogQHR5cGUge0NvbXBvbmVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9wYXJlbnRDb250YWluZXIgPSBjb25maWcucGFyZW50Q29udGFpbmVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbnRhaW5lciBmb3IgYWxsIHRoZSBjaGlsZCBjb21wb25lbnRzXG4gICAgICogQHR5cGUge0NvbXBvbmVudFtdfVxuICAgICAqL1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdGUgKGRhdGEpIG9mIHRoZSBjb21wb25lbnQgdG8gYmUgcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlIGZvciByZW5kZXJpbmdcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXRlID0gbmV3IFN0YXRlKGNvbmZpZy5zdGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUT0RPKGJpbGx5KSBUaGlzIHNob3VsZCBiZSAnc2VydmljZXMnXG4gICAgICovXG4gICAgdGhpcy5jb3JlID0gc3lzdGVtQ29uZmlnLmNvcmUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQgbWFuYWdlciwgd2hpY2ggY29udGFpbnMgYWxsIG9mIHRoZSBjb21wb25lbnQgY2xhc3Nlc1xuICAgICAqIGVsaWdpYmxlIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50TWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIgPSBzeXN0ZW1Db25maWcuY29tcG9uZW50TWFuYWdlciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGFuYWx5dGljcyByZXBvcnRlciwgdXNlZCB0byByZXBvcnQgZXZlbnRzIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqIEB0eXBlIHtBbmFseXRpY3NSZXBvcnRlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyID0gc3lzdGVtQ29uZmlnLmFuYWx5dGljc1JlcG9ydGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRvIGluY2x1ZGUgd2l0aCBhbGwgYW5hbHl0aWMgZXZlbnRzIHNlbnQgYnkgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzT3B0aW9ucyA9IGNvbmZpZy5hbmFseXRpY3NPcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIERPTSBub2RlIHRoYXQgdGhlIGNvbXBvbmVudCB3aWxsIGJlIGFwcGVuZGVkIHRvIHdoZW4gbW91bnRlZC9yZW5kZXJlZC5cbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgaWYgKHRoaXMuX3BhcmVudENvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBET00ucXVlcnkoY29uZmlnLmNvbnRhaW5lcikgfHwgbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgY29udGFpbmVyIERPTSBub2RlOiAnICsgY29uZmlnLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLnF1ZXJ5KHRoaXMuX3BhcmVudENvbnRhaW5lciwgY29uZmlnLmNvbnRhaW5lcik7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwYXJlbnQsIGFuZCB0aGUgY29udGFpbmVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgRE9NLFxuICAgICAgLy8gd2UgY29uc3RydWN0IHRoZSBjb250YWluZXIgYW5kIGFwcGVuZCBpdCB0byB0aGUgcGFyZW50XG4gICAgICBpZiAodGhpcy5fY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgIGNsYXNzOiBjb25maWcuY29udGFpbmVyLnN1YnN0cmluZygxLCBjb25maWcuY29udGFpbmVyLmxlbmd0aClcbiAgICAgICAgfSk7XG4gICAgICAgIERPTS5hcHBlbmQodGhpcy5fcGFyZW50Q29udGFpbmVyLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGNsYXNzIHRvIGJlIGFwcGxpZWQgdG8ge3RoaXMuX2NvbnRhaW5lcn0gbm9kZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzIHx8ICdjb21wb25lbnQnO1xuXG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB1c2luZyB0aGUgZGVmYXVsdCByZW5kZXJlclxuICAgICAqIEB0eXBlIHtSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXIgPSBjb25maWcucmVuZGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB7UmVuZGVyZXJ9IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIHRlbXBsYXRlXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3JlbmRlcmVyID0gc3lzdGVtQ29uZmlnLnJlbmRlcmVyIHx8IFJlbmRlcmVycy5IYW5kbGViYXJzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRlbXBsYXRlIHN0cmluZyB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50XG4gICAgICogSWYgdGhpcyBpcyBsZWZ0IGVtcHR5LCB3ZSBsb29rdXAgdGhlIHRlbXBsYXRlIHRoZSBiYXNlIHRlbXBsYXRlcyB1c2luZyB0aGUgdGVtcGxhdGVOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wbGF0ZSA9IGNvbmZpZy50ZW1wbGF0ZSA/IHRoaXMuX3JlbmRlcmVyLmNvbXBpbGUoY29uZmlnLnRlbXBsYXRlKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGVOYW1lIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogVGhpcyBpcyBvbmx5IHVzZWQgaWYgX3RlbXBsYXRlIGlzIGVtcHR5LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdGVtcGxhdGVOYW1lID0gY29uZmlnLnRlbXBsYXRlTmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRUZW1wbGF0ZU5hbWUoY29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHN0YXRlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET01cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjaywgdGhhdHMgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGludGVybmFsIGRhdGFcbiAgICAgKiBtb2RlbHMgb2YgdGhlIGNvbXBvbmVudHMsIGJlZm9yZSBpdCBnZXRzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudCBzdGF0ZS5cbiAgICAgKiBCeSBkZWZhdWx0LCBubyB0cmFuc2Zvcm1hdGlvbiBoYXBwZW5zLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybURhdGEgPSBjb25maWcudHJhbnNmb3JtRGF0YSB8fCB0aGlzLnRyYW5zZm9ybURhdGEgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbkNyZWF0ZSA9IGNvbmZpZy5vbkNyZWF0ZU92ZXJyaWRlIHx8IHRoaXMub25DcmVhdGUgfHwgZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5vbkNyZWF0ZSA9IHRoaXMub25DcmVhdGUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyBNb3VudGVkLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uTW91bnQgPSBjb25maWcub25Nb3VudE92ZXJyaWRlIHx8IHRoaXMub25Nb3VudCB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICB0aGlzLm9uTW91bnQgPSB0aGlzLm9uTW91bnQuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIGNvbXBvbmVudHMgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vblVwZGF0ZSA9IGNvbmZpZy5vblVwZGF0ZU92ZXJyaWRlIHx8IHRoaXMub25VcGRhdGUgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgIHRoaXMub25VcGRhdGUgPSB0aGlzLm9uVXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBBIHVzZXIgcHJvdmlkZWQgb25DcmVhdGUgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy51c2VyT25DcmVhdGUgPSBjb25maWcub25DcmVhdGUgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBBIHVzZXIgcHJvdmlkZWQgb25Nb3VudCBjYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJPbk1vdW50ID0gY29uZmlnLm9uTW91bnQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBBIHVzZXIgcHJvdmlkZWQgb25VcGRhdGUgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy51c2VyT25VcGRhdGUgPSBjb25maWcub25VcGRhdGUgfHwgZnVuY3Rpb24gKCkge307XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0NvbXBvbmVudCc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpbml0IChvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUob3B0cy5kYXRhIHx8IG9wdHMuc3RhdGUgfHwge30pO1xuICAgICAgdGhpcy5vbkNyZWF0ZSgpO1xuICAgICAgdGhpcy51c2VyT25DcmVhdGUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRXJyb3IgaW5pdGlhbGl6aW5nIGNvbXBvbmVudCcsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IudHlwZSxcbiAgICAgICAgZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICAgICAgdGhpcy51c2VyT25VcGRhdGUoKTtcbiAgICAgICAgdGhpcy51bk1vdW50KCk7XG4gICAgICAgIHRoaXMubW91bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNDb21wb25lbnRFcnJvcihcbiAgICAgICAgICAnRXJyb3IgdXBkYXRpbmcgY29tcG9uZW50JyxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnR5cGUsXG4gICAgICAgICAgZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBET00uYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCB0aGlzLl9jbGFzc05hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHsgX2NvbmZpZzogdGhpcy5fY29uZmlnIH0sIGRhdGEpO1xuICAgIHRoaXMuX3N0YXRlLnNldChuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRTdGF0ZSAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXQocHJvcCk7XG4gIH1cblxuICBoYXNTdGF0ZSAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5oYXMocHJvcCk7XG4gIH1cblxuICB0cmFuc2Zvcm1EYXRhIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBhZGRDaGlsZCAoZGF0YSwgdHlwZSwgb3B0cykge1xuICAgIGxldCBjaGlsZENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5jcmVhdGUoXG4gICAgICB0eXBlLFxuICAgICAgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0sIG9wdHMgfHwge30sIHtcbiAgICAgICAgX3BhcmVudE9wdHM6IHRoaXMuX2NvbmZpZ1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZENvbXBvbmVudCk7XG4gICAgcmV0dXJuIGNoaWxkQ29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFVubW91bnQgYW5kIHJlbW92ZSB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuIGZyb20gdGhlIGxpc3RcbiAgICogb2YgYWN0aXZlIGNvbXBvbmVudHNcbiAgICovXG4gIHJlbW92ZSAoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZW1vdmUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZW5kZXIgbWV0aG9kIHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbmRlclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzZXRSZW5kZXIgKHJlbmRlcikge1xuICAgIHRoaXMuX3JlbmRlciA9IHJlbmRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlbmRlcmVyIGZvciB0aGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7UmVuZGVyZXJUeXBlfSByZW5kZXJlclxuICAgKi9cbiAgc2V0UmVuZGVyZXIgKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBSZW5kZXJlcnNbcmVuZGVyZXJdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29tcG9uZW50IHRvIHVzZSB3aGVuIHJlbmRlcmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHNldFRlbXBsYXRlICh0ZW1wbGF0ZSkge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdGhpcy5fcmVuZGVyZXIuY29tcGlsZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICB1bk1vdW50ICgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC51bk1vdW50KCk7XG4gICAgfSk7XG5cbiAgICBET00uZW1wdHkodGhpcy5fY29udGFpbmVyKTtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGMgPT4gYy5yZW1vdmUoKSk7XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm9uVW5Nb3VudCgpO1xuICB9XG5cbiAgbW91bnQgKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmVmb3JlTW91bnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIERPTS5hcHBlbmQodGhpcy5fY29udGFpbmVyLCB0aGlzLnJlbmRlcih0aGlzLl9zdGF0ZS5hc0pTT04oKSkpO1xuXG4gICAgLy8gUHJvY2VzcyB0aGUgRE9NIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgY3JlYXRlXG4gICAgLy8gaW4tbWVtb3J5IHN1Yi1jb21wb25lbnRzIGZvciByZW5kZXJpbmdcbiAgICBjb25zdCBkb21Db21wb25lbnRzID0gRE9NLnF1ZXJ5QWxsKHRoaXMuX2NvbnRhaW5lciwgJ1tkYXRhLWNvbXBvbmVudF06bm90KFtkYXRhLWlzLWNvbXBvbmVudC1tb3VudGVkXSknKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy50cmFuc2Zvcm1EYXRhKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fc3RhdGUuZ2V0KCkpKSk7XG4gICAgZG9tQ29tcG9uZW50cy5mb3JFYWNoKGMgPT4gdGhpcy5fY3JlYXRlU3ViY29tcG9uZW50KGMsIGRhdGEpKTtcblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQubW91bnQoKTtcbiAgICB9KTtcblxuICAgIC8vIEF0dGFjaCBhbmFseXRpY3MgaG9va3MgYXMgbmVjZXNzYXJ5XG4gICAgaWYgKHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIpIHtcbiAgICAgIGxldCBkb21Ib29rcyA9IERPTS5xdWVyeUFsbCh0aGlzLl9jb250YWluZXIsICdbZGF0YS1ldmVudHR5cGVdOm5vdChbZGF0YS1pcy1hbmFseXRpY3MtYXR0YWNoZWRdKScpO1xuICAgICAgZG9tSG9va3MuZm9yRWFjaCh0aGlzLl9jcmVhdGVBbmFseXRpY3NIb29rLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5vbk1vdW50KHRoaXMpO1xuICAgIHRoaXMudXNlck9uTW91bnQodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiByZW5kZXIgdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSB7UmVuZGVyZXJ9IHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRlbXBsYXRlIG9mIHRoZSBjb21wb25lbnRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHJlbmRlciAoZGF0YSA9IHRoaXMuX3N0YXRlLmdldCgpKSB7XG4gICAgdGhpcy5iZWZvcmVSZW5kZXIoKTtcbiAgICAvLyBUZW1wb3JhcnkgZml4IGZvciBwYXNzaW5nIGltbXV0YWJsZSBkYXRhIHRvIHRyYW5zZm9ybURhdGEoKS5cbiAgICBkYXRhID0gdGhpcy50cmFuc2Zvcm1EYXRhKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpKTtcblxuICAgIGxldCBodG1sID0gJyc7XG4gICAgLy8gVXNlIGVpdGhlciB0aGUgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiBvciB0aGUgaW50ZXJuYWwgcmVuZGVyZXJcbiAgICAvLyBkZXBlbmRhbnQgb24gdGhlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGh0bWwgPSB0aGlzLl9yZW5kZXIoZGF0YSk7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyIG1ldGhvZCBtdXN0IHJldHVybiBIVE1MIGFzIHR5cGUge3N0cmluZ30nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVuZGVyIHRoZSBleGlzdGluZyB0ZW1wbGF0ZXMgYXMgYSBzdHJpbmdcbiAgICAgIGh0bWwgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXIoe1xuICAgICAgICB0ZW1wbGF0ZTogdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgIHRlbXBsYXRlTmFtZTogdGhpcy5fdGVtcGxhdGVOYW1lXG4gICAgICB9LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBXZSBjcmVhdGUgYW4gSFRNTCBEb2N1bWVudCBmcmFnbWVudCB3aXRoIHRoZSByZW5kZXJlZCBzdHJpbmdcbiAgICAvLyBTbyB0aGF0IHdlIGNhbiBxdWVyeSBpdCBmb3IgcHJvY2Vzc2luZyBvZiBzdWIgY29tcG9uZW50c1xuICAgIGxldCBlbCA9IERPTS5jcmVhdGUoaHRtbCk7XG5cbiAgICB0aGlzLmFmdGVyUmVuZGVyKCk7XG4gICAgcmV0dXJuIGVsLmlubmVySFRNTDtcbiAgfVxuXG4gIF9jcmVhdGVTdWJjb21wb25lbnQgKGRvbUNvbXBvbmVudCwgZGF0YSkge1xuICAgIGRvbUNvbXBvbmVudC5kYXRhc2V0LmlzQ29tcG9uZW50TW91bnRlZCA9IHRydWU7XG4gICAgY29uc3QgZGF0YXNldCA9IGRvbUNvbXBvbmVudC5kYXRhc2V0O1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LmNvbXBvbmVudDtcbiAgICBjb25zdCBwcm9wID0gZGF0YXNldC5wcm9wO1xuICAgIGxldCBvcHRzID0gZGF0YXNldC5vcHRzID8gSlNPTi5wYXJzZShkYXRhc2V0Lm9wdHMpIDoge307XG5cbiAgICBsZXQgY2hpbGREYXRhID0gZGF0YVtwcm9wXSB8fCB7fTtcblxuICAgIG9wdHMgPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgY29udGFpbmVyOiBkb21Db21wb25lbnRcbiAgICB9O1xuXG4gICAgLy8gVE9ETyhiaWxseSkgUmlnaHQgbm93LCBpZiB3ZSBwcm92aWRlIGFuIGFycmF5IGFzIHRoZSBkYXRhIHByb3AsXG4gICAgLy8gdGhlIGJlaGF2aW9yIGlzIHRvIGNyZWF0ZSBtYW55IGNvbXBvbmVudHMgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgLy8gVEhBVCBpbnRlcmZhY2UgU0hPVUxEIGNoYW5nZSB0byB1c2UgYSBkaWZmZXJlbnQgcHJvcGVydHkgdGhhdCBkZWZpbmVzXG4gICAgLy8gd2hldGhlciB0byBhcnJheSBkYXRhIHNob3VsZCBiZSB1c2VkIGZvciBhIHNpbmdsZSBjb21wb25lbnQgb3JcbiAgICAvLyB0byBjcmVhdGUgbWFueSBjb21wb25lbnRzIGZvciBlYWNoIGl0ZW0uXG4gICAgLy8gT3ZlcmxvYWRpbmcgYW5kIGhhdmluZyB0aGlzIHNpZGUgZWZmZWN0IGlzIHVuaW50dWl0aXZlIGFuZCBXUk9OR1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZERhdGEpKSB7XG4gICAgICAvLyBSZW5kZXJpbmcgYSBzdWIgY29tcG9uZW50IHNob3VsZCBiZSB3aXRoaW4gdGhlIGNvbnRleHQsXG4gICAgICAvLyBvZiB0aGUgbm9kZSB0aGF0IHdlIHByb2Nlc3NlZCBpdCBmcm9tXG4gICAgICB0aGlzLmFkZENoaWxkKGNoaWxkRGF0YSwgdHlwZSwgb3B0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2hpbGREYXRhLnJldmVyc2UoKTtcbiAgICBjaGlsZERhdGEuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgIHRoaXMuYWRkQ2hpbGQoZGF0YSwgdHlwZSwgb3B0cyk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQW5hbHl0aWNzSG9vayAoZG9tQ29tcG9uZW50KSB7XG4gICAgZG9tQ29tcG9uZW50LmRhdGFzZXQuaXNBbmFseXRpY3NBdHRhY2hlZCA9IHRydWU7XG4gICAgY29uc3QgZGF0YXNldCA9IGRvbUNvbXBvbmVudC5kYXRhc2V0O1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LmV2ZW50dHlwZTtcbiAgICBjb25zdCBsYWJlbCA9IGRhdGFzZXQuZXZlbnRsYWJlbDtcbiAgICBjb25zdCBvcHRpb25zID0gZGF0YXNldC5ldmVudG9wdGlvbnMgPyBKU09OLnBhcnNlKGRhdGFzZXQuZXZlbnRvcHRpb25zKSA6IHt9O1xuXG4gICAgRE9NLm9uKGRvbUNvbXBvbmVudCwgJ2NsaWNrJywgZSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBBbmFseXRpY3NFdmVudCh0eXBlLCBsYWJlbCk7XG4gICAgICBldmVudC5hZGRPcHRpb25zKHRoaXMuX2FuYWx5dGljc09wdGlvbnMpO1xuICAgICAgZXZlbnQuYWRkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbkNyZWF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbnN0cnVjdGVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBpbnZva2UgdXBvbiBlbWl0XG4gICAqL1xuICBvbkNyZWF0ZSAoY2IpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIG9uVXBkYXRlIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IGNoYW5nZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uVXBkYXRlIChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogYmVmb3JlUmVuZGVyIGV2ZW50IGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgYmVmb3JlUmVuZGVyIChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogYWZ0ZXJSZW5kZXIgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIGFmdGVyUmVuZGVyIChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogb25Nb3VudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFwcGVuZGVkIHRvIHRoZSBET01cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uTW91bnQgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvblVuTW91bnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgb25Vbk1vdW50IChjYikge1xuXG4gIH1cblxuICAvKipcbiAgICogYmVmb3JlTW91bnQgaXMgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgdG8gdGhlIERPTVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZW1pdFxuICAgKi9cbiAgYmVmb3JlTW91bnQgKGNiKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBvbkRlc3Ryb3kgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGludm9rZSB1cG9uIGVtaXRcbiAgICovXG4gIG9uRGVzdHJveSAoY2IpIHtcblxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBFcnJvclJlcG9ydGVyICovXG5cbmltcG9ydCB7IEFuc3dlcnNCYXNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBMSUJfVkVSU0lPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9lcnJvcnJlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEVycm9yUmVwb3J0ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogRXJyb3JSZXBvcnRlciBpcyB1c2VkIGZvciByZXBvcnRpbmcgZXJyb3JzIHRvIHRoZSBjb25zb2xlIGFuZCBBUElcbiAqXG4gKiBAaW1wbGVtZW50cyB7RXJyb3JSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yUmVwb3J0ZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGFwaUtleSB0byB1c2UgZm9yIHJlcG9ydGluZ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGVyaWVuY2VLZXkgdG8gdXNlIHdoZW4gcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmV4cGVyaWVuY2VLZXkgPSBjb25maWcuZXhwZXJpZW5jZUtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbnN3ZXJzIGNvbmZpZyB2ZXJzaW9uIHVzZWQgZm9yIGFwaSByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXhwZXJpZW5jZVZlcnNpb24gPSBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24gfHwgJ2NvbmZpZzEuMCc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBwcmludCBlbnRpcmUgZXJyb3Igb2JqZWN0cyB0byB0aGUgY29uc29sZSBmb3IgaW5zcGVjdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucHJpbnRWZXJib3NlID0gY29uZmlnLnByaW50VmVyYm9zZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJlcG9ydCB0aGUgZXJyb3IgdGhlIHNlcnZlciBmb3IgbG9nZ2luZyBhbmQgbW9uaXRvcmluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VuZFRvU2VydmVyID0gY29uZmlnLnNlbmRUb1NlcnZlcjtcblxuICAgIC8vIEF0dGFjaCByZXBvcnRpbmcgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGUgPT4gdGhpcy5yZXBvcnQoZS5lcnJvcikpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBlID0+IHRoaXMucmVwb3J0KGUuZXJyb3IpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXBvcnQgcHJldHR5IHByaW50cyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG9wdGlvbmFsbHlcbiAgICogcHJpbnRzIHRoZSBlbnRpcmUgZXJyb3IgaWYgYHByaW50VmVyYm9zZWAgaXMgdHJ1ZSwgYW5kIHNlbmRzIHRoZVxuICAgKiBlcnJvciB0byB0aGUgc2VydmVyIHRvIGJlIGxvZ2dlZCBpZiBgc2VuZFRvU2VydmVyYCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSByZXBvcnRlZFxuICAgKiBAcmV0dXJucyB7QW5zd2Vyc0Jhc2VFcnJvcn0gVGhlIHJlcG9ydGVkIGVycm9yXG4gICAqL1xuICByZXBvcnQgKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEFuc3dlcnNCYXNlRXJyb3IpIHx8IGVyci5yZXBvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVyci5yZXBvcnRlZCA9IHRydWU7XG5cbiAgICB0aGlzLnByaW50RXJyb3IoZXJyKTtcblxuICAgIGlmICh0aGlzLnNlbmRUb1NlcnZlcikge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBBcGlSZXF1ZXN0KHtcbiAgICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9lcnJvcnMnLFxuICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICB2ZXJzaW9uOiAyMDE5MDMwMSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgJ2Vycm9yJzogZXJyLnRvSnNvbigpLFxuICAgICAgICAgICdsaWJWZXJzaW9uJzogTElCX1ZFUlNJT04sXG4gICAgICAgICAgJ2V4cGVyaWVuY2VWZXJzaW9uJzogdGhpcy5leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuZXhwZXJpZW5jZUtleVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdC5nZXQoKVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnI7XG4gIH1cblxuICAvKipcbiAgICogcHJpbnRzIHRoZSBnaXZlbiBlcnJvciB0byB0aGUgYnJvd3NlciBjb25zb2xlXG4gICAqIEBwYXJhbSB7QW5zd2Vyc0Jhc2VFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBiZSBwcmludGVkXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVyci50b1N0cmluZygpKTtcbiAgICBpZiAodGhpcy5wcmludFZlcmJvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKHsgLi4uZXJyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL2Vycm9ycmVwb3J0ZXJzZXJ2aWNlJykuZGVmYXVsdH0gRXJyb3JSZXBvcnRlclNlcnZpY2UgKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RXJyb3JSZXBvcnRlclNlcnZpY2V9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnNvbGVFcnJvclJlcG9ydGVyIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlcG9ydCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgeyBBbnN3ZXJzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcblxuLyoqIEBtb2R1bGUgUGVyc2lzdGVudFN0b3JhZ2UgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc2lzdGVudFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwYXJhbXMgbW9kZWxcbiAgICAgKiBAdHlwZSB7U2VhcmNoUGFyYW1zfVxuICAgICAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgaGlzdG9yeSBlZGl0IHRpbWVyLCBpZiBhbnlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2hpc3RvcnlUaW1lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBsaXN0ZW5lcnMgdG8gZXZlcnkgc3RvcmFnZSB1cGRhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVMaXN0ZW5lciA9IGNvbmZpZy51cGRhdGVMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGxpc3RlbmVycyB0byBzdG9yYWdlIHJlc2V0c1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbltdfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc2V0TGlzdGVuZXIgPSBjb25maWcucmVzZXRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICB0aGlzLl9jYWxsTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgdGhpcy5fY2FsbExpc3RlbmVyKHRoaXMuX3Jlc2V0TGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBnaXZlbiBrZXkvdmFsdWUgcGFpciBpbnRvIHN0b3JhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGluc2VydCB0aGUgZGF0YSBpblxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSBoaXN0b3J5IGluc3RlYWQgb2YgcHVzaGluZyBuZXcgc3RhdGVcbiAgICovXG4gIHNldCAoa2V5LCBkYXRhLCByZXBsYWNlSGlzdG9yeSA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc1N0b3JhZ2VFcnJvcignU3RvcmFnZSBkYXRhIGtleSBtdXN0IGJlIGEgc3RyaW5nJywga2V5LCBkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3RGF0YSA9IGRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgbmV3RGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9wYXJhbXMuc2V0KGtleSwgbmV3RGF0YSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBnaXZlbiBrZXkgZnJvbSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBkZWxldGVcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIGhpc3RvcnkgaW5zdGVhZCBvZiBwdXNoaW5nIG5ldyBzdGF0ZVxuICAgKi9cbiAgZGVsZXRlIChrZXksIHJlcGxhY2VIaXN0b3J5ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fdXBkYXRlSGlzdG9yeShyZXBsYWNlSGlzdG9yeSk7XG4gIH1cblxuICBfdXBkYXRlSGlzdG9yeSAocmVwbGFjZUhpc3RvcnkgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9oaXN0b3J5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaXN0b3J5VGltZXIpO1xuICAgIH1cblxuICAgIC8vIGJhdGNoIHVwZGF0ZSBjYWxscyBhY3Jvc3MgY29tcG9uZW50cyB0byBhdm9pZCB1cGRhdGluZyB0aGUgdXJsIHRvbyBtdWNoXG4gICAgdGhpcy5faGlzdG9yeVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcGxhY2VIaXN0b3J5KSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIGA/JHt0aGlzLl9wYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgYD8ke3RoaXMuX3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGxpc3Qgb2YgY2FsbGJhY2tzIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBkYXRhXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gbGlzdGVuZXJzIFRoZSBjYWxsYmFja3MgdG8gaW52b2tlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsbExpc3RlbmVyIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKHRoaXMuZ2V0QWxsKCksIHRoaXMuX3BhcmFtcy50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBrZXkvdmFsdWUgcGFpcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgZ2V0QWxsICgpIHtcbiAgICBjb25zdCBhbGxQYXJhbXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5fcGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgYWxsUGFyYW1zW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBhbGxQYXJhbXM7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFuc3dlcnNDb25maWdFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9lcnJvcnMnO1xuXG4vKiogQG1vZHVsZSBTZWFyY2hDb25maWcgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1heCByZXN1bHRzIHBlciBzZWFyY2guXG4gICAgICogQWxzbyBkZWZpbmVzIHRoZSBudW1iZXIgb2YgcmVzdWx0cyBwZXIgcGFnZSwgaWYgcGFnaW5hdGlvbiBpcyBlbmFibGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbWl0ID0gY29uZmlnLmxpbWl0IHx8IDIwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGtleSB0byB1c2UgZm9yIGFsbCBzZWFyY2hlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHNlYXJjaCB0byB1c2Ugb24gaW5pdGlhbGl6YXRpb24gZm9yIHZlcnRpY2FsIHNlYXJjaGVycywgd2hlbiB0aGUgdXNlciBoYXMndCBwcm92aWRlZCBhIHF1ZXJ5XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRJbml0aWFsU2VhcmNoID0gY29uZmlnLmRlZmF1bHRJbml0aWFsU2VhcmNoO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpbWl0ICE9PSAnbnVtYmVyJyB8fCB0aGlzLmxpbWl0IDwgMSB8fCB0aGlzLmxpbWl0ID4gNTApIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29uZmlnRXJyb3IoJ1NlYXJjaCBMaW1pdCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNTAnLCAnU2VhcmNoQ29uZmlnJyk7XG4gICAgfVxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVEYXRhICovXG5cbmltcG9ydCBIaWdobGlnaHRlZFZhbHVlIGZyb20gJy4vaGlnaGxpZ2h0ZWR2YWx1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZURhdGEge1xuICBjb25zdHJ1Y3RvciAoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgdGhpcy5xdWVyeUlkID0gZGF0YS5xdWVyeUlkIHx8ICcnO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAocmVzcG9uc2UpIHtcbiAgICBsZXQgc2VjdGlvbnM7XG4gICAgaWYgKHJlc3BvbnNlLnNlY3Rpb25zKSB7XG4gICAgICBzZWN0aW9ucyA9IHJlc3BvbnNlLnNlY3Rpb25zLm1hcChzID0+ICh7XG4gICAgICAgIGxhYmVsOiBzLmxhYmVsLFxuICAgICAgICByZXN1bHRzOiBzLnJlc3VsdHMubWFwKHIgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdChyKSlcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VjdGlvbnMgPSBbeyByZXN1bHRzOiByZXNwb25zZS5yZXN1bHRzLm1hcChyID0+IG5ldyBBdXRvQ29tcGxldGVSZXN1bHQocikpIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEF1dG9Db21wbGV0ZURhdGEoeyBzZWN0aW9ucywgcXVlcnlJZDogcmVzcG9uc2UucXVlcnlJZCB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXV0b0NvbXBsZXRlUmVzdWx0IHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZmlsdGVyID0gZGF0YS5maWx0ZXIgfHwge307XG4gICAgdGhpcy5oaWdobGlnaHRlZFZhbHVlID0gbmV3IEhpZ2hsaWdodGVkVmFsdWUoZGF0YSkuZ2V0SW52ZXJ0ZWQoKTtcbiAgICB0aGlzLmtleSA9IGRhdGEua2V5IHx8ICcnO1xuICAgIHRoaXMubWF0Y2hlZFN1YnN0cmluZ3MgPSBkYXRhLm1hdGNoZWRTdWJzdHJpbmdzIHx8IFtdO1xuICAgIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlIHx8ICcnO1xuICAgIHRoaXMuc2hvcnRWYWx1ZSA9IGRhdGEuc2hvcnRWYWx1ZSB8fCB0aGlzLnZhbHVlO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lciAqL1xuXG5pbXBvcnQgQXV0b0NvbXBsZXRlRGF0YSBmcm9tICcuLi9tb2RlbHMvYXV0b2NvbXBsZXRlZGF0YSc7XG5cbi8qKlxuICogQSBEYXRhIFRyYW5zZm9ybWVyIHRoYXQgdGFrZXMgdGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIGEgQXV0b0NvbXBsZXRlIHJlcXVlc3RcbiAqIEFuZCB0cmFuc2Zvcm1zIGluIHRvIGEgZnJvbnQtZW5kIG9yaWVudGVkIGRhdGEgc3RydWN0dXJlIHRoYXQgb3VyXG4gKiBjb21wb25lbnQgbGlicmFyeSBhbmQgY29yZSBzdG9yYWdlIHVuZGVyc3RhbmQuXG4gKlxuICogVE9ETyhiaWxseSkgQ3JlYXRlIG91ciBvd24gZnJvbnQtZW5kIGRhdGEgbW9kZWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lciB7XG4gIHN0YXRpYyBjbGVhbiAobW9kdWxlSWQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zZWN0aW9ucyAmJiBkYXRhLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGRhdGEuc2VjdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc2VjdGlvbnMgJiYgZGF0YS5zZWN0aW9ucy5sZW5ndGggPT09IDEgJiYgZGF0YS5zZWN0aW9uc1swXS5yZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGRhdGEuc2VjdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFttb2R1bGVJZF06IGRhdGFcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHVuaXZlcnNhbCAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXV0b0NvbXBsZXRlRGF0YS5mcm9tKHJlc3BvbnNlKTtcbiAgfVxuXG4gIHN0YXRpYyBmaWx0ZXIgKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEF1dG9Db21wbGV0ZURhdGEuZnJvbShyZXNwb25zZSk7XG4gIH1cblxuICBzdGF0aWMgdmVydGljYWwgKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIEF1dG9Db21wbGV0ZURhdGEuZnJvbShyZXNwb25zZSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEF1dG9Db21wbGV0ZUFwaSAqL1xuXG5pbXBvcnQgQXBpUmVxdWVzdCBmcm9tICcuLi9odHRwL2FwaXJlcXVlc3QnO1xuaW1wb3J0IEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lciBmcm9tICcuL2F1dG9jb21wbGV0ZWRhdGF0cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBBbnN3ZXJzQmFzaWNFcnJvciwgQW5zd2Vyc0VuZHBvaW50RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZXJyb3JzJztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vYXV0b2NvbXBsZXRlc2VydmljZScpLmRlZmF1bHR9IEF1dG9Db21wbGV0ZVNlcnZpY2UgKi9cblxuLyoqXG4gKiBBdXRvQ29tcGxldGVBcGkgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIG5ldHdvcmsgcmVsYXRlZCBtYXR0ZXJzXG4gKiBmb3IgYWxsIHRoZSBhdXRvY29tcGxldGUgZW5kcG9pbnRzLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtBdXRvQ29tcGxldGVTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvQ29tcGxldGVBcGkge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBcGkgS2V5IGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIEFuc3dlcnMgS2V5IHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaWYgKCFjb25maWcuZXhwZXJpZW5jZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBbnN3ZXJzIEtleSBpcyByZXF1aXJlZCcsICdBdXRvQ29tcGxldGUnKTtcbiAgICB9XG4gICAgdGhpcy5fZXhwZXJpZW5jZUtleSA9IGNvbmZpZy5leHBlcmllbmNlS2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIEFQSSB0byBtYWtlIGEgcmVxdWVzdCB0b1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gfHwgMjAxOTAxMDEgfHwgMjAxOTAzMDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5zd2VycyBjb25maWcgdmVyc2lvbiB0byB1c2UgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9leHBlcmllbmNlVmVyc2lvbiA9IGNvbmZpZy5leHBlcmllbmNlVmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbGUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpZiAoIWNvbmZpZy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQmFzaWNFcnJvcignTG9jYWxlIGlzIHJlcXVpcmVkJywgJ0F1dG9Db21wbGV0ZScpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBjb25maWcubG9jYWxlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5RmlsdGVyIChpbnB1dCwgY29uZmlnKSB7XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdCh7XG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9hbnN3ZXJzL2ZpbHRlcnNlYXJjaCcsXG4gICAgICBhcGlLZXk6IHRoaXMuX2FwaUtleSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2lucHV0JzogaW5wdXQsXG4gICAgICAgICdleHBlcmllbmNlS2V5JzogdGhpcy5fZXhwZXJpZW5jZUtleSxcbiAgICAgICAgJ3ZlcnNpb24nOiB0aGlzLl9leHBlcmllbmNlVmVyc2lvbixcbiAgICAgICAgJ3ZlcnRpY2FsS2V5JzogY29uZmlnLnZlcnRpY2FsS2V5LFxuICAgICAgICAnaW5wdXRLZXknOiBjb25maWcuYmFyS2V5LFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlLFxuICAgICAgICAnc2VhcmNoX3BhcmFtZXRlcnMnOiBKU09OLnN0cmluZ2lmeShjb25maWcuc2VhcmNoUGFyYW1ldGVycylcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBBdXRvQ29tcGxldGVEYXRhVHJhbnNmb3JtZXIuZmlsdGVyKHJlc3BvbnNlLnJlc3BvbnNlLCBjb25maWcuYmFyS2V5KSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcignRmlsdGVyIHNlYXJjaCByZXF1ZXN0IGZhaWxlZCcsICdBdXRvQ29tcGxldGUnLCBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVZlcnRpY2FsIChpbnB1dCwgdmVydGljYWxLZXksIGJhcktleSkge1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3Qoe1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy92ZXJ0aWNhbC9hdXRvY29tcGxldGUnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IGlucHV0LFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICd2ZXJ0aWNhbEtleSc6IHZlcnRpY2FsS2V5LFxuICAgICAgICAnYmFyS2V5JzogYmFyS2V5LFxuICAgICAgICAnbG9jYWxlJzogdGhpcy5fbG9jYWxlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyLnZlcnRpY2FsKHJlc3BvbnNlLnJlc3BvbnNlLCByZXF1ZXN0Ll9wYXJhbXMuYmFyS2V5KSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcignVmVydGljYWwgc2VhcmNoIHJlcXVlc3QgZmFpbGVkJywgJ0F1dG9Db21wbGV0ZScsIGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5VW5pdmVyc2FsIChxdWVyeVN0cmluZykge1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEFwaVJlcXVlc3Qoe1xuICAgICAgZW5kcG9pbnQ6ICcvdjIvYWNjb3VudHMvbWUvYW5zd2Vycy9hdXRvY29tcGxldGUnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgICdpbnB1dCc6IHF1ZXJ5U3RyaW5nLFxuICAgICAgICAnZXhwZXJpZW5jZUtleSc6IHRoaXMuX2V4cGVyaWVuY2VLZXksXG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy5fZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICdsb2NhbGUnOiB0aGlzLl9sb2NhbGVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdldChxdWVyeVN0cmluZylcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IEF1dG9Db21wbGV0ZURhdGFUcmFuc2Zvcm1lci51bml2ZXJzYWwocmVzcG9uc2UucmVzcG9uc2UpKVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEFuc3dlcnNFbmRwb2ludEVycm9yKCdVbml2ZXJzYWwgc2VhcmNoIHJlcXVlc3QgZmFpbGVkJywgJ0F1dG9Db21wbGV0ZScsIGVycm9yKTtcbiAgICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgQXV0b0NvbXBsZXRlRGF0YSwgeyBBdXRvQ29tcGxldGVSZXN1bHQgfSBmcm9tICcuLi9tb2RlbHMvYXV0b2NvbXBsZXRlZGF0YSc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zZXJ2aWNlcy9hdXRvY29tcGxldGVzZXJ2aWNlJykuZGVmYXVsdH0gQXV0b0NvbXBsZXRlU2VydmljZSAqL1xuXG5jb25zdCB1bml2ZXJzYWxPcHRpb25zID0gW1xuICAnd2hhdCBpcyB5ZXh0JyxcbiAgJ3dobyBpcyB0aGUgY2VvIG9mIHlleHQnXG5dO1xuXG5jb25zdCB2ZXJ0aWNhbE9wdGlvbnMgPSBbXG4gICduZWFyIG1lJyxcbiAgJ2luIG5ldyB5b3JrJyxcbiAgJ2F2YWlsYWJsZSBub3cnXG5dO1xuXG4vKipcbiAqIE1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIHNlcnZlcyBhdXRvY29tcGxldGUgcXVlcmllcyB3aXRoIG1vY2sgZGF0YVxuICpcbiAqIEBpbXBsZW1lbnRzIHtBdXRvQ29tcGxldGVTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2NrQXV0b0NvbXBsZXRlU2VydmljZSB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeUZpbHRlciAoaW5wdXQsIGNvbmZpZykge1xuICAgIC8vIFRPRE8oYW11bGxpbmdzKTogU2ltdWxhdGUgZmlsdGVyIHNlYXJjaCwgd2l0aCBzZWN0aW9uc1xuICAgIHJldHVybiBlbXB0eVJlc3VsdHMoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBxdWVyeVZlcnRpY2FsIChpbnB1dCwgdmVydGljYWxLZXkpIHtcbiAgICByZXR1cm4gZmlsdGVyT3B0aW9ucyhpbnB1dCwgdmVydGljYWxPcHRpb25zXG4gICAgICAubWFwKG9wdCA9PiBgJHt2ZXJ0aWNhbEtleX0gJHtvcHR9YClcbiAgICAgIC5jb25jYXQodW5pdmVyc2FsT3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHF1ZXJ5VW5pdmVyc2FsIChpbnB1dCkge1xuICAgIHJldHVybiBmaWx0ZXJPcHRpb25zKGlucHV0LCB1bml2ZXJzYWxPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBRdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnMgSGFyZGNvZGVkIGF1dG9jb21wbGV0ZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRvQ29tcGxldGVEYXRhPn1cbiAqL1xuZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBlbXB0eVJlc3VsdHMoKTtcbiAgfVxuXG4gIGNvbnN0IGxvd2VyY2FzZSA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHJlc3VsdHMgPSBvcHRpb25zXG4gICAgLmZpbHRlcihvcHQgPT4gb3B0LmluY2x1ZGVzKGxvd2VyY2FzZSkpXG4gICAgLm1hcChvcHQgPT4gbmV3IEF1dG9Db21wbGV0ZVJlc3VsdCh7XG4gICAgICB2YWx1ZTogb3B0LFxuICAgICAgbWF0Y2hlZFN1YnN0cmluZ3M6IFt7XG4gICAgICAgIG9mZnNldDogb3B0LmluZGV4T2YobG93ZXJjYXNlKSxcbiAgICAgICAgbGVuZ3RoOiBsb3dlcmNhc2UubGVuZ3RoXG4gICAgICB9XVxuICAgIH0pKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXV0b0NvbXBsZXRlRGF0YSh7XG4gICAgc2VjdGlvbnM6IFt7IHJlc3VsdHMgfV0sXG4gICAgcXVlcnlJZDogcmFuZG9tU3RyaW5nKClcbiAgfSkpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPEF1dG9Db21wbGV0ZURhdGE+fVxuICovXG5mdW5jdGlvbiBlbXB0eVJlc3VsdHMgKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBdXRvQ29tcGxldGVEYXRhKHtcbiAgICBzZWN0aW9uczogW3t9XSxcbiAgICBxdWVyeUlkOiByYW5kb21TdHJpbmcoKVxuICB9KSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmFuZG9tU3RyaW5nICgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cbiIsIi8qKiBAbW9kdWxlIFF1ZXN0aW9uQW5zd2VyQXBpICovXG5cbmltcG9ydCBBcGlSZXF1ZXN0IGZyb20gJy4uL2h0dHAvYXBpcmVxdWVzdCc7XG5pbXBvcnQgeyBBUElfQkFTRV9VUkwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQW5zd2Vyc0Jhc2ljRXJyb3IsIEFuc3dlcnNFbmRwb2ludEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2Vycm9ycyc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKipcbiAqIFF1ZXN0aW9uQW5zd2VyQXBpIHN1Ym1pdHMgcXVlc3Rpb25zIHZpYSB0aGUgUSZBIFJFU1QgQVBJXG4gKlxuICogQGltcGxlbWVudHMge1F1ZXN0aW9uQW5zd2VyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVlc3Rpb25BbnN3ZXJBcGkge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEFuc3dlcnNCYXNpY0Vycm9yKCdBcGkgS2V5IGlzIHJlcXVpcmVkJywgJ1F1ZXN0aW9uQW5zd2VyQXBpJyk7XG4gICAgfVxuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc3VibWl0UXVlc3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQXBpUmVxdWVzdCh7XG4gICAgICBiYXNlVXJsOiBBUElfQkFTRV9VUkwsXG4gICAgICBlbmRwb2ludDogJy92Mi9hY2NvdW50cy9tZS9xdWVzdGlvbnMnLFxuICAgICAgYXBpS2V5OiB0aGlzLl9hcGlLZXksXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ2VudGl0eUlkJzogcXVlc3Rpb24uZW50aXR5SWQsXG4gICAgICAgICdzaXRlJzogcXVlc3Rpb24uc2l0ZSxcbiAgICAgICAgJ25hbWUnOiBxdWVzdGlvbi5uYW1lLFxuICAgICAgICAnZW1haWwnOiBxdWVzdGlvbi5lbWFpbCxcbiAgICAgICAgJ3F1ZXN0aW9uVGV4dCc6IHF1ZXN0aW9uLnF1ZXN0aW9uVGV4dCxcbiAgICAgICAgJ3F1ZXN0aW9uRGVzY3JpcHRpb24nOiBxdWVzdGlvbi5xdWVzdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgICAncXVlc3Rpb25MYW5ndWFnZSc6IHF1ZXN0aW9uLnF1ZXN0aW9uTGFuZ3VhZ2VcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXF1ZXN0LnBvc3Qoe1xuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9XG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBBbnN3ZXJzRW5kcG9pbnRFcnJvcihcbiAgICAgICAgICAnUXVlc3Rpb24gc3VibWl0IGZhaWxlZCcsXG4gICAgICAgICAgJ1F1ZXN0aW9uQW5zd2VyQXBpJyxcbiAgICAgICAgICBlcnJvcik7XG4gICAgICB9KTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTW9ja1F1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2VydmljZXMvcXVlc3Rpb25hbnN3ZXJzZXJ2aWNlJykuZGVmYXVsdH0gUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlICovXG5cbi8qKlxuICogQGltcGxlbWVudHMge1F1ZXN0aW9uQW5zd2VyU2VydmljZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9ja1F1ZXN0aW9uQW5zd2VyU2VydmljZSB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBzdWJtaXRRdWVzdGlvbiAocXVlc3Rpb24pIHtcbiAgICAvLyBUT0RPKGFtdWxsaW5ncyk6IE1ha2UgYWN0dWFsIHJlc3BvbnNlIG9iamVjdCBvbmNlIHdlJ3JlIHVzaW5nIGl0IGZvclxuICAgIC8vIHNvbWV0aGluZ1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICB9XG59XG4iLCIvKiBnbG9iYWwgZmV0Y2ggKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL21vZGVscy9zZWN0aW9uJykuZGVmYXVsdH0gU2VjdGlvbiAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3NlcnZpY2VzL3NlYXJjaHNlcnZpY2UnKS5kZWZhdWx0fSBTZWFyY2hTZXJ2aWNlICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVzdWx0RGF0YVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIH0gaHRtbFRpdGxlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgUmVzdWx0c01vZGlmaWVyXG4gKiBAcGFyYW0ge1Jlc3VsdERhdGFbXX0gcmVzdWx0c1xuICogQHJldHVybnMge1Jlc3VsdERhdGFbXX1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBNb2NrRGF0YUNvbnN1bWVyXG4gKiBAcGFyYW0ge1NlY3Rpb25bXX0gc2VjdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gKi9cblxuY29uc3QgQVJCSVRSQVJZX0JVU0lORVNTX0lEID0gOTE5ODcxO1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtTZWFyY2hTZXJ2aWNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2NrU2VhcmNoU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZ2V0TW9ja0RhdGFKc29uID0gZmV0Y2goJ2h0dHBzOi8vYXNzZXRzLnNpdGVzY2RuLm5ldC9hbnN3ZXJzL3Rlc3RkYXRhL3NlYXJjaC9tb2NrZGF0YV92MS5qc29uJylcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC50ZXh0KCkpXG4gICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmVydGljYWxTZWFyY2ggKHZlcnRpY2FsS2V5LCB7IGlucHV0LCBmaWx0ZXIsIGZhY2V0RmlsdGVyLCBsaW1pdCwgb2Zmc2V0LCBpZCwgZ2VvbG9jYXRpb24sIGlzRHluYW1pY0ZpbHRlcnNFbmFibGVkLCBza2lwU3BlbGxDaGVjaywgcXVlcnlUcmlnZ2VyIH0pIHtcbiAgICByZXR1cm4gdGhpcy51c2VNb2NrRGF0YShzZWN0aW9ucyA9PiB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkZWxheWVkUmVzcG9uc2UoY29uc3RydWN0VmVydGljYWxSZXNwb25zZSh7XG4gICAgICAgICAgcmVzdWx0czogW10sXG4gICAgICAgICAgYXBwbGllZFF1ZXJ5RmlsdGVyczogW11cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBFaXRoZXIgZmluZCBhIHNlY3Rpb24gd2l0aCBtYXRjaGluZyBJRCwgb3IgcGljayBvbmUgYXQgcmFuZG9tXG4gICAgICBsZXQgc2VjdGlvbiA9IHNlY3Rpb25zLmZpbmQoXG4gICAgICAgIHZlcnRpY2FsTW9kdWxlID0+IHZlcnRpY2FsS2V5ID09PSB2ZXJ0aWNhbE1vZHVsZVsndmVydGljYWxDb25maWdJZCddXG4gICAgICApO1xuICAgICAgaWYgKHNlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2VjdGlvbnMubGVuZ3RoKV07XG4gICAgICB9XG5cbiAgICAgIG1vZGlmeVJlc3VsdHMoc2VjdGlvbiwgZ2V0UmVzdWx0c0ZpbHRlcmVyKGlucHV0KSk7XG4gICAgICBpZiAob2Zmc2V0ICE9IG51bGwgJiYgbGltaXQgIT0gbnVsbCkge1xuICAgICAgICBtb2RpZnlSZXN1bHRzKHNlY3Rpb24sIGZ1bmN0aW9uIGxpbWl0IChyZXN1bHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwID0gY29uc3RydWN0VmVydGljYWxSZXNwb25zZShzZWN0aW9uKTtcbiAgICAgIHJldHVybiBkZWxheWVkUmVzcG9uc2UocmVzcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdW5pdmVyc2FsU2VhcmNoIChxdWVyeVN0cmluZywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTW9ja0RhdGEoc2VjdGlvbnMgPT4ge1xuICAgICAgaWYgKHF1ZXJ5U3RyaW5nID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVsYXllZFJlc3BvbnNlKGNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlKFtdKSk7XG4gICAgICB9XG5cbiAgICAgIHNlY3Rpb25zLmZvckVhY2goc2VjdGlvbiA9PiB7XG4gICAgICAgIG1vZGlmeVJlc3VsdHMoc2VjdGlvbiwgZ2V0UmVzdWx0c0ZpbHRlcmVyKHF1ZXJ5U3RyaW5nKSk7XG4gICAgICB9KTtcblxuICAgICAgc2VjdGlvbnMgPSBzZWN0aW9ucy5maWx0ZXIoc2VjdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLnJlc3VsdHMubGVuZ3RoID4gMDtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwID0gY29uc3RydWN0VW5pdmVyc2FsUmVzcG9uc2Uoc2VjdGlvbnMpO1xuICAgICAgcmV0dXJuIGRlbGF5ZWRSZXNwb25zZShyZXNwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vY2tEYXRhQ29uc3VtZXJ9IGNvbnN1bWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1c2VNb2NrRGF0YSAoY29uc3VtZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TW9ja0RhdGFKc29uLnRoZW4oSlNPTi5wYXJzZSkudGhlbihjb25zdW1lcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlTdHJpbmdcbiAqIEByZXR1cm4ge1Jlc3VsdHNNb2RpZmllcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzdWx0c0ZpbHRlcmVyIChxdWVyeVN0cmluZykge1xuICByZXR1cm4gcmVzdWx0cyA9PiByZXN1bHRzLmZpbHRlcihyZXN1bHQgPT4ge1xuICAgIGlmIChyZXN1bHQuaHRtbFRpdGxlICYmIHJlc3VsdC5odG1sVGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeVN0cmluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcmVzdWx0LmRhdGEpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHJlc3VsdC5kYXRhW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5U3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlY3Rpb259IHNlY3Rpb25cbiAqIEBwYXJhbSB7UmVzdWx0c01vZGlmaWVyfSBtb2RpZnlGblxuICovXG5mdW5jdGlvbiBtb2RpZnlSZXN1bHRzIChzZWN0aW9uLCBtb2RpZnlGbikge1xuICBzZWN0aW9uLnJlc3VsdHMgPSBtb2RpZnlGbihzZWN0aW9uLnJlc3VsdHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VjdGlvbltdfSBzZWN0aW9ucyBBIGxpc3Qgb2YgbW9jayBzZWN0aW9uIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgbW9jayBBbnN3ZXJzQXBpIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlIChzZWN0aW9ucykge1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IHNwZWxsY2hlY2ssIGdlbywgZmlsdGVyc1xuICAvLyBUT0RPKGFtdWxsaW5ncyk6IEZha2UgZW5jb2RlZFN0YXRlIG9uY2UgdGhlIFNESyB1c2VzIGl0XG4gIHNlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZpbGxTZWN0aW9uRmllbGRzKTtcbiAgcmV0dXJuIHtcbiAgICBtZXRhOiB7XG4gICAgICB1dWlkOiB1dWlkVjQoKSxcbiAgICAgIGVycm9yczogW11cbiAgICB9LFxuICAgIHJlc3BvbnNlOiB7XG4gICAgICBidXNpbmVzc0lkOiBBUkJJVFJBUllfQlVTSU5FU1NfSUQsXG4gICAgICBtb2R1bGVzOiBzZWN0aW9ucyxcbiAgICAgIGZhaWxlZFZlcnRpY2FsczogW10sXG4gICAgICBxdWVyeUlkOiB1dWlkVjQoKSxcbiAgICAgIHNlYXJjaEludGVudHM6IFtdXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VjdGlvbn0gc2VjdGlvbiBBIG1vY2sgc2VjdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1vY2sgQW5zd2Vyc0FwaSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RWZXJ0aWNhbFJlc3BvbnNlIChzZWN0aW9uKSB7XG4gIC8vIFRPRE8oYW11bGxpbmdzKTogc3BlbGxjaGVjaywgZ2VvLCBmaWx0ZXJzXG4gIC8vIFRPRE8oYW11bGxpbmdzKTogRmFrZSBlbmNvZGVkU3RhdGUgb25jZSB0aGUgU0RLIHVzZXMgaXRcbiAgc2VjdGlvbiA9IGZpbGxTZWN0aW9uRmllbGRzKHNlY3Rpb24pO1xuICByZXR1cm4ge1xuICAgIG1ldGE6IHtcbiAgICAgIHV1aWQ6IHV1aWRWNCgpLFxuICAgICAgZXJyb3JzOiBbXVxuICAgIH0sXG4gICAgcmVzcG9uc2U6IE9iamVjdC5hc3NpZ24oc2VjdGlvbiwge1xuICAgICAgYnVzaW5lc3NJZDogQVJCSVRSQVJZX0JVU0lORVNTX0lELFxuICAgICAgcXVlcnlJZDogdXVpZFY0KCksXG4gICAgICBzZWFyY2hJbnRlbnRzOiBbXVxuICAgIH0pXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWN0aW9ufVxuICogQHJldHVybnMge1NlY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGZpbGxTZWN0aW9uRmllbGRzIChzZWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGljYWxDb25maWdJZDogc2VjdGlvbi52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgIHJlc3VsdHNDb3VudDogc2VjdGlvbi5yZXN1bHRzLmxlbmd0aCxcbiAgICBlbmNvZGVkU3RhdGU6ICcnLFxuICAgIHJlc3VsdHM6IHNlY3Rpb24ucmVzdWx0cyxcbiAgICBhcHBsaWVkUXVlcnlGaWx0ZXJzOiBzZWN0aW9uLmFwcGxpZWRRdWVyeUZpbHRlcnMsXG4gICAgcXVlcnlEdXJhdGlvbk1pbGxpczogcmFuZG9tSW50KDUwLCAxMDAwKSxcbiAgICBmYWNldHM6IHNlY3Rpb24uZmFjZXRzLFxuICAgIHNvdXJjZTogc2VjdGlvbi5zb3VyY2VcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZnVuY3Rpb24gZGVsYXllZFJlc3BvbnNlIChyZXNwKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc29sdmUocmVzcCk7XG4gICAgfSwgcmFuZG9tSW50KDI1MCwgMTAwMCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb2RlLWdvbGYteSBidXQgbGVnaXQgYmFzaWMgVVVJRCB2NCBpbXBsZW1lbnRhdGlvbi4gTm90IGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZS5cbiAqIEZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICogQHJldHVybnMge3N0cmluZ30gQSB2NC1jb21wbGlhbnQgVVVJRFxuICovXG5mdW5jdGlvbiB1dWlkVjQgKCkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGIgKGEpIHsgcmV0dXJuIGEgPyAoYSBeIE1hdGgucmFuZG9tKCkgKiAxNiA+PiBhIC8gNCkudG9TdHJpbmcoMTYpIDogKFsxZTddICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIGIpOyB9KSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gaW5jbHVzaXZlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IGV4Y2x1c2l2ZVxuICogQHJldHVybnMge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludCAobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluKTtcbn1cbiIsIi8qKiBAbW9kdWxlIE5hdmlnYXRpb25Db21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogVGhlIGRlYm91bmNlIGR1cmF0aW9uIGZvciByZXNpemUgZXZlbnRzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBSRVNJWkVfREVCT1VOQ0UgPSAxMDA7XG5cbi8qKlxuICogVGhlIGJyZWFrcG9pbnQgZm9yIG1vYmlsZVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTU9CSUxFX0JSRUFLUE9JTlQgPSA3Njc7XG5cbi8qKlxuICogRW51bSBvcHRpb25zIGZvciBtb2JpbGUgb3ZlcmZsb3cgYmVhaHZpb3JcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTiA9IHtcbiAgQ09MTEFQU0U6ICdDT0xMQVBTRScsXG4gIElOTkVSU0NST0xMOiAnSU5ORVJTQ1JPTEwnXG59O1xuXG4vKipcbiAqIFRoZSBUYWIgaXMgYSBtb2RlbCB0aGF0IGlzIHVzZWQgdG8gcG93ZXIgdGhlIE5hdmlnYXRpb24gdGFicyBpbiB0aGUgdmlldy5cbiAqIEl0J3MgaW5pdGlhbGl6ZWQgdGhyb3VnaCB0aGUgY29uZmlndXJhdGlvbiBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgY2xhc3MgVGFiIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0YWIgdGhhdCBpcyBleHBvc2VkIGZvciB0aGUgbGlua1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbDtcbiAgICBpZiAodHlwZW9mIHRoaXMubGFiZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKCdsYWJlbCBpcyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciB0YWIuJywgJ05hdmlnYXRpb25Db21wb25lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcGxldGUgVVJMLCBpbmNsdWRpbmcgdGhlIHBhcmFtc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy51cmwgPSBjb25maWcudXJsO1xuICAgIGlmICh0eXBlb2YgdGhpcy51cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKCd1cmwgaXMgYSByZXF1aXJlZCBjb25maWd1cmF0aW9uIG9wdGlvbiBmb3IgdGFiLicsICdOYXZpZ2F0aW9uQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlcnNpZGUgdmVydGljYWwgY29uZmlnIGlkIHRoYXQgdGhpcyBpcyByZWZlcmVuY2VkIHRvLlxuICAgICAqIEJ5IHByb3ZpZGluZyB0aGlzLCBlbmFibGVzIGR5bmFtaWMgc29ydGluZyBiYXNlZCBvbiByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb25maWdJZCA9IGNvbmZpZy5jb25maWdJZCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgVVJMIHVzZWQgZm9yIGNvbnN0cnVjdGluZyB0aGUgVVJMIHdpdGggcGFyYW1zXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VVcmwgPSBjb25maWcudXJsO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhpcyB0YWIgZmlyc3QgaW4gdGhlIG9yZGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0ZpcnN0ID0gY29uZmlnLmlzRmlyc3QgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGFwcGx5IGEgc3BlY2lhbCBjbGFzcyB0byB0aGVcbiAgICAgKiBtYXJrdXAgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWN0aXZlIHRhYlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNBY3RpdmUgPSBjb25maWcuaXNBY3RpdmUgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogZnJvbSB3aWxsIGNvbnN0cnVjdCBhIG1hcCBvZiBjb25maWdJZCB0byB7VGFifSBmcm9tXG4gICAqIGEgY29uZmlndXJhdGlvbiBmaWxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YWJzQ29uZmlnIHRoZSBjb25maWd1cmF0aW9uIHRvIHVzZVxuICAgKi9cbiAgc3RhdGljIGZyb20gKHRhYnNDb25maWcpIHtcbiAgICBsZXQgdGFicyA9IHt9O1xuICAgIC8vIFBhcnNlIHRoZSBvcHRpb25zIGFuZCBidWlsZCBvdXQgb3VyIHRhYnMgYW5kXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzQ29uZmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGFiID0gdGFic0NvbmZpZ1tpXTtcbiAgICAgIC8vIEZvciB0YWJzIHdpdGhvdXQgY29uZmlnIGlkcywgbWFwIHRoZWlyIFVSTCB0byB0aGUgY29uZmlnSURcbiAgICAgIC8vIHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIHJlbmRlcnNcbiAgICAgIGlmICh0YWIuY29uZmlnSWQgPT09IG51bGwgJiYgdGFic1t0YWIuY29uZmlnSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFiLmNvbmZpZ0lkID0gdGFiLnVybDtcbiAgICAgIH1cblxuICAgICAgdGFic1t0YWIuY29uZmlnSWRdID0gbmV3IFRhYih0YWIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFicztcbiAgfVxufVxuXG4vKipcbiAqIE5hdmlnYXRpb25Db21wb25lbnQgZXhwb3NlcyBhbiBpbnRlcmZhY2UgZm9yIGJ1aWxkaW5nIGEgZHluYW1pY1xuICogbmF2aWdhdGlvbiB0aGF0IGlzIHBvd2VyZWQgYnkgdW5pdmVyc2FsIHNlYXJjaCB1cGRhdGVzLlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgb24gdGhlIGRyb3Bkb3duIG1lbnUgYnV0dG9uIHdoZW4gb3ZlcmZsb3dcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dMYWJlbCA9IGNvbmZpZy5vdmVyZmxvd0xhYmVsIHx8ICdNb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBpY29uIHRvIHNob3cgb24gdGhlIGRyb3Bkb3duIG1lbnUgYnV0dG9uIHdoZW4gb3ZlcmZsb3dcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dJY29uID0gY29uZmlnLm92ZXJmbG93SWNvbiB8fCAna2Fib2InO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZSBrZXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5OQVZJR0FUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGFicyBjb25maWcgZnJvbSBnbG9iYWwgbmF2aWdhdGlvbiBjb25maWdcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90YWJzQ29uZmlnID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuTkFWSUdBVElPTl9DT05GSUcpLnRhYnNDb25maWc7XG5cbiAgICAvKipcbiAgICAgKiBVbm9yZGVyZWQgbWFwIG9mIGVhY2ggdGFiLCBrZXllZCBieSBWUyBjb25maWdJZFxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgT2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RhYnMgPSBUYWIuZnJvbSh0aGlzLl90YWJzQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciBvZiB0aGUgdGFicywgcGFyc2VkIGZyb20gY29uZmlndXJhdGlvbiBvciBVUkwuXG4gICAgICogVGhpcyBnZXRzIHVwZGF0ZWQgYmFzZWQgb24gdGhlIHNlcnZlciByZXN1bHRzXG4gICAgICogQHR5cGUge0FycmF5LjxTdHJpbmc+fSBUaGUgbGlzdCBvZiBWUyBjb25maWdJZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RhYk9yZGVyID0gdGhpcy5nZXREZWZhdWx0VGFiT3JkZXIodGhpcy5fdGFic0NvbmZpZywgdGhpcy5nZXRVcmxQYXJhbXMoKSk7XG5cbiAgICAvKipcbiAgICAgKiBCcmVha3BvaW50cyBhdCB3aGljaCBuYXZpZ2F0aW9uIGl0ZW1zIG1vdmUgdG8gdGhlIFwibW9yZVwiIGRyb3Bkb3duXG4gICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmF2QnJlYWtwb2ludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqICBUaGUgbW9iaWxlIG92ZXJmbG93IGJlaGF2aW9yIGNvbmZpZ1xuICAgICAqICBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX21vYmlsZU92ZXJmbG93QmVoYXZpb3IgPSBjb25maWcubW9iaWxlT3ZlcmZsb3dCZWhhdmlvciB8fCBNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OLkNPTExBUFNFO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBBUklBIGxhYmVsXG4gICAgICogIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fYXJpYUxhYmVsID0gY29uZmlnLmFyaWFMYWJlbCB8fCAnU2VhcmNoIFBhZ2UgTmF2aWdhdGlvbic7XG5cbiAgICB0aGlzLmNoZWNrT3V0c2lkZUNsaWNrID0gdGhpcy5jaGVja091dHNpZGVDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yID0gdGhpcy5jaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdOYXZpZ2F0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiAnbmF2aWdhdGlvbi9uYXZpZ2F0aW9uJztcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICAvLyBUT0RPOiBSZS1yZW5kZXJpbmcgYW5kIHJlLW1vdW50aW5nIHRoZSBjb21wb25lbnQgZXZlcnkgdGltIGUgdGhlIHdpbmRvdyBjaGFuZ2VzIHNpemVcbiAgICAvLyBpcyBub3QgZ3JlYXQuXG4gICAgRE9NLm9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yKTtcbiAgfVxuXG4gIG9uRGVzdHJveSAoKSB7XG4gICAgRE9NLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLmNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvcik7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRDb2xsYXBzZSgpKSB7XG4gICAgICB0aGlzLl9uYXZCcmVha3BvaW50cyA9IFtdO1xuICAgICAgdGhpcy5iaW5kT3ZlcmZsb3dIYW5kbGVycygpO1xuICAgICAgdGhpcy5yZWZpdE5hdigpO1xuICAgICAgRE9NLm9uKERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyksICdjbGljaycsIHRoaXMudG9nZ2xlTW9yZURyb3Bkb3duLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIG9uVW5Nb3VudCAoKSB7XG4gICAgdGhpcy51bmJpbmRPdmVyZmxvd0hhbmRsZXJzKCk7XG4gIH1cblxuICBiaW5kT3ZlcmZsb3dIYW5kbGVycyAoKSB7XG4gICAgRE9NLm9uKHdpbmRvdywgJ2NsaWNrJywgdGhpcy5jaGVja091dHNpZGVDbGljayk7XG4gIH1cblxuICB1bmJpbmRPdmVyZmxvd0hhbmRsZXJzICgpIHtcbiAgICBET00ub2ZmKHdpbmRvdywgJ2NsaWNrJywgdGhpcy5jaGVja091dHNpZGVDbGljayk7XG4gIH1cblxuICByZWZpdE5hdiAoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LWNvbnRhaW5lcicpO1xuICAgIGNvbnN0IG1vcmVCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9yZScpO1xuICAgIGNvbnN0IG1haW5MaW5rcyA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1leHBhbmRlZCcpO1xuICAgIGNvbnN0IGNvbGxhcHNlZExpbmtzID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vZGFsJyk7XG5cbiAgICBjb25zdCBuYXZXaWR0aCA9IG1vcmVCdXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCd5eHQtTmF2LWl0ZW0tLW1vcmUnKVxuICAgICAgPyBjb250YWluZXIub2Zmc2V0V2lkdGhcbiAgICAgIDogY29udGFpbmVyLm9mZnNldFdpZHRoIC0gbW9yZUJ1dHRvbi5vZmZzZXRXaWR0aDtcbiAgICBsZXQgbnVtQnJlYWtwb2ludHMgPSB0aGlzLl9uYXZCcmVha3BvaW50cy5sZW5ndGg7XG5cbiAgICAvLyBzdW0gY2hpbGQgd2lkdGhzIGluc3RlYWQgb2YgdXNpbmcgcGFyZW50J3Mgd2lkdGggdG8gYXZvaWRcbiAgICAvLyBicm93c2VyIGluY29uc2lzdGVuY2llc1xuICAgIGxldCBtYWluTGlua3NXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgZWwgb2YgbWFpbkxpbmtzLmNoaWxkcmVuKSB7XG4gICAgICBtYWluTGlua3NXaWR0aCArPSBlbC5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAobWFpbkxpbmtzV2lkdGggPiBuYXZXaWR0aCkge1xuICAgICAgdGhpcy5fbmF2QnJlYWtwb2ludHMucHVzaChtYWluTGlua3NXaWR0aCk7XG4gICAgICBjb25zdCBsYXN0TGluayA9IG1haW5MaW5rcy5jaGlsZHJlbi5pdGVtKG1haW5MaW5rcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChsYXN0TGluayA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb2xsYXBzZWRMaW5rcy5wcmVwZW5kKGxhc3RMaW5rKTtcblxuICAgICAgaWYgKG1vcmVCdXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCd5eHQtTmF2LWl0ZW0tLW1vcmUnKSkge1xuICAgICAgICBtb3JlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3l4dC1OYXYtaXRlbS0tbW9yZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobnVtQnJlYWtwb2ludHMgJiYgbmF2V2lkdGggPiB0aGlzLl9uYXZCcmVha3BvaW50c1tudW1CcmVha3BvaW50cyAtIDFdKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TGluayA9IGNvbGxhcHNlZExpbmtzLmNoaWxkcmVuLml0ZW0oMCk7XG4gICAgICAgIGlmIChmaXJzdExpbmsgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFpbkxpbmtzLmFwcGVuZChmaXJzdExpbmspO1xuICAgICAgICB0aGlzLl9uYXZCcmVha3BvaW50cy5wb3AoKTtcbiAgICAgICAgbnVtQnJlYWtwb2ludHMtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbGxhcHNlZExpbmtzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBtb3JlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1OYXYtaXRlbS0tbW9yZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2xvc2VNb3JlRHJvcGRvd24oKTtcbiAgICBpZiAobWFpbkxpbmtzV2lkdGggPiBuYXZXaWR0aCB8fFxuICAgICAgKG51bUJyZWFrcG9pbnRzID4gMCAmJiBuYXZXaWR0aCA+IHRoaXMuX25hdkJyZWFrcG9pbnRzW251bUJyZWFrcG9pbnRzIC0gMV0pKSB7XG4gICAgICB0aGlzLnJlZml0TmF2KCk7XG4gICAgfVxuICB9XG5cbiAgY2xvc2VNb3JlRHJvcGRvd24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuICAgIGNvbGxhcHNlZC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBtb3JlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIG9wZW5Nb3JlRHJvcGRvd24gKCkge1xuICAgIGNvbnN0IGNvbGxhcHNlZCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb2RhbCcpO1xuICAgIGNvbGxhcHNlZC5jbGFzc0xpc3QuYWRkKCdpcy1hY3RpdmUnKTtcbiAgICBjb25zdCBtb3JlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LW1vcmUnKTtcbiAgICBtb3JlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICB9XG5cbiAgdG9nZ2xlTW9yZURyb3Bkb3duICgpIHtcbiAgICBjb25zdCBjb2xsYXBzZWQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1OYXYtbW9kYWwnKTtcbiAgICBjb2xsYXBzZWQuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XG4gICAgY29uc3QgbW9yZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LU5hdi1tb3JlJyk7XG4gICAgbW9yZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBjb2xsYXBzZWQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1hY3RpdmUnKSk7XG4gIH1cblxuICBjaGVja091dHNpZGVDbGljayAoZSkge1xuICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KCcueXh0LU5hdi1jb250YWluZXInKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2VNb3JlRHJvcGRvd24oKTtcbiAgfVxuXG4gIGNoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvciAoKSB7XG4gICAgaWYgKHRoaXMuX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2hlY2tNb2JpbGVPdmVyZmxvd0JlaGF2aW9yVGltZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyID0gc2V0VGltZW91dCh0aGlzLnNldFN0YXRlLmJpbmQodGhpcyksIFJFU0laRV9ERUJPVU5DRSk7XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgdGhlIHNlcnZlciBkYXRhIG9ubHkgcHJvdmlkZXMgYSBsaXN0IG9mXG4gICAqIFZTIGNvbmZpZ0lkcywgd2UgbmVlZCB0byBjb21wdXRlIGFuZCB0cmFuc2Zvcm1cbiAgICogdGhlIGRhdGEgaW50byB0aGUgcHJvcGVyIGZvcm1hdCBmb3IgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldFN0YXRlIChkYXRhID0ge30pIHtcbiAgICBpZiAoZGF0YS50YWJPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl90YWJPcmRlciA9IHRoaXMubWVyZ2VUYWJPcmRlcihkYXRhLnRhYk9yZGVyLCB0aGlzLl90YWJPcmRlcik7XG4gICAgfVxuXG4gICAgLy8gU2luY2UgdGhlIHRhYiBvcmRlcmluZyBjYW4gY2hhbmdlIGJhc2VkIG9uIHRoZSBzZXJ2ZXIgZGF0YVxuICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIGVhY2ggdGFicyBVUkwgdG8gaW5jbHVkZSB0aGUgb3JkZXIgYXMgcGFydCBvZiB0aGVpciBwYXJhbXMuXG4gICAgLy8gVGhpcyBoZWxwcyB3aXRoIHBlcnNpc3Rpbmcgc3RhdGUgYWNyb3NzIHZlcnRpY2Fscy5cbiAgICBsZXQgdGFicyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFiT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0YWIgPSB0aGlzLl90YWJzW3RoaXMuX3RhYk9yZGVyW2ldXTtcbiAgICAgIGlmICh0YWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YWIudXJsID0gdGhpcy5nZW5lcmF0ZVRhYlVybCh0YWIuYmFzZVVybCwgdGhpcy5nZXRVcmxQYXJhbXMoKSk7XG4gICAgICAgIHRhYnMucHVzaCh0YWIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZSh7XG4gICAgICB0YWJzOiB0YWJzLFxuICAgICAgb3ZlcmZsb3dMYWJlbDogdGhpcy5vdmVyZmxvd0xhYmVsLFxuICAgICAgb3ZlcmZsb3dJY29uOiB0aGlzLm92ZXJmbG93SWNvbixcbiAgICAgIHNob3dDb2xsYXBzZTogdGhpcy5zaG91bGRDb2xsYXBzZSgpLFxuICAgICAgYXJpYUxhYmVsOiB0aGlzLl9hcmlhTGFiZWxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFVybFBhcmFtcyAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICB9XG5cbiAgc2hvdWxkQ29sbGFwc2UgKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbW9iaWxlT3ZlcmZsb3dCZWhhdmlvcikge1xuICAgICAgY2FzZSBNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OLkNPTExBUFNFOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgTU9CSUxFX09WRVJGTE9XX0JFSEFWSU9SX09QVElPTi5JTk5FUlNDUk9MTDpcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy55eHQtTmF2LWNvbnRhaW5lcicpIHx8IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbmF2V2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIHJldHVybiBuYXZXaWR0aCA+IE1PQklMRV9CUkVBS1BPSU5UO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXREZWZhdWx0VGFiT3JkZXIgd2lsbCBjb21wdXRlIHRoZSBpbml0aWFsIHRhYiBvcmRlcmluZyBiYXNlZFxuICAgKiBvbiBhIGNvbWJpbmF0aW9uIG9mIHRoZSBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGRpcmVjdGx5IHRvIHRoZSBjb21wb25lbnRcbiAgICogYW5kIHRoZSB1cmwgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSB0YWJzQ29uZmlnXG4gICAqIEBwYXJhbSB7U2VhcmNoUGFyYW1zfVxuICAgKi9cbiAgZ2V0RGVmYXVsdFRhYk9yZGVyICh0YWJzQ29uZmlnLCB1cmxQYXJhbXMpIHtcbiAgICBsZXQgdGFiT3JkZXIgPSBbXTtcblxuICAgIC8vIFVzZSB0aGUgb3JkZXJpbmcgZnJvbSB0aGUgVVJMIGFzIHRoZSBwcmltYXJ5IGNvbmZpZ3VyYXRpb25cbiAgICAvLyBBbmQgdGhlbiBtZXJnZSBpdCB3aXRoIHRoZSBsb2NhbCBjb25maWd1cmF0aW9uLCBpZiBwcm92aWRlZC5cbiAgICBpZiAodXJsUGFyYW1zICYmIHVybFBhcmFtcy5oYXMoJ3RhYk9yZGVyJykpIHtcbiAgICAgIHRhYk9yZGVyID0gdXJsUGFyYW1zLmdldCgndGFiT3JkZXInKS5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFic0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFiID0gdGFic0NvbmZpZ1tpXTtcbiAgICAgIC8vIFNvbWUgdGFicyBkb24ndCBoYXZlIGNvbmZpZ0lkLCBzbyB3ZSBtYXAgaXQgZnJvbSBVUkxcbiAgICAgIGlmICh0YWIuY29uZmlnSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YWIuY29uZmlnSWQgPSB0YWIudXJsO1xuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCBkdXBsaWNhdGVzIGlmIGNvbmZpZyB3YXMgcHJvdmlkZWQgZnJvbSBVUkxcbiAgICAgIGlmICh0YWJPcmRlci5pbmNsdWRlcyh0YWIuY29uZmlnSWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpc0ZpcnN0IHNob3VsZCBhbHdheXMgYmUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAgICAgIGlmICh0YWIuaXNGaXJzdCkge1xuICAgICAgICB0YWJPcmRlci51bnNoaWZ0KHRhYi5jb25maWdJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJPcmRlci5wdXNoKHRhYi5jb25maWdJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYk9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIG1lcmdlVGFiT3JkZXIgbWVyZ2VzIHR3byBhcnJheXMgaW50byBvbmVcbiAgICogYnkgYXBwZW5kaW5nIGFkZGl0aW9uYWwgdGFicyB0byB0aGUgZW5kIG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0YWJPcmRlciBUYWIgb3JkZXIgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvdGhlclRhYk9yZGVyIFRhYiBvcmRlciBwcm92aWRlZCBieSBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgKi9cbiAgbWVyZ2VUYWJPcmRlciAodGFiT3JkZXIsIG90aGVyVGFiT3JkZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyVGFiT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhYkNvbmZpZyA9IG90aGVyVGFiT3JkZXJbaV07XG4gICAgICBpZiAodGFiT3JkZXIuaW5jbHVkZXModGFiQ29uZmlnKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXNGaXJzdCBzaG91bGQgYmUgYW4gb3ZlcnJpZGUgdG8gZHluYW1pYyB0YWIgb3JkZXJpbmcuXG4gICAgICBpZiAodGhpcy5fdGFic1t0YWJDb25maWddICYmIHRoaXMuX3RhYnNbdGFiQ29uZmlnXS5pc0ZpcnN0KSB7XG4gICAgICAgIHRhYk9yZGVyLnVuc2hpZnQodGFiQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYk9yZGVyLnB1c2godGFiQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFiT3JkZXI7XG4gIH1cblxuICBnZW5lcmF0ZVRhYlVybCAoYmFzZVVybCwgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpKSB7XG4gICAgLy8gV2Ugd2FudCB0byBwZXJzaXN0IHRoZSBwYXJhbXMgZnJvbSB0aGUgZXhpc3RpbmcgVVJMIHRvIHRoZSBuZXdcbiAgICAvLyBVUkxTIHdlIGNyZWF0ZS5cbiAgICBwYXJhbXMuc2V0KCd0YWJPcmRlcicsIHRoaXMuX3RhYk9yZGVyKTtcbiAgICByZXR1cm4gYmFzZVVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTZWFyY2hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcblxuLyoqXG4gKiBTZWFyY2hDb21wb25lbnQgZXhwb3NlcyBhbiBpbnRlcmZhY2UgaW4gb3JkZXIgdG8gY3JlYXRlXG4gKiBhIFVJIFNlYXJjaCBleHBlcmllbmNlIGZvciB2ZXJ0aWNhbCBhbmQgdW5pdmVyc2FsIHNlYXJjaC5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBpbnB1dCBrZXkgZm9yIHRoZSB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgYXV0by1jb21wbGV0ZSBhbmQgc2VhcmNoIHdpbGwgYmUgYmFzZWQgb24gdW5pdmVyc2FsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9iYXJLZXkgPSBjb25maWcuYmFyS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgYXV0by1jb21wbGV0ZSBhbmQgc2VhcmNoIHdpbGwgYmUgYmFzZWQgb24gdW5pdmVyc2FsXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IGNvbmZpZy52ZXJ0aWNhbEtleSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUXVlcnkgc3VibWlzc2lvbiBpcyBiYXNlZCBvbiBhIGZvcm0gYXMgY29udGV4dC5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gbmF0aXZlIGZvcm0gbm9kZSB3aXRoaW4gY29udGFpbmVyXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1TZWxlY3RvciB8fCAnZm9ybSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgZWxlbWVudCB1c2VkIGZvciBzZWFyY2hpbmcgYW5kIHdpcmVzIHVwIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvblxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5faW5wdXRFbCA9IGNvbmZpZy5pbnB1dEVsIHx8ICcuanMteWV4dC1xdWVyeSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdXNlZCwgcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlIGFzIGEgZGF0YSBwb2ludFxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRpdGxlID0gY29uZmlnLnRpdGxlIHx8ICdBbnN3ZXJzIFVuaXZlcnNhbCBTZWFyY2gnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRleHQgaXMgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGlucHV0IGJveCwgYWxzbyBwcm92aWRlZCB0byB0ZW1wbGF0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsVGV4dCA9IGNvbmZpZy5sYWJlbFRleHQgfHwgJ1doYXQgYXJlIHlvdSBpbnRlcmVzdGVkIGluPyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VibWl0IHRleHQgaXMgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIHN1Ym1pdCBidXR0b24sIGFsc28gcHJvdmlkZWQgdG8gdGhlIHRlbXBsYXRlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdWJtaXRUZXh0ID0gY29uZmlnLnN1Ym1pdFRleHQgfHwgJ1N1Ym1pdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3VibWl0IGljb24gaXMgYW4gaWNvbiBmb3IgdGhlIHN1Ym1pdCBidXR0b24sIGlmIHByb3ZpZGVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFuZCB0aGVcbiAgICAgKiBzdWJtaXQgdGV4dCB3aWxsIGJlIHVzZWQgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN1Ym1pdEljb24gPSBjb25maWcuc3VibWl0SWNvbiB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHRleHQgdG8gc2hvdyBhcyB0aGUgZmlyc3QgaXRlbSBmb3IgYXV0byBjb21wbGV0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb21wdEhlYWRlciA9IGNvbmZpZy5wcm9tcHRIZWFkZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEF1dG8gZm9jdXNlcyB0aGUgaW5wdXQgYm94IGlmIHNldCB0byB0cnVlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b0ZvY3VzID0gY29uZmlnLmF1dG9Gb2N1cyA9PT0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYW4gXCJ4XCIgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gY2xlYXIgdGhlIGN1cnJlbnRcbiAgICAgKiBxdWVyeVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJCdXR0b24gPSBjb25maWcuY2xlYXJCdXR0b24gPT09IHVuZGVmaW5lZFxuICAgICAgPyB0cnVlXG4gICAgICA6IGNvbmZpZy5jbGVhckJ1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYXV0b2ZvY3VzaW5nIG9uIGxvYWQsIG9wdGlvbmFsbHkgb3BlbiB0aGUgYXV0b2NvbXBsZXRlXG4gICAgICogKHByZXNldCBwcm9tcHRzKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b2NvbXBsZXRlT25Mb2FkID0gY29uZmlnLmF1dG9jb21wbGV0ZU9uTG9hZCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIHN1Ym1pdFVSTCB3aWxsIGZvcmNlIHRoZSBzZWFyY2ggcXVlcnkgc3VibWlzc2lvbiB0byBnZXRcbiAgICAgKiByZWRpcmVjdGVkIHRvIHRoZSBVUkwgcHJvdmlkZWQuXG4gICAgICogT3B0aW9uYWwsIGRlZmF1bHRzIHRvIG51bGwuXG4gICAgICpcbiAgICAgKiBJZiBubyByZWRpcmVjdFVybCBwcm92aWRlZCwgd2Uga2VlcCB0aGUgcGFnZSBhcyBhIHNpbmdsZSBwYWdlIGFwcC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVkaXJlY3RVcmwgPSBjb25maWcucmVkaXJlY3RVcmwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlcmUgaXMgYW5vdGhlciBzZWFyY2ggYmFyIHByZXNlbnQgb24gdGhlIHBhZ2UuXG4gICAgICogVHdpbnMgb25seSB1cGRhdGUgdGhlIHF1ZXJ5LCBhbmQgZG8gbm90IHNlYXJjaFxuICAgICAqL1xuICAgIHRoaXMuX2lzVHdpbiA9IGNvbmZpZy5pc1R3aW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMucXVlcnkgPSBjb25maWcucXVlcnkgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5RVUVSWSwgcSA9PiB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBQZXJtaXNzaW9ucyBBUEkgaXMgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlciwgd2UgY2FuIHVzZSBsb2NhdGlvbiBkYXRhIHRoZSB1c2VyXG4gICAgICAvLyBoYXMgYWxyZWFkeSBjb25zZW50ZWQgdG8gc2hhcmUgaW5zdGVhZCBvZiBwcm9tcHRpbmcgYWdhaW4gdG8gZ2V0IGxvY2F0aW9uIGRhdGFcbiAgICAgIGlmIChuYXZpZ2F0b3IucGVybWlzc2lvbnMpIHtcbiAgICAgICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ2dlb2xvY2F0aW9uJyB9KS50aGVuKCh7IHN0YXRlIH0pID0+IHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09ICdncmFudGVkJykge1xuICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5HRU9MT0NBVElPTiwge1xuICAgICAgICAgICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICAgICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IHBvc2l0aW9uLmNvb3Jkcy5hY2N1cmFjeVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2gocSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2gocSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBib3RoIGNvZGUgcGF0aHMgYXJlIGFzeW5jaHJvdW5vdXMsIGZvciBjb25zaXN0ZW5jeVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNlYXJjaChxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSB0aW1lIGFsbG93ZWQgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gc2VhcmNoZXMgdG8gcHJldmVudFxuICAgICAqIG1hbnkgZHVwbGljYXRlIHNlYXJjaGVzIGJhY2stdG8tYmFja1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hDb29sZG93biA9IGNvbmZpZy5zZWFyY2hDb29sZG93biB8fCAzMDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgYW5kIFwibmVhciBtZVwiIGludGVudCBpcyBleHByZXNzZWQsIHByb21wdCB0aGUgdXNlciBmb3IgdGhlaXIgZ2VvbG9jYXRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Byb21wdEZvckxvY2F0aW9uID0gY29uZmlnLnByb21wdEZvckxvY2F0aW9uID09PSB1bmRlZmluZWRcbiAgICAgID8gdHJ1ZVxuICAgICAgOiBCb29sZWFuKGNvbmZpZy5wcm9tcHRGb3JMb2NhdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHNlYXJjaCBjbGVhciBidXR0b25cbiAgICAgKi9cbiAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSB0aGlzLmNsZWFyQnV0dG9uICYmIHRoaXMucXVlcnk7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdmVydGljYWwgc2VhcmNoIGJhcnMsIHdoZXRoZXIgb3Igbm90IHRvIGFsbG93IGVtcHR5IHNlYXJjaGVzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYWxsb3dFbXB0eVNlYXJjaCA9ICEhY29uZmlnLmFsbG93RW1wdHlTZWFyY2g7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnU2VhcmNoQmFyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnc2VhcmNoL3NlYXJjaCc7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMucXVlcnkgIT0gbnVsbCAmJiAhdGhpcy5yZWRpcmVjdFVybCkge1xuICAgICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJvbXB0Rm9yTG9jYXRpb24pIHtcbiAgICAgIHRoaXMuaW5pdExvY2F0aW9uUHJvbXB0KCk7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gTk9URShhbXVsbGluZ3MpOiBJZiBhdXRvY29tcGxldGVPbkxvYWQgaXMgZmFsc2UsIHdlIGZvY3VzIHRoZSBpbnB1dFxuICAgIC8vIGVsZW1lbnQgYmVmb3JlIGxvYWRpbmcgdGhlIGF1dG9jb21wbGV0ZSBjb21wb25lbnQgc28gdGhhdCBpdHMgZm9jdXNcbiAgICAvLyBoYW5kbGVyIHdvbid0IGJlIHRyaWdnZXJlZFxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyA9PT0gdHJ1ZSAmJiAhdGhpcy5xdWVyeSAmJiAhdGhpcy5hdXRvY29tcGxldGVPbkxvYWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyBXaXJlIHVwIG91ciBzZWFyY2ggaGFuZGxpbmcgYW5kIGF1dG8gY29tcGxldGVcbiAgICB0aGlzLmluaXRTZWFyY2godGhpcy5fZm9ybUVsKTtcbiAgICB0aGlzLmluaXRBdXRvQ29tcGxldGUodGhpcy5faW5wdXRFbCk7XG5cbiAgICBpZiAodGhpcy5jbGVhckJ1dHRvbikge1xuICAgICAgdGhpcy5pbml0Q2xlYXJCdXR0b24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvRm9jdXMgPT09IHRydWUgJiYgIXRoaXMucXVlcnkgJiYgdGhpcy5hdXRvY29tcGxldGVPbkxvYWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIGluaXRDbGVhckJ1dHRvbiAoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtU2VhcmNoQmFyLWNsZWFyJyk7XG4gICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gdGhpcy5fc2hvd0NsZWFyQnV0dG9uIHx8IHRoaXMucXVlcnk7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicsICF0aGlzLl9zaG93Q2xlYXJCdXR0b24pO1xuXG4gICAgRE9NLm9uKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgdGhpcy5fc2hvd0NsZWFyQnV0dG9uID0gZmFsc2U7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgneXh0LVNlYXJjaEJhci0taGlkZGVuJyk7XG4gICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuUVVFUlksIHRoaXMucXVlcnkpO1xuICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5zZXRRdWVyeSh0aGlzLnF1ZXJ5KTtcblxuICAgICAgLy8gRm9jdXMgdGhlIGlucHV0IGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgdGhlIHF1ZXJ5LCByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICAgIC8vIG9yIG5vdCB0aGUgYXV0b0ZvY3VzIG9wdGlvbiBpcyBlbmFibGVkLlxuICAgICAgLy8gTk9URShhbXVsbGluZ3MpOiBUaGlzIGRlcGVuZHMgaGVhdmlseSBvbiB0aGUgZmFjdCB0aGF0IHRoZSByZS1yZW5kZXJzXG4gICAgICAvLyB0cmlnZ2VyZWQgYnkgc2V0U3RhdGUgYW5kIGNvcmUuc2V0UXVlcnkgaGFwcGVuIHN5bmNocm9ub3VzbHk7IGlmIHRoaXNcbiAgICAgIC8vIHN0b3BzIGJlaW5nIHRoZSBjYXNlIGF0IHNvbWUgcG9pbnQsIHdlJ2xsIG5lZWQgYW4gYWx0ZXJuYXRpdmUgc29sdXRpb25cbiAgICAgIHRoaXMuZm9jdXNJbnB1dEVsZW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0ID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCk7XG4gICAgRE9NLm9uKGlucHV0LCAnaW5wdXQnLCBlID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQudmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX3Nob3dDbGVhckJ1dHRvbiAmJiBpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3Nob3dDbGVhckJ1dHRvbiA9IHRydWU7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd5eHQtU2VhcmNoQmFyLS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hvd0NsZWFyQnV0dG9uICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zaG93Q2xlYXJCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdExvY2F0aW9uUHJvbXB0ICgpIHtcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuSU5URU5UUywgaW50ZW50ID0+IHtcbiAgICAgIGlmICghaW50ZW50Lm5lYXJNZSB8fCB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5HRU9MT0NBVElPTikgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKHBvc2l0aW9uID0+IHtcbiAgICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OLCB7XG4gICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLFxuICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlYXJjaCh0aGlzLnF1ZXJ5IHx8ICcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCB0byB1c2UgZm9yIHdpcmluZyB1cCBzZWFyY2hpbmcgb24gZm9ybSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtU2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIHN1Ym1pdCBoYW5kbGluZyB0b1xuICAgKi9cbiAgaW5pdFNlYXJjaCAoZm9ybVNlbGVjdG9yKSB7XG4gICAgdGhpcy5fZm9ybUVsID0gZm9ybVNlbGVjdG9yO1xuXG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3l4dC1TZWFyY2hCYXItd3JhcHBlcicpO1xuXG4gICAgbGV0IGZvcm0gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCBmb3JtU2VsZWN0b3IpO1xuICAgIGlmICghZm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBTZWFyY2hCYXI7IENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9mb3JtRWwsICdgLicpO1xuICAgIH1cblxuICAgIERPTS5vbihmb3JtLCAnc3VibWl0JywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgbGV0IGlucHV0RWwgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IodGhpcy5faW5wdXRFbCk7XG5cbiAgICAgIGxldCBxdWVyeSA9IGlucHV0RWwudmFsdWU7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlZGlyZWN0VXJsLCB3ZSB3YW50IHRoZSBmb3JtIHRvIGJlXG4gICAgICAvLyBzZXJpYWxpemVkIGFuZCBzdWJtaXR0ZWQuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucmVkaXJlY3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5yZWRpcmVjdFVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlucHV0RWwuYmx1cigpO1xuXG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlFVRVJZLCBxdWVyeSk7XG4gICAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgICAgdGhpcy5jb3JlLnNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIHRoaXMuc2VhcmNoKHF1ZXJ5KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdG8gd2lyZSB1cCBvdXIgYXV0byBjb21wbGV0ZSBvbiBhbiBpbnB1dCBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRTZWxlY3RvciBDU1Mgc2VsZWN0b3IgdG8gYmluZCBvdXIgYXV0byBjb21wbGV0ZSBjb21wb25lbnQgdG9cbiAgICovXG4gIGluaXRBdXRvQ29tcGxldGUgKGlucHV0U2VsZWN0b3IpIHtcbiAgICB0aGlzLl9pbnB1dEVsID0gaW5wdXRTZWxlY3RvcjtcblxuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdXRvY29tcGxldGUgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYCxcbiAgICAgIGNvbnRhaW5lcjogJy55eHQtU2VhcmNoQmFyLWF1dG9jb21wbGV0ZScsXG4gICAgICBiYXJLZXk6IHRoaXMuX2JhcktleSxcbiAgICAgIGF1dG9Gb2N1czogdGhpcy5hdXRvRm9jdXMgJiYgIXRoaXMuYXV0b2NvbXBsZXRlT25Mb2FkLFxuICAgICAgdmVydGljYWxLZXk6IHRoaXMuX3ZlcnRpY2FsS2V5LFxuICAgICAgcHJvbXB0SGVhZGVyOiB0aGlzLnByb21wdEhlYWRlcixcbiAgICAgIG9yaWdpbmFsUXVlcnk6IHRoaXMucXVlcnksXG4gICAgICBpbnB1dEVsOiBpbnB1dFNlbGVjdG9yLFxuICAgICAgb25TdWJtaXQ6ICgpID0+IHtcbiAgICAgICAgRE9NLnRyaWdnZXIoRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fZm9ybUVsKSwgJ3N1Ym1pdCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICAgKi9cbiAgc2VhcmNoIChxdWVyeSkge1xuICAgIC8vIERvbid0IHNlYXJjaCBpZiB3ZSByZWNlbnRseSBzZWFyY2hlZCxcbiAgICAvLyBpZiB0aGVyZSdzIG5vIHF1ZXJ5IGZvciB1bml2ZXJzYWwgc2VhcmNoLFxuICAgIC8vIG9yIGlmIHRoaXMgaXMgYSB0d2luIHNlYXJjaGJhclxuICAgIGlmICh0aGlzLl90aHJvdHRsZWQgfHxcbiAgICAgICghcXVlcnkgJiYgIXRoaXMuX3ZlcnRpY2FsS2V5KSB8fFxuICAgICAgKCFxdWVyeSAmJiB0aGlzLl92ZXJ0aWNhbEtleSAmJiAhdGhpcy5fYWxsb3dFbXB0eVNlYXJjaCkgfHxcbiAgICAgIHRoaXMuX2lzVHdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Rocm90dGxlZCA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuX3Rocm90dGxlZCA9IGZhbHNlOyB9LCB0aGlzLl9zZWFyY2hDb29sZG93bik7XG5cbiAgICBpZiAodGhpcy5fdmVydGljYWxLZXkpIHtcbiAgICAgIGNvbnN0IGFsbEZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICAgID8gRmlsdGVyLmFuZCguLi5hbGxGaWx0ZXJzKVxuICAgICAgICA6IGFsbEZpbHRlcnNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLnZlcnRpY2FsU2VhcmNoKHRoaXMuX3ZlcnRpY2FsS2V5LCB7XG4gICAgICAgIGlucHV0OiBxdWVyeSxcbiAgICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICAgIG9mZnNldDogdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCkgfHwgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5PVEUoYmlsbHkpIFRlbXBvcmFyeSBoYWNrIGZvciBERU1PXG4gICAgICAvLyBSZW1vdmUgbWUgYWZ0ZXIgdGhlIGRlbW9cbiAgICAgIGxldCBuYXYgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXJcbiAgICAgICAgLmdldEFjdGl2ZUNvbXBvbmVudCgnTmF2aWdhdGlvbicpO1xuXG4gICAgICBpZiAobmF2KSB7XG4gICAgICAgIGxldCB0YWJzID0gbmF2LmdldFN0YXRlKCd0YWJzJyk7XG4gICAgICAgIGxldCB1cmxzID0ge307XG5cbiAgICAgICAgaWYgKHRhYnMgJiYgQXJyYXkuaXNBcnJheSh0YWJzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXModGFic1tpXS51cmwuc3BsaXQoJz8nKVsxXSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdxdWVyeScsIHF1ZXJ5KTtcblxuICAgICAgICAgICAgbGV0IHVybCA9IHRhYnNbaV0uYmFzZVVybDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudG9TdHJpbmcoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHVybCArPSAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHNbdGFic1tpXS5jb25maWdJZF0gPSB1cmw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcmUuc2VhcmNoKHF1ZXJ5LCB1cmxzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBsYWJlbFRleHQ6IHRoaXMubGFiZWxUZXh0LFxuICAgICAgc3VibWl0SWNvbjogdGhpcy5zdWJtaXRJY29uLFxuICAgICAgc3VibWl0VGV4dDogdGhpcy5zdWJtaXRUZXh0LFxuICAgICAgc2hvd0NsZWFyQnV0dG9uOiB0aGlzLl9zaG93Q2xlYXJCdXR0b24sXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSB8fCAnJ1xuICAgIH0sIGRhdGEpKTtcbiAgfVxuXG4gIGZvY3VzSW5wdXRFbGVtZW50ICgpIHtcbiAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCB0aGlzLl9pbnB1dEVsKS5mb2N1cygpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGaWx0ZXJTZWFyY2hDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi9kb20vc2VhcmNocGFyYW1zJztcblxuLyoqXG4gKiBGaWx0ZXJTZWFyY2hDb21wb25lbnQgaXMgdXNlZCBmb3IgYXV0b2NvbXBsZXRlIHVzaW5nIHRoZSBGaWx0ZXJTZWFyY2ggYmFja2VuZC5cbiAqIEl0J2xsIGFsbG93IHlvdSB0byBwaWNrIHByZS1zZXQgZmlsdGVycyB0aGF0IGFyZSBzZXR1cCBvbiB0aGUgYmFja2VuZCB3aXRoaW5cbiAqIGEgdmVydGljYWwgc2VhcmNoIGNvbnRleHQuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlclNlYXJjaENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQga2V5IGZvciB0aGUgdmVydGljYWwgc2VhcmNoIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2JhcktleSA9IGNvbmZpZy5iYXJLZXkgfHwgY29uZmlnLmlucHV0S2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB2ZXJ0aWNhbCBzZWFyY2ggY29uZmlndXJhdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlIHRoZSBmaWx0ZXIgdmFsdWUgYnV0IGRvIG5vdCBzZWFyY2ggb24gY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBRdWVyeSBzdWJtaXNzaW9uIGlzIGJhc2VkIG9uIGEgZm9ybSBhcyBjb250ZXh0LlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0cyB0byBuYXRpdmUgZm9ybSBub2RlIHdpdGhpbiBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9mb3JtRWwgPSBjb25maWcuZm9ybVNlbGVjdG9yIHx8ICdmb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgZm9yIHNlYXJjaGluZyBhbmQgd2lyZXMgdXAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9uXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBDU1Mgc2VsZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLl9pbnB1dEVsID0gY29uZmlnLmlucHV0RWwgfHwgJy5qcy15ZXh0LXF1ZXJ5JztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB1c2VkLCBwcm92aWRlZCB0byB0aGUgdGVtcGxhdGUgYXMgYSBkYXRhIHBvaW50XG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VhcmNoIHRleHQgdXNlZCBmb3IgbGFiZWxpbmcgdGhlIGlucHV0IGJveCwgYWxzbyBwcm92aWRlZCB0byB0ZW1wbGF0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaFRleHQgPSBjb25maWcuc2VhcmNoVGV4dCB8fCAnV2hhdCBhcmUgeW91IGludGVyZXN0ZWQgaW4/JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSB0ZXh0IHRvIHNob3cgYXMgdGhlIGZpcnN0IGl0ZW0gZm9yIGF1dG8gY29tcGxldGUuXG4gICAgICogT3B0aW9uYWxseSBwcm92aWRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wcm9tcHRIZWFkZXIgPSBjb25maWcucHJvbXB0SGVhZGVyIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBdXRvIGZvY3VzZXMgdGhlIGlucHV0IGJveCBpZiBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9Gb2N1cyA9IGNvbmZpZy5hdXRvRm9jdXMgPT09IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBzdWJtaXRVUkwgd2lsbCBmb3JjZSB0aGUgc2VhcmNoIHF1ZXJ5IHN1Ym1pc3Npb24gdG8gZ2V0XG4gICAgICogcmVkaXJlY3RlZCB0byB0aGUgVVJMIHByb3ZpZGVkLlxuICAgICAqIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBudWxsLlxuICAgICAqXG4gICAgICogSWYgbm8gcmVkaXJlY3RVcmwgcHJvdmlkZWQsIHdlIGtlZXAgdGhlIHBhZ2UgYXMgYSBzaW5nbGUgcGFnZSBhcHAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZGlyZWN0VXJsID0gY29uZmlnLnJlZGlyZWN0VXJsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGlucHV0IGJveCwgcHJvdmlkZWQgdG8gdGVtcGxhdGUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnF1ZXJ5ID0gY29uZmlnLnF1ZXJ5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNlYXJjaCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpbHRlciBzdHJpbmcgdG8gdXNlIGZvciB0aGUgcHJvdmlkZWQgcXVlcnlcbiAgICAgKiBPcHRpb25hbGx5IHByb3ZpZGVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlciA9IGNvbmZpZy5maWx0ZXIgfHwgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBKU09OLnBhcnNlKHRoaXMuZmlsdGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hQYXJhbWV0ZXJzID0gdGhpcy5fYnVpbGRTZWFyY2hQYXJhbWV0ZXJzKGNvbmZpZy5zZWFyY2hQYXJhbWV0ZXJzKTtcblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBgJHtTdG9yYWdlS2V5cy5GSUxURVJ9LiR7dGhpcy5uYW1lfWAsIGYgPT4geyB0aGlzLmZpbHRlciA9IGY7IH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlclNlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9maWx0ZXJzZWFyY2gnO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5ICYmIHRoaXMuZmlsdGVyKSB7XG4gICAgICB0aGlzLnNlYXJjaCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIFdpcmUgdXAgb3VyIHNlYXJjaCBoYW5kbGluZyBhbmQgYXV0byBjb21wbGV0ZVxuICAgIHRoaXMuaW5pdEF1dG9Db21wbGV0ZSh0aGlzLl9pbnB1dEVsKTtcblxuICAgIGlmICh0aGlzLmF1dG9Gb2N1cyA9PT0gdHJ1ZSAmJiB0aGlzLnF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5faW5wdXRFbCkuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIHdpcmUgdXAgb3VyIGF1dG8gY29tcGxldGUgb24gYW4gaW5wdXQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIGF1dG8gY29tcGxldGUgY29tcG9uZW50IHRvXG4gICAqL1xuICBpbml0QXV0b0NvbXBsZXRlIChpbnB1dFNlbGVjdG9yKSB7XG4gICAgdGhpcy5faW5wdXRFbCA9IGlucHV0U2VsZWN0b3I7XG5cbiAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYCxcbiAgICAgIGlzRmlsdGVyU2VhcmNoOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiAnLnl4dC1TZWFyY2hCYXItYXV0b2NvbXBsZXRlJyxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5wcm9tcHRIZWFkZXIsXG4gICAgICBvcmlnaW5hbFF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgb3JpZ2luYWxGaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgaW5wdXRFbDogaW5wdXRTZWxlY3RvcixcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIGJhcktleTogdGhpcy5fYmFyS2V5LFxuICAgICAgc2VhcmNoUGFyYW1ldGVyczogdGhpcy5zZWFyY2hQYXJhbWV0ZXJzLFxuICAgICAgb25TdWJtaXQ6IChxdWVyeSwgZmlsdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICBwYXJhbXMuc2V0KGAke3RoaXMubmFtZX0ucXVlcnlgLCBxdWVyeSk7XG4gICAgICAgIHBhcmFtcy5zZXQoYCR7dGhpcy5uYW1lfS5maWx0ZXJgLCBmaWx0ZXIpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSByZWRpcmVjdFVybCwgd2Ugd2FudCB0aGUgcGFyYW1zIHRvIGJlXG4gICAgICAgIC8vIHNlcmlhbGl6ZWQgYW5kIHN1Ym1pdHRlZC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlZGlyZWN0VXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5yZWRpcmVjdFVybCArICc/JyArIHBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgdGhlIGZpbHRlciB0byBzdG9yYWdlIGZvciB0aGUgbmV4dCBzZWFyY2hcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmZpbHRlciA9IEZpbHRlci5mcm9tUmVzcG9uc2UoZmlsdGVyKTtcbiAgICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCwgdGhpcy5xdWVyeSk7XG4gICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gLCB0aGlzLmZpbHRlcik7XG4gICAgICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCB0aGlzLmZpbHRlcik7XG4gICAgICAgIHRoaXMuc2VhcmNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSB0aGUgdmVydGljYWwgc2VhcmNoIHdpdGggYWxsIHNhdmVkIGZpbHRlcnMgYW5kIHF1ZXJ5LFxuICAgKiBvcHRpb25hbGx5IHJlZGlyZWN0aW5nIGJhc2VkIG9uIGNvbmZpZ1xuICAgKi9cbiAgc2VhcmNoICgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVPbkNoYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICBsZXQgdG90YWxGaWx0ZXIgPSBmaWx0ZXJzWzBdO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRvdGFsRmlsdGVyID0gRmlsdGVyLmFuZCguLi5maWx0ZXJzKTtcbiAgICB9XG4gICAgY29uc3Qgc2VhcmNoUXVlcnkgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSkgfHwgJyc7XG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcblxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl92ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHNlYXJjaFF1ZXJ5LFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxuICAgICAgc2VhcmNoVGV4dDogdGhpcy5zZWFyY2hUZXh0LFxuICAgICAgcXVlcnk6IHRoaXMucXVlcnksXG4gICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgfSwgZGF0YSkpO1xuICB9XG5cbiAgX2J1aWxkU2VhcmNoUGFyYW1ldGVycyAoc2VhcmNoUGFyYW1ldGVyQ29uZmlncykge1xuICAgIGxldCBzZWFyY2hQYXJhbWV0ZXJzID0ge1xuICAgICAgc2VjdGlvbmVkOiBmYWxzZSxcbiAgICAgIGZpZWxkczogW11cbiAgICB9O1xuICAgIGlmIChzZWFyY2hQYXJhbWV0ZXJDb25maWdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5zZWN0aW9uZWQpIHtcbiAgICAgIHNlYXJjaFBhcmFtZXRlcnMuc2VjdGlvbmVkID0gc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5zZWN0aW9uZWQ7XG4gICAgfVxuICAgIHNlYXJjaFBhcmFtZXRlcnMuZmllbGRzID0gdGhpcy5fYnVpbGRGaWVsZHMoc2VhcmNoUGFyYW1ldGVyQ29uZmlncy5maWVsZHMpO1xuICAgIHJldHVybiBzZWFyY2hQYXJhbWV0ZXJzO1xuICB9XG5cbiAgX2J1aWxkRmllbGRzIChmaWVsZENvbmZpZ3MpIHtcbiAgICBpZiAoZmllbGRDb25maWdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRDb25maWdzLm1hcChmYyA9PiAoeyBmZXRjaEVudGl0aWVzOiBmYWxzZSwgLi4uZmMgfSkpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBdXRvQ29tcGxldGVDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG5jb25zdCBLZXlzID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBFU0NBUEU6IDI3LFxuXG4gIExFRlQ6IDM3LFxuICBSSUdIVDogMzksXG4gIFVQOiAzOCxcblxuICBERUxFVEU6IDQ2LFxuICBET1dOOiA0MCxcbiAgTEVGVF9PU19LRVk6IDkxLFxuICBSSUdIVF9PU19LRVk6IDkyLFxuICBTRUxFQ1RfS0VZOiA5M1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0NvbXBsZXRlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGF1dG9jb21wbGV0ZSBpcyBzaW1wbGUgb3IgZmlsdGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0ZpbHRlclNlYXJjaCA9IG9wdHMuaXNGaWx0ZXJTZWFyY2ggfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGJhcktleWAgaW4gdGhlIHZlcnRpY2FsIHNlYXJjaCB0byB1c2UgZm9yIGF1dG8tY29tcGxldGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2JhcktleSA9IG9wdHMuYmFyS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYHZlcnRpY2FsS2V5YCBvZiB0aGUgdmVydGljYWwgc2VhcmNoIHRvIHVzZSBmb3IgYXV0by1jb21wbGV0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBvcHRzLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5wdXQgZWwgc2VsZWN0b3IgZm9yIGF1dG8gY29tcGxldGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2lucHV0RWwgPSBvcHRzLmlucHV0RWwgfHwgJy5qcy15ZXh0LXF1ZXJ5JztcblxuICAgIC8qKlxuICAgICAqIEEgc2VsZWN0b3IgZm9yIHRoZSBhdXRvY29tcGxldGUgZWxlbWVudGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9hdXRvY29tcGxldGVFbHMgPSBvcHRzLmF1dG9Db21wbGV0ZUVscyB8fCAnLmpzLXlleHQtYXV0b2NvbWxldGUtb3B0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSBmb3IgdGhlIGRhdGEtc3RvcmFnZSB0byBsaXN0ZW4gZm9yIHVwZGF0ZXMgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gYCR7U3RvcmFnZUtleXMuQVVUT0NPTVBMRVRFfS4ke3RoaXMubmFtZX1gO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHR5cGluZy5cbiAgICAgKiBXZSB1c2UgdGhpcyBmb3IgcmVzZXR0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgdmFsdWUgd2hlbiBvdGhlciBpbnRlcmFjdGlvbnMgKGUuZy4gcmVzdWx0IG5hdmlnYXRpb24pXG4gICAgICogY2hhbmdlIGJhc2VkIG9uIGludGVyYWN0aW9ucy4gRm9yIGluc3RhbmNlLCBoaXR0aW5nIGVzY2FwZSBzaG91bGQgcmVzZXQgdGhlIHZhbHVlIHRvIHRoZSBvcmlnaW5hbCB0eXBlZCBxdWVyeS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSBvcHRzLm9yaWdpbmFsUXVlcnkgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIHRocm91Z2ggcmVzdWx0cy5cbiAgICAgKiBBbiBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgc2VjdGlvbiB3ZSdyZSBuYXZpZ2F0aW5nIGluLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc2VjdGlvbkluZGV4ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24gdGhyb3VnaCByZXN1bHRzLlxuICAgICAqIEFuIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZXN1bHQgaW5kZXggd2UncmUgbmF2aWdhdGluZyBvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgdGV4dCB0byBzaG93IGFzIHRoZSBmaXJzdCBpdGVtIGZvciBhdXRvIGNvbXBsZXRlLlxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvbXB0SGVhZGVyID0gb3B0cy5wcm9tcHRIZWFkZXIgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGF1dG9jb21hdGljYWxseSBmb2N1c2VkIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2F1dG9Gb2N1cyA9IG9wdHMuYXV0b0ZvY3VzIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSBgRW50ZXJgIGtleSBpcyBwcmVzc2VkIG9uIGF1dG8gY29tcGxldGUuXG4gICAgICovXG4gICAgdGhpcy5fb25TdWJtaXQgPSBvcHRzLm9uU3VibWl0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5fc2VhcmNoUGFyYW1ldGVycyA9IG9wdHMuc2VhcmNoUGFyYW1ldGVycyB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhbGlhc2VkIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBtYW5hZ2VyIGZvciBjcmVhdGlvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdBdXRvQ29tcGxldGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvYXV0b2NvbXBsZXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZSBpcyBvdmVycmlkZGVuIHNvIHRoYXQgd2UgY2FuIHByb3ZpZGUgYWRkaXRpb25hbCBtZXRhIGRhdGFcbiAgICogdG8gdGhlIHRlbXBsYXRlIChlLmcuIHRoZSBzZWN0aW9uSW5kZXggYW5kIHJlc3VsdEluZGV4KSwgc2luY2VcbiAgICogdGhvc2UgYXJlIGNsaWVudC1pbnRlcmFjdGlvbiBzcGVjaWZpYyB2YWx1ZXMgYW5kIGFyZW4ndCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGlmICghdGhpcy5pc1F1ZXJ5SW5wdXRGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IDA7XG4gICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IC0xO1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBoYXNSZXN1bHRzOiB0aGlzLmhhc1Jlc3VsdHMoZGF0YSksXG4gICAgICBzZWN0aW9uSW5kZXg6IHRoaXMuX3NlY3Rpb25JbmRleCxcbiAgICAgIHJlc3VsdEluZGV4OiB0aGlzLl9yZXN1bHRJbmRleCxcbiAgICAgIHByb21wdEhlYWRlcjogdGhpcy5fb3JpZ2luYWxRdWVyeS5sZW5ndGggPT09IDAgPyB0aGlzLnByb21wdEhlYWRlciA6IG51bGxcbiAgICB9KSk7XG4gIH1cblxuICBpc1F1ZXJ5SW5wdXRGb2N1c2VkICgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc05hbWUuaW5jbHVkZXModGhpcy5faW5wdXRFbC5zdWJzdHJpbmcoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGlzIGEgaGVscGVyIHRvIGFwcGx5IHRoZSBjdXJyZW50IHN0YXRlIHdpdGggbmV3IGNsaWVudC1zdGF0ZS5cbiAgICovXG4gIHVwZGF0ZVN0YXRlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuX3N0YXRlLmdldCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbkNyZWF0ZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIGZyYW1ld29yay5cbiAgICogT25jZSB3ZSdyZSBpbml0YWxpemVkLCB3ZSB3aXJlIHVwIGFsbCBvZiBvdXIgdXNlciBpbnRlcmFjdGlvbnNcbiAgICovXG4gIG9uQ3JlYXRlICgpIHtcbiAgICAvLyBVc2UgdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gZmluZCB0aGUgaW5wdXQgbm9kZS5cbiAgICBsZXQgcXVlcnlJbnB1dCA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIGlmICghcXVlcnlJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBBdXRvQ29tcGxldGUuIENhbiBub3QgZmluZCB7SFRNTEVsZW1lbnR9IGAnLCB0aGlzLl9pbnB1dEVsLCAnYC4nKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIHRoZSBuYXRpdmUgYXV0b2NvbXBsZXRlLCBhdXRvY29ycmVjdCAmIHNwZWxsY2hlY2tcbiAgICBET00uYXR0cmlidXRlcyhxdWVyeUlucHV0LCB7XG4gICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJ1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHVzZXIgZXhpdHMgdGhlIGlucHV0LCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzdGF0ZSBhbmQgY2xvc2VcbiAgICAvLyB0aGUgYXV0byBjb21wbGV0ZVxuICAgIC8vIFRPRE8oamRlbGVybWUpOiBDbG9zZSBsb2dpYyB0byBiZSBtb3ZlZCB0byBwYXJlbnRcbiAgICBET00ub24oZG9jdW1lbnQsICdjbGljaycsIGUgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0Lm1hdGNoZXMoJy5qcy15eHQtQXV0b0NvbXBsZXRlLXdyYXBwZXIgKicpIHx8IGUudGFyZ2V0Lm1hdGNoZXModGhpcy5faW5wdXRFbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gV2hlbiBhIHVzZXIgZm9jdXNlcyB0aGUgaW5wdXQsIHdlIHNob3VsZCBwb3B1bGF0ZSB0aGUgYXV0b2NvbXBsZXRlIGJhc2VkXG4gICAgLy8gb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICBET00ub24ocXVlcnlJbnB1dCwgJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hdXRvQ29tcGxldGUocXVlcnlJbnB1dC52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHRoZSByZXN1bHRzIHVzaW5nIHRoZSBrZXlib2FyZFxuICAgIERPTS5vbihxdWVyeUlucHV0LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU5hdmlnYXRlUmVzdWx0cyhlLmtleUNvZGUsIGUpO1xuICAgICAgdGhpcy5oYW5kbGVTdWJtaXRSZXN1bHQoZS5rZXlDb2RlLCBxdWVyeUlucHV0LnZhbHVlLCBlKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9hdXRvRm9jdXMpIHtcbiAgICAgIERPTS5vbmNlKHF1ZXJ5SW5wdXQsICdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGUocXVlcnlJbnB1dC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBzZWxlY3QgYSByZXN1bHQgd2l0aCB0aGUgbW91c2VcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtYXV0b2NvbXBsZXRlLW9wdGlvbicsICdjbGljaycsIChldnQsIHRhcmdldCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZGF0YXNldDtcbiAgICAgIGxldCB2YWwgPSBkYXRhLnNob3J0O1xuXG4gICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHZhbCk7XG4gICAgICB0aGlzLl9vblN1Ym1pdCh2YWwsIGRhdGEuZmlsdGVyKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIHVzZXIgaXMgdHlwaW5nIGluIHRoZSBpbnB1dCwgcHJvY2VzcyB0aGUgYXV0byBjb21wbGV0ZS5cbiAgICBET00ub24ocXVlcnlJbnB1dCwgJ2tleXVwJywgKGUpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVHlwaW5nKGUua2V5Q29kZSwgcXVlcnlJbnB1dC52YWx1ZSwgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogY2xvc2Ugd2lsbCBoaWRlIHRoZSBhdXRvIGNvbXBsZXRlIHJlc3VsdHMgYW5kIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogcmVzZXRzIHRoZSBjbGllbnQgc3RhdGUgdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWVzIGFuZCB0cmlnZ2Vyc1xuICAgKiBhIHRlbXBsYXRlLXJlcmVuZGVyIHZpYSB1cGRhdGVTdGF0ZVxuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IDA7XG4gICAgdGhpcy5fcmVzdWx0SW5kZXggPSAtMTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdFZhbHVlIE9wdGlvbiB2YWx1ZSBwcm92aWRlZC5cbiAgICogSWYgbm8gdmFsdWUgcHJvdmlkZWQsIHdlJ2xsIHRyeSB0byBmaW5kIGl0IGJhc2VkIG9uIHRoZSBzZWxlY3Rpb24gaW5kZXhlcy5cbiAgICovXG4gIHVwZGF0ZVF1ZXJ5IChvcHRWYWx1ZSkge1xuICAgIC8vIE9ubHkgd2FudCB0byB1cGRhdGUgdGhlIHF1ZXJ5IHN0cmluZyBpZiB0aGVyZXMgYSB2YWx1ZS5cbiAgICAvLyBJZiBvbmUgaXMgcHJvdmlkZWQsIGdyZWF0LlxuICAgIC8vIE90aGVyd2lzZSwgbGV0cyB0cnkgdG8gZmluZCBpdCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgcmVzdWx0cy5cbiAgICBpZiAob3B0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5fc3RhdGUuZ2V0KCdzZWN0aW9ucycpO1xuXG4gICAgICBsZXQgcmVzdWx0cyA9IHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0cztcbiAgICAgIG9wdFZhbHVlID0gcmVzdWx0c1t0aGlzLl9yZXN1bHRJbmRleF0uc2hvcnRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlFbCA9IERPTS5xdWVyeSh0aGlzLl9wYXJlbnRDb250YWluZXIsIHRoaXMuX2lucHV0RWwpO1xuICAgIHF1ZXJ5RWwudmFsdWUgPSBvcHRWYWx1ZTtcbiAgfVxuXG4gIGhhbmRsZVR5cGluZyAoa2V5LCB2YWx1ZSwgZSkge1xuICAgIGxldCBpZ25vcmVkS2V5cyA9IFtcbiAgICAgIEtleXMuRE9XTixcbiAgICAgIEtleXMuVVAsXG4gICAgICBLZXlzLkNUUkwsXG4gICAgICBLZXlzLkFMVCxcbiAgICAgIEtleXMuU0hJRlQsXG4gICAgICBLZXlzLkxFRlQsXG4gICAgICBLZXlzLlJJR0hULFxuICAgICAgS2V5cy5MRUZUX09TX0tFWSxcbiAgICAgIEtleXMuUklHSFRfT1NfS0VZLFxuICAgICAgS2V5cy5FTlRFUixcbiAgICAgIEtleXMuVEFCLFxuICAgICAgS2V5cy5TRUxFQ1RfS0VZXG4gICAgXTtcblxuICAgIGlmIChpZ25vcmVkS2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVzZXIgZXNjYXBlcyBvdXQgb2YgYXV0byBjb21wbGV0ZSwgc28gd2UgcmVzZXQgaXQgdG8gdGhlIG9yaWdpbmFsIGlucHV0XG4gICAgaWYgKGtleSA9PT0gS2V5cy5FU0NBUEUpIHtcbiAgICAgIHRoaXMudXBkYXRlUXVlcnkodGhpcy5fb3JpZ2luYWxRdWVyeSk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBvcmlnaW5hbCB2YWx1ZSBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dFxuICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSB2YWx1ZTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmF1dG9Db21wbGV0ZSh2YWx1ZSk7XG4gIH1cblxuICBhdXRvQ29tcGxldGUgKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuaXNGaWx0ZXJTZWFyY2gpIHtcbiAgICAgIHRoaXMuY29yZS5hdXRvQ29tcGxldGVGaWx0ZXIoaW5wdXQsIHtcbiAgICAgICAgbmFtZXNwYWNlOiB0aGlzLm5hbWUsXG4gICAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgICAgYmFyS2V5OiB0aGlzLl9iYXJLZXksXG4gICAgICAgIHNlYXJjaFBhcmFtZXRlcnM6IHRoaXMuX3NlYXJjaFBhcmFtZXRlcnNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdmVydGljYWxLZXkgfHwgdGhpcy5fYmFyS2V5KSB7XG4gICAgICB0aGlzLmNvcmUuYXV0b0NvbXBsZXRlVmVydGljYWwoaW5wdXQsIHRoaXMubmFtZSwgdGhpcy5fdmVydGljYWxLZXksIHRoaXMuX2JhcktleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29yZS5hdXRvQ29tcGxldGVVbml2ZXJzYWwoaW5wdXQsIHRoaXMubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdHJ1ZSBpZiB3ZSBoYXZlIHJlc3VsdHMgaW4gYW55IHNlY3Rpb25cbiAgICogQHJldHVybnMgYm9vbGVhblxuICAgKi9cbiAgaGFzUmVzdWx0cyAoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc2VjdGlvbnMgPSBkYXRhWydzZWN0aW9ucyddO1xuICAgIGlmICghc2VjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhID0gc2VjdGlvbnNbaV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHRzID0gZGF0YS5yZXN1bHRzO1xuICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZU5hdmlnYXRlUmVzdWx0cyAoa2V5LCBlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gdGhpcy5fc3RhdGUuZ2V0KCdzZWN0aW9ucycpO1xuICAgIGlmIChzZWN0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHNlY3Rpb25zLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGFiYmluZyBvdXQgb3IgZW50ZXIgc2hvdWxkIGNsb3NlIHRoZSBhdXRvIGNvbXBsZXRlLlxuICAgIGlmIChrZXkgPT09IEtleXMuVEFCKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdHMgPSBzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHM7XG4gICAgaWYgKGtleSA9PT0gS2V5cy5VUCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuX3Jlc3VsdEluZGV4IDw9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25JbmRleCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9zZWN0aW9uSW5kZXgtLTtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRJbmRleCA9IHNlY3Rpb25zW3RoaXMuX3NlY3Rpb25JbmRleF0ucmVzdWx0cy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBkYXRlUXVlcnkodGhpcy5fb3JpZ2luYWxRdWVyeSk7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXN1bHRJbmRleC0tO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IEtleXMuRE9XTikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuX3Jlc3VsdEluZGV4ID49IHJlc3VsdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAodGhpcy5fc2VjdGlvbkluZGV4IDwgc2VjdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCsrO1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXN1bHRJbmRleCsrO1xuICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN1Ym1pdFJlc3VsdCAoa2V5LCB2YWx1ZSwgZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuX3N0YXRlLmdldCgnc2VjdGlvbnMnKTtcbiAgICBpZiAoc2VjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWN0aW9ucy5sZW5ndGggPD0gMCkge1xuICAgICAgaWYgKHRoaXMuaXNGaWx0ZXJTZWFyY2gpIHtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN1Ym1pdCB0aGUgc2VhcmNoIG9uIGVudGVyXG4gICAgaWYgKGtleSA9PT0gS2V5cy5FTlRFUikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlclNlYXJjaCAmJiB0aGlzLl9yZXN1bHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZmlsdGVyID0gJyc7XG4gICAgICBpZiAodGhpcy5fc2VjdGlvbkluZGV4ID49IDAgJiYgdGhpcy5fcmVzdWx0SW5kZXggPj0gMCkge1xuICAgICAgICBmaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShzZWN0aW9uc1t0aGlzLl9zZWN0aW9uSW5kZXhdLnJlc3VsdHNbdGhpcy5fcmVzdWx0SW5kZXhdLmZpbHRlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUXVlcnkodmFsdWUpO1xuICAgICAgdGhpcy5fb3JpZ2luYWxRdWVyeSA9IHZhbHVlO1xuICAgICAgdGhpcy5fb25TdWJtaXQodmFsdWUsIGZpbHRlcik7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKiogQG1vZHVsZSBTcGVsbENoZWNrQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTZWFyY2hQYXJhbXMgZnJvbSAnLi4vLi4vZG9tL3NlYXJjaHBhcmFtcyc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcblxuLyoqXG4gKiBTcGVsbENoZWNrQ29tcG9uZW50IHdpbGwgc3VwcG9ydCBkaXNwbGF5aW5nIHN1Z2dlc3Rpb24sIGF1dG9jb3JyZWN0IGFuZCBjb21iaW5lZChtYXliZSBpbiB0aGUgZnV0dXJlKVxuICogcHJvdmlkZWQgZnJvbSBzcGVsbGluZyBjb3JyZWN0aW9uLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVsbENoZWNrQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5TUEVMTF9DSEVDSztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdTcGVsbENoZWNrJztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaC9zcGVsbGNoZWNrJztcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICB0aGlzLmNvcmUucGVyc2lzdGVudFN0b3JhZ2UuZGVsZXRlKCdza2lwU3BlbGxDaGVjaycsIHRydWUpO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoJ3F1ZXJ5VHJpZ2dlcicsIHRydWUpO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEsIHZhbCkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBzaG91bGRTaG93OiBkYXRhLmNvcnJlY3RlZFF1ZXJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICBjb3JyZWN0ZWRRdWVyeVVybDogdGhpcy5fYnVpbGRSZWRpcmVjdFF1ZXJ5VXJsKGRhdGEuY29ycmVjdGVkUXVlcnksIGRhdGEudHlwZSksXG4gICAgICBoZWxwVGV4dDogdGhpcy5fZ2V0SGVscFRleHQoZGF0YS50eXBlKVxuICAgIH0sIHZhbCkpO1xuICB9XG5cbiAgX2J1aWxkUmVkaXJlY3RRdWVyeVVybCAocXVlcnksIHR5cGUpIHtcbiAgICBpZiAocXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBsZXQgcGFyYW1zID0gbmV3IFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgcGFyYW1zLnNldCgncXVlcnknLCBxdWVyeS52YWx1ZSk7XG4gICAgcGFyYW1zLnNldCgnc2tpcFNwZWxsQ2hlY2snLCB0cnVlKTtcbiAgICBwYXJhbXMuc2V0KCdxdWVyeVRyaWdnZXInLCB0eXBlLnRvTG93ZXJDYXNlKCkpO1xuICAgIHJldHVybiAnPycgKyBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIF9nZXRIZWxwVGV4dCAodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnU1VHR0VTVCc6XG4gICAgICAgIHJldHVybiAnRGlkIHlvdSBtZWFuOic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZpbHRlcic7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogTG9jYXRpb25CaWFzQ29tcG9uZW50IHdpbGwgc2hvdyB0aGUgdXNlciB3aGVyZSBpcyB1c2VkIGZvciBsb2NhdGlvbiBiaWFzIGFuZCBhbGxvdyB1c2VyIHRvXG4gKiBpbXByb3ZlIGFjY3VyYWN5IHdpdGggSFRNTDUgZ2VvbG9jYXRpb24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2F0aW9uQmlhc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiBSZWNpZXZlIHVwZGF0ZXMgZnJvbSBzdG9yYWdlIGJhc2VkIG9uIHRoaXMgaW5kZXhcbiAgICAgKiBAdHlwZSB7U3RvcmFnZUtleX1cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuTE9DQVRJT05fQklBUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCB2ZXJ0aWNhbCBrZXkgZm9yIHZlcnRpY2FsIHNlYXJjaCBjb25maWd1cmF0aW9uXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB3aGVuIGxvY2F0aW9uIHVwZGF0ZWQsXG4gICAgICogYSB1bml2ZXJzYWwgc2VhcmNoIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLy8gVE9ETzogUmVtb3ZlIGNvbmZpZy52ZXJ0aWNhbEtleVxuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB1c2VkIGZvciB1cGRhdGluZyBsb2NhdGlvblxuICAgICAqIE9wdGlvbmFsbHkgcHJvdmlkZWQuXG4gICAgICogQHR5cGUge3N0cmluZ30gQ1NTIHNlbGVjdG9yXG4gICAgICovXG4gICAgdGhpcy5fdXBkYXRlTG9jYXRpb25FbCA9IGNvbmZpZy51cGRhdGVMb2NhdGlvbkVsIHx8ICcuanMtbG9jYXRpb25CaWFzLXVwZGF0ZS1sb2NhdGlvbic7XG5cbiAgICB0aGlzLl9sb2NhdGlvbkRpc3BsYXlOYW1lID0gJyc7XG5cbiAgICB0aGlzLl9hY2N1cmFjeSA9ICcnO1xuXG4gICAgdGhpcy5fYWxsb3dVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0xvY2F0aW9uQmlhcyc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdzZWFyY2gvbG9jYXRpb25iaWFzJztcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICghdGhpcy5fYWxsb3dVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlzYWJsZUxvY2F0aW9uVXBkYXRlSWZHZW9sb2NhdGlvbkRlbmllZCgpO1xuICAgIERPTS5vbih0aGlzLl91cGRhdGVMb2NhdGlvbkVsLCAnY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OLCB7XG4gICAgICAgICAgICBsYXQ6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcbiAgICAgICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fZG9TZWFyY2goKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUxvY2F0aW9uVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB0aHJvdyBlcnJvciBvciB3YXJuaW5nIGhlcmUgaWYgbm8gZ2VvbG9jYXRpb24/XG4gICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSwgdmFsKSB7XG4gICAgdGhpcy5fbG9jYXRpb25EaXNwbGF5TmFtZSA9IGRhdGEubG9jYXRpb25EaXNwbGF5TmFtZTtcbiAgICB0aGlzLl9hY2N1cmFjeSA9IGRhdGEuYWNjdXJhY3k7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIGxvY2F0aW9uRGlzcGxheU5hbWU6IHRoaXMuX2dldExvY2F0aW9uRGlzcGxheU5hbWUoZGF0YSksXG4gICAgICBhY2N1cmFjeVRleHQ6IHRoaXMuX2dldEFjY3VyYWN5SGVscFRleHQoZGF0YS5hY2N1cmFjeSksXG4gICAgICBpc1ByZWNpc2VMb2NhdGlvbjogZGF0YS5hY2N1cmFjeSA9PT0gJ0RFVklDRScgJiYgdGhpcy5fYWxsb3dVcGRhdGUsXG4gICAgICBpc1Vua25vd25Mb2NhdGlvbjogZGF0YS5hY2N1cmFjeSA9PT0gJ1VOS05PV04nLFxuICAgICAgc2hvdWxkU2hvdzogZGF0YS5hY2N1cmFjeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgYWxsb3dVcGRhdGU6IHRoaXMuX2FsbG93VXBkYXRlXG4gICAgfSwgdmFsKSk7XG4gIH1cblxuICBfZ2V0TG9jYXRpb25EaXNwbGF5TmFtZSAoZGF0YSkge1xuICAgIGlmIChkYXRhLmFjY3VyYWN5ID09PSAnVU5LTk9XTicpIHtcbiAgICAgIHJldHVybiAnVW5rbm93biBMb2NhdGlvbic7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLmxvY2F0aW9uRGlzcGxheU5hbWU7XG4gIH1cblxuICBfZ2V0QWNjdXJhY3lIZWxwVGV4dCAoYWNjdXJhY3kpIHtcbiAgICBzd2l0Y2ggKGFjY3VyYWN5KSB7XG4gICAgICBjYXNlICdJUCc6XG4gICAgICAgIHJldHVybiAnYmFzZWQgb24geW91ciBpbnRlcm5ldCBhZGRyZXNzJztcbiAgICAgIGNhc2UgJ0RFVklDRSc6XG4gICAgICAgIHJldHVybiAnYmFzZWQgb24geW91ciBkZXZpY2UnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIF9kb1NlYXJjaCAoKSB7XG4gICAgbGV0IHF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuICAgIGlmICh0aGlzLl92ZXJ0aWNhbEtleSkge1xuICAgICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgICAgY29uc3QgdG90YWxGaWx0ZXIgPSBhbGxGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgPyBGaWx0ZXIuYW5kKC4uLmFsbEZpbHRlcnMpXG4gICAgICAgIDogYWxsRmlsdGVyc1swXTtcbiAgICAgIGNvbnN0IGZhY2V0RmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0QWxsKFN0b3JhZ2VLZXlzLkZBQ0VUX0ZJTFRFUilbMF07XG4gICAgICB0aGlzLmNvcmUudmVydGljYWxTZWFyY2godGhpcy5fdmVydGljYWxLZXksIHtcbiAgICAgICAgaW5wdXQ6IHF1ZXJ5LFxuICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwLFxuICAgICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3JlLnNlYXJjaChxdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVMb2NhdGlvblVwZGF0ZUlmR2VvbG9jYXRpb25EZW5pZWQgKCkge1xuICAgIGlmICgncGVybWlzc2lvbnMnIGluIG5hdmlnYXRvcikge1xuICAgICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ2dlb2xvY2F0aW9uJyB9KVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVMb2NhdGlvblVwZGF0ZSAoKSB7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLkdFT0xPQ0FUSU9OKTtcbiAgICB0aGlzLl9hbGxvd1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbG9jYXRpb25EaXNwbGF5TmFtZTogdGhpcy5fbG9jYXRpb25EaXNwbGF5TmFtZSxcbiAgICAgIGFjY3VyYWN5OiB0aGlzLl9hY2N1cmFjeVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGYWNldCAqL1xuXG4vKipcbiAqIE1vZGVsIHJlcHJlc2VudGluZyBhIGZhY2V0IGZpbHRlciB3aXRoIHRoZSBmb3JtYXQgb2ZcbiAqIHtcbiAqICAgXCJmaWVsZF9uYW1lXCI6IFsgRmlsdGVycy4uLiBdLFxuICogICAuLi5cbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBGaWx0ZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY2V0IHtcbiAgY29uc3RydWN0b3IgKGRhdGEgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGF0YSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmYWNldCBmaWx0ZXIgZnJvbSBhIGxpc3Qgb2YgRmlsdGVyc1xuICAgKiBAcGFyYW0gIHsuLi5GaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gdXNlIGluIHRoaXMgZmFjZXRcbiAgICogQHJldHVybnMge0ZhY2V0fVxuICAgKi9cbiAgc3RhdGljIGZyb21GaWx0ZXJzIChhdmFpbGFibGVGaWVsZElkcywgLi4uZmlsdGVycykge1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGF2YWlsYWJsZUZpZWxkSWRzLmZvckVhY2goZmllbGRJZCA9PiB7XG4gICAgICBncm91cHNbZmllbGRJZF0gPSBbXTtcbiAgICB9KTtcbiAgICBjb25zdCBmbGF0RmlsdGVycyA9IGZpbHRlcnMuZmxhdE1hcChmID0+IGYuJG9yIHx8IGYpO1xuICAgIGZsYXRGaWx0ZXJzLmZvckVhY2goZiA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhmKVswXTtcbiAgICAgIGlmICghZ3JvdXBzW2tleV0pIHtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1trZXldLnB1c2goZik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IEZhY2V0KGdyb3Vwcyk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlckJveENvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IEZhY2V0IGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL2ZhY2V0JztcblxuY2xhc3MgRmlsdGVyQm94Q29uZmlnIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSB0byBkaXNwbGF5IGFib3ZlIHRoZSBjb250cm9sc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IGNvbmZpZy50aXRsZSB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5IHRoZSBudW1iZXIgb2YgcmVzdWx0cyBuZXh0IHRvIGVhY2ggZmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dDb3VudCA9IGNvbmZpZy5zaG93Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0NvdW50O1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdHJpZ2dlciBhIHNlYXJjaCBvbiBlYWNoIGNoYW5nZSB0byBhIGZpbHRlclxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoT25DaGFuZ2UgPSBjb25maWcuc2VhcmNoT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzaG93IGEgYnV0dG9uIHRvIHJlc2V0IGZvciBlYWNoIGZhY2V0IGdyb3VwXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlciA9IGNvbmZpZy5yZXNldEZhY2V0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSByZXNldCBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXJMYWJlbCA9IGNvbmZpZy5yZXNldEZhY2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBcInJlc2V0IGFsbFwiIGJ1dHRvbiB0byByZXNldCBhbGwgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZpbHRlcnMgPSBjb25maWcucmVzZXRGYWNldHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucmVzZXRGYWNldHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIFwicmVzZXQgYWxsXCIgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmlsdGVyc0xhYmVsID0gY29uZmlnLnJlc2V0RmFjZXRzTGFiZWwgfHwgJ3Jlc2V0IGFsbCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG51bWJlciBvZiBmYWNldHMgdG8gc2hvdyBiZWZvcmUgZGlzcGxheWluZyBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IGNvbmZpZy5zaG93TW9yZUxpbWl0IHx8IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ3Nob3cgbW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBsZXNzIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TGVzc0xhYmVsID0gY29uZmlnLnNob3dMZXNzTGFiZWwgfHwgJ3Nob3cgbGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBlbmFibGUgaGlkaW5nIGV4Y2VzcyBmYWNldHMgaW4gZWFjaCBncm91cCB3aXRoIGEgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmUgPSBjb25maWcuc2hvd01vcmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd01vcmU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvdyBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmcgZWFjaCBncm91cCBvZiBmYWNldHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGFuZCA9IGNvbmZpZy5leHBhbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuZXhwYW5kO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheSB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhcHBsaWVkIGZpbHRlcnMgd2hlbiBjb2xsYXBzZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dOdW1iZXJBcHBsaWVkID0gY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkO1xuXG4gICAgLyoqXG4gICAgICogVGV4dCB0byBkaXNwbGF5IG9uIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlMYWJlbCA9IGNvbmZpZy5hcHBseUxhYmVsIHx8ICdhcHBseSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0b3Igb2YgdGhlIGFwcGx5IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hcHBseUJ1dHRvblNlbGVjdG9yID0gY29uZmlnLmFwcGx5QnV0dG9uU2VsZWN0b3IgfHwgJy5qcy15ZXh0LWZpbHRlcmJveC1hcHBseSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiBmaWx0ZXJzIHRvIGRpc3BsYXkgYW5kIGNvbnRyb2wsIGlnbm9yaW5nIGVtcHR5IHNlY3Rpb25zXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyQ29uZmlncyA9IGNvbmZpZy5maWx0ZXJzLmZpbHRlcihmID0+IGYub3B0aW9ucy5sZW5ndGggIT09IDApO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyBmaWx0ZXJib3ggY29udGFpbnMgZmFjZXRzLiBUaGlzIGFmZmVjdHMgdGhlXG4gICAgICogdGhlIHdheSB0aGUgZmlsdGVycyBhcmUgdXNlZCBpbiB0aGUgc2VhcmNoXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0R5bmFtaWMgPSBjb25maWcuaXNEeW5hbWljIHx8IGZhbHNlO1xuXG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICB9XG5cbiAgdmFsaWRhdGUgKCkge1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHNldCBvZiBmaWx0ZXJzLCBhbmQgc2VhcmNoZXMgd2l0aCB0aGVtIHdoZW4gYXBwbGllZC5cbiAqIE11bHRpcGxlIEZpbHRlckJveCBjb21wb25lbnRzIHdpbGwgQU5EIHRvZ2V0aGVyIGJ1dCB3aWxsIG5vdCBzaGFyZSBzdGF0ZS5cbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJCb3hDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgdGhpcy5jb25maWcgPSBuZXcgRmlsdGVyQm94Q29uZmlnKGNvbmZpZyk7XG5cbiAgICBpZiAoIWNvbmZpZy5maWx0ZXJzIHx8ICEoY29uZmlnLmZpbHRlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICdGaWx0ZXJCb3ggcmVxdWlyZXMgZmlsdGVycyB0byBiZSBwcm92aWRlZCBhcyBhbiBhcnJheScsXG4gICAgICAgICdGaWx0ZXJCb3gnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwga2V5IGZvciB0aGUgc2VhcmNoXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsS2V5ID0gY29uZmlnLnZlcnRpY2FsS2V5IHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50cyBjcmVhdGVkIGZvciBlYWNoIGZpbHRlciBjb25maWdcbiAgICAgKiBAdHlwZSB7Q29tcG9uZW50W119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmlsdGVyIGNvbXBvbmVudHMgaW4gdGhlIGJveFxuICAgICAqIEB0eXBlIHtGaWx0ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJzID0gW107XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLnNob3dDb3VudCkge1xuICAgICAgdGhpcy5jb25maWcuZmlsdGVyQ29uZmlncy5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgIGNvbmZpZy5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICBvcHRpb24uY291bnRMYWJlbCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlckJveCc7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdmaWx0ZXJzL2ZpbHRlcmJveCc7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHRoaXMuY29uZmlnLCB7XG4gICAgICBzaG93UmVzZXQ6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVycyxcbiAgICAgIHJlc2V0TGFiZWw6IHRoaXMuY29uZmlnLnJlc2V0RmlsdGVyc0xhYmVsLFxuICAgICAgc2hvd0FwcGx5QnV0dG9uOiAhdGhpcy5jb25maWcuc2VhcmNoT25DaGFuZ2VcbiAgICB9KSk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyQ29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMuZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgICAgdGhpcy5fZmlsdGVyQ29tcG9uZW50cyA9IFtdO1xuICAgICAgdGhpcy5fZmlsdGVycyA9IFtdO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgZmlsdGVycyBmcm9tIGNvbmZpZ3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnLmZpbHRlckNvbmZpZ3NbaV07XG4gICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKGNvbmZpZy50eXBlLCBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICAgICAgbmFtZTogYCR7dGhpcy5uYW1lfS5maWx0ZXIke2l9YCxcbiAgICAgICAgICBzdG9yZU9uQ2hhbmdlOiBmYWxzZSxcbiAgICAgICAgICBjb250YWluZXI6IGAuanMteWV4dC1maWx0ZXJib3gtZmlsdGVyJHtpfWAsXG4gICAgICAgICAgc2hvd1Jlc2V0OiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlcixcbiAgICAgICAgICByZXNldExhYmVsOiB0aGlzLmNvbmZpZy5yZXNldEZpbHRlckxhYmVsLFxuICAgICAgICAgIHNob3dFeHBhbmQ6IHRoaXMuY29uZmlnLmV4cGFuZCxcbiAgICAgICAgICBvbkNoYW5nZTogKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlckNoYW5nZShpLCBmaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgY29tcG9uZW50Lm1vdW50KCk7XG4gICAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2ZpbHRlcnNbaV0gPSBjb21wb25lbnQuZ2V0RmlsdGVyKCk7XG4gICAgICB0aGlzLl9zYXZlRmlsdGVyc1RvU3RvcmFnZSgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgYXBwbHkgYnV0dG9uXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5zZWFyY2hPbkNoYW5nZSkge1xuICAgICAgY29uc3QgYnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5jb25maWcuYXBwbHlCdXR0b25TZWxlY3Rvcik7XG5cbiAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgRE9NLm9uKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NhdmVGaWx0ZXJzVG9TdG9yYWdlKCk7XG4gICAgICAgICAgdGhpcy5fc2VhcmNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcmVzZXQgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnJlc2V0RmlsdGVycykge1xuICAgICAgRE9NLm9uKFxuICAgICAgICBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1GaWx0ZXJCb3gtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5yZXNldEZpbHRlcnMuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRGaWx0ZXJzICgpIHtcbiAgICB0aGlzLl9maWx0ZXJDb21wb25lbnRzLmZvckVhY2goZmlsdGVyID0+IGZpbHRlci5jbGVhck9wdGlvbnMoKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgdG8gY2hpbGQgZmlsdGVyIGNvbXBvbmVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hhbmdlZCBmaWx0ZXJcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlciBUaGUgbmV3IGZpbHRlclxuICAgKi9cbiAgb25GaWx0ZXJDaGFuZ2UgKGluZGV4LCBmaWx0ZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJzW2luZGV4XSA9IGZpbHRlcjtcbiAgICBpZiAodGhpcy5jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3NhdmVGaWx0ZXJzVG9TdG9yYWdlKCk7XG4gICAgICB0aGlzLl9zZWFyY2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmaWx0ZXIgY29tcG9uZW50cyBhbG9uZyB3aXRoIHRoaXMgY29tcG9uZW50XG4gICAqL1xuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2ZpbHRlckNvbXBvbmVudHMuZm9yRWFjaChjID0+IGMucmVtb3ZlKCkpO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCBmaWx0ZXJzIHRvIHN0b3JhZ2UgdG8gYmUgdXNlZCBpbiB0aGUgbmV4dCBzZWFyY2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlRmlsdGVyc1RvU3RvcmFnZSAoKSB7XG4gICAgY29uc3QgdmFsaWRGaWx0ZXJzID0gdGhpcy5fZmlsdGVycy5maWx0ZXIoZiA9PlxuICAgICAgZiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBmICE9PSBudWxsICYmXG4gICAgICBPYmplY3Qua2V5cyhmKS5sZW5ndGggPiAwKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5pc0R5bmFtaWMpIHtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZUZpZWxkSWRzID0gdGhpcy5jb25maWcuZmlsdGVyQ29uZmlncy5tYXAoY29uZmlnID0+IGNvbmZpZy5maWVsZElkKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkRmlsdGVyID0gRmFjZXQuZnJvbUZpbHRlcnMoYXZhaWxhYmxlRmllbGRJZHMsIC4uLnZhbGlkRmlsdGVycyk7XG4gICAgICB0aGlzLmNvcmUuc2V0RmFjZXRGaWx0ZXIodGhpcy5uYW1lLCBjb21iaW5lZEZpbHRlciB8fCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkRmlsdGVyID0gdmFsaWRGaWx0ZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgPyBGaWx0ZXIuYW5kKC4uLnZhbGlkRmlsdGVycylcbiAgICAgICAgOiB2YWxpZEZpbHRlcnNbMF07XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgY29tYmluZWRGaWx0ZXIgfHwge30pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2VhcmNoIHdpdGggYWxsIGZpbHRlcnMgaW4gc3RvcmFnZVxuICAgKi9cbiAgX3NlYXJjaCAoKSB7XG4gICAgY29uc3QgYWxsRmlsdGVycyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldEFsbChTdG9yYWdlS2V5cy5GSUxURVIpO1xuICAgIGNvbnN0IHRvdGFsRmlsdGVyID0gYWxsRmlsdGVycy5sZW5ndGggPiAxXG4gICAgICA/IEZpbHRlci5hbmQoLi4uYWxsRmlsdGVycylcbiAgICAgIDogYWxsRmlsdGVyc1swXTtcblxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuXG4gICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcblxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpO1xuICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl92ZXJ0aWNhbEtleSwge1xuICAgICAgaW5wdXQ6IHF1ZXJ5LFxuICAgICAgZmlsdGVyOiBKU09OLnN0cmluZ2lmeSh0b3RhbEZpbHRlciksXG4gICAgICBmYWNldEZpbHRlcjogSlNPTi5zdHJpbmdpZnkoZmFjZXRGaWx0ZXIpXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEZpbHRlck9wdGlvbnNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9lcnJvcnMvZXJyb3JzJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBzdXBwb3J0ZWQgY29udHJvbHNcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgU1VQUE9SVEVEX0NPTlRST0xTID0gW1xuICAnc2luZ2xlb3B0aW9uJyxcbiAgJ211bHRpb3B0aW9uJ1xuXTtcblxuY2xhc3MgRmlsdGVyT3B0aW9uc0NvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBjb250cm9sIHRvIGRpc3BsYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbCA9IGNvbmZpZy5jb250cm9sO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZmlsdGVyIG9wdGlvbnMgdG8gZGlzcGxheSB3aXRoIGNoZWNrZWQgc3RhdHVzXG4gICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIGJlIHVzZWQgaW4gdGhlIGxlZ2VuZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCAnRmlsdGVycyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGNoYW5nZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbkNoYW5nZSA9IGNvbmZpZy5vbkNoYW5nZSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHN0b3JlcyB0aGUgZmlsdGVyIHRvIHN0b3JhZ2Ugb24gZWFjaCBjaGFuZ2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnN0b3JlT25DaGFuZ2UgPSBjb25maWcuc3RvcmVPbkNoYW5nZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3cgYSBidXR0b24gdG8gcmVzZXQgdGhlIGN1cnJlbnQgZmlsdGVyIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd1Jlc2V0ID0gY29uZmlnLnNob3dSZXNldCB8fCBmYWxzZTtcbiAgICB0aGlzLnNob3dSZXNldCA9IHRoaXMuc2hvd1Jlc2V0ICYgdGhpcy5vcHRpb25zLmxlbmd0aCA+IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIHJlc2V0IGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldExhYmVsID0gY29uZmlnLnJlc2V0TGFiZWwgfHwgJ3Jlc2V0JztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGZhY2V0cyB0byBzaG93IGJlZm9yZSBkaXNwbGF5aW5nIFwic2hvdyBtb3JlXCIvXCJzaG93IGxlc3NcIlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxpbWl0ID0gY29uZmlnLnNob3dNb3JlTGltaXQgfHwgNTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIG1vcmUgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dNb3JlTGFiZWwgPSBjb25maWcuc2hvd01vcmVMYWJlbCB8fCAnc2hvdyBtb3JlJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYWJlbCB0byBzaG93IGZvciBkaXNwbGF5aW5nIGxlc3MgZmFjZXRzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNob3dMZXNzTGFiZWwgPSBjb25maWcuc2hvd0xlc3NMYWJlbCB8fCAnc2hvdyBsZXNzJztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGVuYWJsZSBoaWRpbmcgZXhjZXNzIGZhY2V0cyB3aXRoIGEgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmUgPSBjb25maWcuc2hvd01vcmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd01vcmU7XG4gICAgdGhpcy5zaG93TW9yZSA9IHRoaXMuc2hvd01vcmUgJiYgdGhpcy5vcHRpb25zLmxlbmd0aCA+IHRoaXMuc2hvd01vcmVMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFsbG93IGV4cGFuZGluZyBhbmQgY29sbGFwc2luZyB0aGUgZ3JvdXAgb2YgZmFjZXRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93RXhwYW5kID0gY29uZmlnLnNob3dFeHBhbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0V4cGFuZDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXkgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYXBwbGllZCBmaWx0ZXJzIHdoZW4gY29sbGFwc2VkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93TnVtYmVyQXBwbGllZCA9IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5zaG93TnVtYmVyQXBwbGllZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RvciB1c2VkIGZvciBvcHRpb25zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25TZWxlY3RvciA9IGNvbmZpZy5vcHRpb25TZWxlY3RvciB8fCAnLmpzLXlleHQtZmlsdGVyLW9wdGlvbic7XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5wcmV2aW91c09wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25maWcucHJldmlvdXNPcHRpb25zID0gSlNPTi5wYXJzZShjb25maWcucHJldmlvdXNPcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uZmlnLnByZXZpb3VzT3B0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRPcHRpb25zID0gY29uZmlnLnByZXZpb3VzT3B0aW9ucyB8fCBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNldERlZmF1bHRTZWxlY3RlZFZhbHVlcyh0aGlzLm9wdGlvbnMsIHNlbGVjdGVkT3B0aW9ucyk7XG4gIH1cblxuICBzZXREZWZhdWx0U2VsZWN0ZWRWYWx1ZXMgKG9wdGlvbnMsIHNlbGVjdGVkT3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLm1hcChvID0+ICh7XG4gICAgICAuLi5vLFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGhcbiAgICAgICAgPyBzZWxlY3RlZE9wdGlvbnMuaW5jbHVkZXMoby5sYWJlbClcbiAgICAgICAgOiBvLnNlbGVjdGVkXG4gICAgfSkpO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRDb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWR1Y2UoXG4gICAgICAobnVtU2VsZWN0ZWQsIG9wdGlvbikgPT4gb3B0aW9uLnNlbGVjdGVkID8gbnVtU2VsZWN0ZWQgKyAxIDogbnVtU2VsZWN0ZWQsXG4gICAgICAwKTtcbiAgfVxuXG4gIHZhbGlkYXRlICgpIHtcbiAgICBpZiAoIXRoaXMuY29udHJvbCB8fCAhU1VQUE9SVEVEX0NPTlRST0xTLmluY2x1ZGVzKHRoaXMuY29udHJvbCkpIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgICdGaWx0ZXJPcHRpb25zIHJlcXVpcmVzIGEgdmFsaWQgXCJjb250cm9sXCIgdG8gYmUgcHJvdmlkZWQnLFxuICAgICAgICAnRmlsdGVyT3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnRmlsdGVyT3B0aW9ucyBjb21wb25lbnQgcmVxdWlyZXMgb3B0aW9ucyB0byBiZSBwcm92aWRlZCcsXG4gICAgICAgICdGaWx0ZXJPcHRpb25zJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHNldCBvZiBvcHRpb25zLCBlYWNoIG9uZSByZXByZXNlbnRpbmcgYSBmaWx0ZXIgaW4gYSBzZWFyY2guXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlck9wdGlvbnNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgbGV0IHByZXZpb3VzT3B0aW9ucyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKHRoaXMubmFtZSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZGVsZXRlKHRoaXMubmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcG9uZW50IGNvbmZpZ1xuICAgICAqIEB0eXBlIHtGaWx0ZXJPcHRpb25zQ29uZmlnfVxuICAgICAqL1xuICAgIHRoaXMuY29uZmlnID0gbmV3IEZpbHRlck9wdGlvbnNDb25maWcoe1xuICAgICAgcHJldmlvdXNPcHRpb25zLFxuICAgICAgLi4uY29uZmlnXG4gICAgfSk7XG5cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgb3B0aW9uIGxpc3QgaXMgZXhwYW5kZWQgYW5kIHZpc2libGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGFuZGVkID0gdGhpcy5jb25maWcuc2hvd0V4cGFuZCA/IHNlbGVjdGVkQ291bnQgPiAwIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgYWxsIG9wdGlvbnMgYXJlIHNob3duLCBmYWxzZSBpZiBzb21lIGFyZSBoaWRkZW4gYmFzZWQgb24gY29uZmlnXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbGxTaG93biA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0ZpbHRlck9wdGlvbnMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXIsIGJhc2VkIG9uIHRoZSBjb250cm9sXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKGNvbmZpZykge1xuICAgIHJldHVybiBgY29udHJvbHMvZmlsdGVyb3B0aW9uc2A7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucztcbiAgICBpZiAodGhpcy5jb25maWcuc2hvd01vcmUgJiYgIXRoaXMuYWxsU2hvd24pIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zLnNsaWNlKDAsIHRoaXMuY29uZmlnLnNob3dNb3JlTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gdGhpcy5jb25maWcuZ2V0U2VsZWN0ZWRDb3VudCgpO1xuICAgIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICBzaG93UmVzZXQ6IHRoaXMuY29uZmlnLnNob3dSZXNldCAmJiBzZWxlY3RlZENvdW50ID4gMCxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgICAgYWxsU2hvd246IHRoaXMuYWxsU2hvd24sXG4gICAgICBzZWxlY3RlZENvdW50LFxuICAgICAgaXNTaW5nbGVPcHRpb246IHRoaXMuY29uZmlnLmNvbnRyb2wgPT09ICdzaW5nbGVvcHRpb24nLFxuICAgICAgb3B0aW9uc1xuICAgIH0pKTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIERPTS5kZWxlZ2F0ZShcbiAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsIGAueXh0LUZpbHRlck9wdGlvbnMtb3B0aW9uc2ApLFxuICAgICAgdGhpcy5jb25maWcub3B0aW9uU2VsZWN0b3IsXG4gICAgICAnY2xpY2snLFxuICAgICAgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVPcHRpb24ocGFyc2VJbnQoZXZlbnQudGFyZ2V0LmRhdGFzZXQuaW5kZXgpLCBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSB0aGlzLmNvbmZpZy5nZXRTZWxlY3RlZENvdW50KCk7XG5cbiAgICAvLyByZXNldCBidXR0b25cbiAgICBpZiAodGhpcy5jb25maWcuc2hvd1Jlc2V0ICYmIHNlbGVjdGVkQ291bnQgPiAwKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LUZpbHRlck9wdGlvbnMtcmVzZXQnKSxcbiAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgdGhpcy5jbGVhck9wdGlvbnMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gc2hvdyBtb3JlL2xlc3MgYnV0dG9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnNob3dNb3JlKSB7XG4gICAgICBET00ub24oXG4gICAgICAgIERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcueXh0LUZpbHRlck9wdGlvbnMtc2hvd1RvZ2dsZScpLFxuICAgICAgICAnY2xpY2snLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hbGxTaG93biA9ICF0aGlzLmFsbFNob3duO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZXhwYW5kIGJ1dHRvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zaG93RXhwYW5kKSB7XG4gICAgICBjb25zdCBsZWdlbmQgPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLnl4dC1GaWx0ZXJPcHRpb25zLWNsaWNrYWJsZUxlZ2VuZCcpO1xuICAgICAgRE9NLm9uKFxuICAgICAgICBsZWdlbmQsXG4gICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICBjbGljayA9PiB7XG4gICAgICAgICAgaWYgKGNsaWNrLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIERPTS5vbihcbiAgICAgICAgbGVnZW5kLFxuICAgICAgICAna2V5ZG93bicsXG4gICAgICAgIGtleSA9PiB7XG4gICAgICAgICAgaWYgKGtleS5rZXkgPT09ICcgJyB8fCBrZXkua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBrZXkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyT3B0aW9ucyAoKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnMubWFwKG8gPT4gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlTGlzdGVuZXJzICgpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZy5vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgX3VwZGF0ZU9wdGlvbiAoaW5kZXgsIHNlbGVjdGVkKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbnRyb2wgPT09ICdzaW5nbGVvcHRpb24nKSB7XG4gICAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gdGhpcy5jb25maWcub3B0aW9ucy5tYXAobyA9PiBPYmplY3QuYXNzaWduKHt9LCBvLCB7IHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcub3B0aW9uc1tpbmRleF0gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZy5vcHRpb25zW2luZGV4XSwgeyBzZWxlY3RlZCB9KTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgfVxuXG4gIGdldEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkRmlsdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9wdGlvbnNcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IERPTS5xdWVyeUFsbCh0aGlzLl9jb250YWluZXIsIHRoaXMuY29uZmlnLm9wdGlvblNlbGVjdG9yKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGUgPT4gZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnZmFsc2UnKSk7XG4gICAgdGhpcy5fYXBwbHlGaWx0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbmQgcmV0dXJuIHRoZSBGaWx0ZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEByZXR1cm5zIHtGaWx0ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRGaWx0ZXIgKCkge1xuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmNvbmZpZy5vcHRpb25zXG4gICAgICAuZmlsdGVyKG8gPT4gby5zZWxlY3RlZClcbiAgICAgIC5tYXAobyA9PiBvLmZpbHRlclxuICAgICAgICA/IG8uZmlsdGVyXG4gICAgICAgIDogRmlsdGVyLmVxdWFsKG8uZmllbGQsIG8udmFsdWUpKTtcblxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQodGhpcy5uYW1lLCB0aGlzLmNvbmZpZy5vcHRpb25zLmZpbHRlcihvID0+IG8uc2VsZWN0ZWQpLm1hcChvID0+IG8ubGFiZWwpKTtcbiAgICByZXR1cm4gZmlsdGVycy5sZW5ndGggPiAwXG4gICAgICA/IEZpbHRlci5ncm91cCguLi5maWx0ZXJzKVxuICAgICAgOiB7fTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUmFuZ2VGaWx0ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VGaWx0ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIHRvIGZpbHRlciBvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZCA9IGNvbmZpZy5maWVsZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZpbHRlciB2YWx1ZSBjaGFuZ2VzXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICBsZXQgbWluVmFsID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7dGhpcy5uYW1lfS5taW5gKTtcbiAgICBpZiAodHlwZW9mIG1pblZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pblZhbCA9IE51bWJlci5wYXJzZUludChtaW5WYWwpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgbGV0IG1heFZhbCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke3RoaXMubmFtZX0ubWF4YCk7XG4gICAgaWYgKHR5cGVvZiBtaW5WYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIucGFyc2VJbnQobWF4VmFsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmFuZ2UgcmVwcmVzZW50ZWRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmFuZ2UgPSB7XG4gICAgICBtaW46IG1pblZhbCB8fCBjb25maWcuaW5pdGlhbE1pbiB8fCAwLFxuICAgICAgbWF4OiBtYXhWYWwgfHwgY29uZmlnLmluaXRpYWxNYXggfHwgMTBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgZm9yIHRoZSByYW5nZSBjb250cm9sXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RpdGxlID0gY29uZmlnLnRpdGxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGxhYmVsIHRvIGRpc3BsYXkgZm9yIHRoZSBtaW4gaW5wdXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWluTGFiZWwgPSBjb25maWcubWluTGFiZWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25hbCBsYWJlbCB0byBkaXNwbGF5IGZvciB0aGUgbWF4IGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgdG8gcmVuZGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBsYXRlTmFtZSA9IGBjb250cm9scy9yYW5nZWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUmFuZ2VGaWx0ZXInO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB0aXRsZTogdGhpcy5fdGl0bGUsXG4gICAgICBtaW5MYWJlbDogdGhpcy5fbWluTGFiZWwsXG4gICAgICBtYXhMYWJlbDogdGhpcy5fbWF4TGFiZWwsXG4gICAgICBtaW5WYWx1ZTogdGhpcy5fcmFuZ2UubWluLFxuICAgICAgbWF4VmFsdWU6IHRoaXMuX3JhbmdlLm1heFxuICAgIH0pKTtcbiAgfVxuXG4gIG9uQ3JlYXRlICgpIHtcbiAgICBET00uZGVsZWdhdGUodGhpcy5fY29udGFpbmVyLCAnLmpzLXlleHQtcmFuZ2UnLCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVSYW5nZShldmVudC50YXJnZXQuZGF0YXNldC5rZXksIE51bWJlci5wYXJzZUludChldmVudC50YXJnZXQudmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldE1pbiAodmFsdWUpIHtcbiAgICB0aGlzLl91cGRhdGVSYW5nZSgnbWluJywgdmFsdWUpO1xuICB9XG5cbiAgc2V0TWF4ICh2YWx1ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtYXgnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCByYW5nZSBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByYW5nZSBrZXkgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUga2V5XG4gICAqL1xuICBfdXBkYXRlUmFuZ2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9yYW5nZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JhbmdlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICB0aGlzLnNldFN0YXRlKCk7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcigpO1xuICAgIGlmICh0aGlzLl9zdG9yZU9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvcmUuc2V0RmlsdGVyKHRoaXMubmFtZSwgZmlsdGVyKTtcbiAgICB9XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1pbmAsIHRoaXMuX3JhbmdlLm1pbik7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1heGAsIHRoaXMuX3JhbmdlLm1heCk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZShmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBmaWx0ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICogQHJldHVybnMge0ZpbHRlcn1cbiAgICovXG4gIF9idWlsZEZpbHRlciAoKSB7XG4gICAgcmV0dXJuIEZpbHRlci5pbmNsdXNpdmVSYW5nZSh0aGlzLl9maWVsZCwgdGhpcy5fcmFuZ2UubWluLCB0aGlzLl9yYW5nZS5tYXgpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBEYXRlRmlsdGVyQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vLi4vY29yZS9tb2RlbHMvZmlsdGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vZG9tL2RvbSc7XG5cbi8qKlxuICogQSBmaWx0ZXIgZm9yIGEgcmFuZ2Ugb2YgZGF0ZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcGkgZmllbGQgdGhpcyBmaWx0ZXIgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGQgPSBjb25maWcuZmllbGQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBmb3IgdGhlIGRhdGUgcmFuZ2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGl0bGUgPSBjb25maWcudGl0bGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1pbiBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21pbkxhYmVsID0gY29uZmlnLm1pbkxhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgbGFiZWwgdG8gc2hvdyBmb3IgdGhlIG1heCBkYXRlIGlucHV0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heExhYmVsID0gY29uZmlnLm1heExhYmVsIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgdXNlZCB3aGVuIGEgZGF0ZSBpcyBjaGFuZ2VkXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBjb25maWcub25DaGFuZ2UgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdG9yZXMgdGhlIGZpbHRlciB0byBzdG9yYWdlIG9uIGVhY2ggY2hhbmdlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZU9uQ2hhbmdlID0gY29uZmlnLnN0b3JlT25DaGFuZ2UgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGlzIGZpbHRlciByZXByZXNlbnRzIGFuIGV4Y2x1c2l2ZSByYW5nZSwgcmF0aGVyIHRoYW4gYW4gaW5jbHVzaXZlIG9uZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faXNFeGNsdXNpdmUgPSBjb25maWcuaXNFeGNsdXNpdmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGVtcGxhdGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wbGF0ZU5hbWUgPSBgY29udHJvbHMvZGF0ZWA7XG5cbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdG9kYXlTdHJpbmcgPSBgJHt0b2RheS5nZXRGdWxsWWVhcigpfS0ke2Ake3RvZGF5LmdldE1vbnRoKCkgKyAxfWAucGFkU3RhcnQoMiwgJzAnKX0tJHtgJHt0b2RheS5nZXREYXRlKCl9YC5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgY29uc3QgbWluRGF0ZSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke3RoaXMubmFtZX0ubWluYCk7XG4gICAgY29uc3QgbWF4RGF0ZSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke3RoaXMubmFtZX0ubWF4YCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBkYXRlIHJhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kYXRlID0ge1xuICAgICAgbWluOiBtaW5EYXRlIHx8IGNvbmZpZy5pbml0aWFsTWluIHx8IHRvZGF5U3RyaW5nLFxuICAgICAgbWF4OiBtYXhEYXRlIHx8IGNvbmZpZy5pbml0aWFsTWF4IHx8IHRvZGF5U3RyaW5nXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdEYXRlUmFuZ2VGaWx0ZXInO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB0aXRsZTogdGhpcy5fdGl0bGUsXG4gICAgICBtaW5MYWJlbDogdGhpcy5fbWluTGFiZWwsXG4gICAgICBtYXhMYWJlbDogdGhpcy5fbWF4TGFiZWwsXG4gICAgICBkYXRlTWluOiB0aGlzLl9kYXRlLm1pbixcbiAgICAgIGRhdGVNYXg6IHRoaXMuX2RhdGUubWF4XG4gICAgfSkpO1xuICB9XG5cbiAgb25DcmVhdGUgKCkge1xuICAgIERPTS5kZWxlZ2F0ZSh0aGlzLl9jb250YWluZXIsICcuanMteWV4dC1kYXRlJywgJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlUmFuZ2UoZXZlbnQudGFyZ2V0LmRhdGFzZXQua2V5LCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluIGRhdGUgdG8gdGhlIG9uZSBwcm92aWRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZSBEYXRlIHRvIHNldCBpbiB5eXl5LW1tLWRkIHN0cmluZyBmb3JtYXRcbiAgICovXG4gIHNldE1pbiAoZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVJhbmdlKCdtaW4nLCBkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heCBkYXRlIHRvIHRoZSBvbmUgcHJvdmlkZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGUgRGF0ZSB0byBzZXQgaW4geXl5eS1tbS1kZCBzdHJpbmcgZm9ybWF0XG4gICAqL1xuICBzZXRNYXggKGRhdGUpIHtcbiAgICB0aGlzLl91cGRhdGVSYW5nZSgnbWF4JywgZGF0ZSk7XG4gIH1cblxuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWlsZEZpbHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aGUgZGF0ZSB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyBkYXRlIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUmFuZ2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9kYXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZGF0ZSwgeyBba2V5XTogdmFsdWUgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSgpO1xuXG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5fYnVpbGRGaWx0ZXIoKTtcbiAgICBpZiAodGhpcy5fc3RvcmVPbkNoYW5nZSkge1xuICAgICAgdGhpcy5jb3JlLnNldEZpbHRlcih0aGlzLm5hbWUsIGZpbHRlcik7XG4gICAgfVxuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7dGhpcy5uYW1lfS5taW5gLCB0aGlzLl9kYXRlLm1pbik7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHt0aGlzLm5hbWV9Lm1heGAsIHRoaXMuX2RhdGUubWF4KTtcblxuICAgIHRoaXMuX29uQ2hhbmdlKGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGFwaSBmaWx0ZXIgd2l0aCB0aGUgY3VycmVudCBkYXRlIHN0YXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRGaWx0ZXIgKCkge1xuICAgIGlmICh0aGlzLl9kYXRlLm1pbiA9PT0gJycgfHwgdGhpcy5fZGF0ZS5tYXggPT09ICcnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0V4Y2x1c2l2ZVxuICAgICAgPyBGaWx0ZXIuZXhjbHVzaXZlUmFuZ2UodGhpcy5fZmllbGQsIHRoaXMuX2RhdGUubWluLCB0aGlzLl9kYXRlLm1heClcbiAgICAgIDogRmlsdGVyLmluY2x1c2l2ZVJhbmdlKHRoaXMuX2ZpZWxkLCB0aGlzLl9kYXRlLm1pbiwgdGhpcy5fZGF0ZS5tYXgpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBGYWNldHNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmNsYXNzIEZhY2V0c0NvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBhYm92ZSB0aGUgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGl0bGUgPSBjb25maWcudGl0bGUgfHwgJ0ZpbHRlcnMnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheSB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgbmV4dCB0byBlYWNoIGZhY2V0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG93Q291bnQgPSBjb25maWcuc2hvd0NvdW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dDb3VudDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRyaWdnZXIgYSBzZWFyY2ggb24gZWFjaCBjaGFuZ2UgdG8gYSBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaE9uQ2hhbmdlID0gY29uZmlnLnNlYXJjaE9uQ2hhbmdlIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIGJ1dHRvbiB0byByZXNldCBmb3IgZWFjaCBmYWNldCBncm91cFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGYWNldCA9IGNvbmZpZy5yZXNldEZhY2V0IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSByZXNldCBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGYWNldExhYmVsID0gY29uZmlnLnJlc2V0RmFjZXRMYWJlbCB8fCAncmVzZXQnO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc2hvdyBhIFwicmVzZXQgYWxsXCIgYnV0dG9uIHRvIHJlc2V0IGFsbCBmYWNldHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RmFjZXRzID0gY29uZmlnLnJlc2V0RmFjZXRzID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnJlc2V0RmFjZXRzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIHRvIHNob3cgZm9yIHRoZSBcInJlc2V0IGFsbFwiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNldEZhY2V0c0xhYmVsID0gY29uZmlnLnJlc2V0RmFjZXRzTGFiZWwgfHwgJ3Jlc2V0IGFsbCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IG51bWJlciBvZiBmYWNldHMgdG8gc2hvdyBiZWZvcmUgZGlzcGxheWluZyBcInNob3cgbW9yZVwiL1wic2hvdyBsZXNzXCJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmVMaW1pdCA9IGNvbmZpZy5zaG93TW9yZUxpbWl0IHx8IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBtb3JlIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TW9yZUxhYmVsID0gY29uZmlnLnNob3dNb3JlTGFiZWwgfHwgJ3Nob3cgbW9yZSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgdG8gc2hvdyBmb3IgZGlzcGxheWluZyBsZXNzIGZhY2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zaG93TGVzc0xhYmVsID0gY29uZmlnLnNob3dMZXNzTGFiZWwgfHwgJ3Nob3cgbGVzcyc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBlbmFibGUgaGlkaW5nIGV4Y2VzcyBmYWNldHMgaW4gZWFjaCBncm91cCB3aXRoIGEgXCJzaG93IG1vcmVcIi9cInNob3cgbGVzc1wiIGJ1dHRvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvd01vcmUgPSBjb25maWcuc2hvd01vcmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd01vcmU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvdyBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmcgZWFjaCBncm91cCBvZiBmYWNldHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmV4cGFuZCA9IGNvbmZpZy5leHBhbmQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuZXhwYW5kO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGlzcGxheSB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhcHBsaWVkIGZpbHRlcnMgd2hlbiBjb2xsYXBzZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dOdW1iZXJBcHBsaWVkID0gY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dOdW1iZXJBcHBsaWVkO1xuXG4gICAgLyoqXG4gICAgICogVGV4dCB0byBkaXNwbGF5IG9uIHRoZSBhcHBseSBidXR0b25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlMYWJlbCA9IGNvbmZpZy5hcHBseUxhYmVsIHx8ICdhcHBseSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbHMgdG8gdXNlIGZvciBlYWNoIGZpZWxkLiBFYWNoIHR5cGUgb2YgZmlsdGVyIGhhcyBhIGRlZmF1bHRcbiAgICAgKiAkZXEgOiBtdWx0aW9wdGlvbiAoY2hlY2tib3gpXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkQ29udHJvbHMgPSBjb25maWcuZmllbGRDb250cm9scyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RvciBvZiB0aGUgYXBwbHkgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlCdXR0b25TZWxlY3RvciA9IGNvbmZpZy5hcHBseUJ1dHRvblNlbGVjdG9yIHx8IG51bGw7XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwbGF5cyBhIHNldCBvZiBkeW5hbWljIGZpbHRlcnMgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZFxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY2V0c0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBGYWNldHNDb25maWcoY29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0aWNhbCBrZXkgZm9yIHRoZSBzZWFyY2hcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVydGljYWxLZXkgPSBjb25maWcudmVydGljYWxLZXk7XG5cbiAgICAvLyBjb25maWcudmVydGljYWxLZXkgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RvciBvZiB0aGUgYXBwbHkgYnV0dG9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FwcGx5QnV0dG9uU2VsZWN0b3IgPSBjb25maWcuYXBwbHlCdXR0b25TZWxlY3RvciB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgcmVmZXJlbmNlIGZvciB0aGUgZGF0YSBzdG9yYWdlIHRvIGxpc3RlbiBmb3IgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5EWU5BTUlDX0ZJTFRFUlM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIGJveCB0aGF0IGRpc3BsYXlzIHRoZSBkeW5hbWljIGZpbHRlcnNcbiAgICAgKiBAdHlwZSB7RmlsdGVyQm94Q29tcG9uZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmlsdGVyYm94ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdGYWNldHMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoKSB7XG4gICAgcmV0dXJuICdmaWx0ZXJzL2ZhY2V0cyc7XG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIGlmICh0aGlzLl9maWx0ZXJib3gpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmJveC5yZW1vdmUoKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICB0aGlzLmNvcmUuZW5hYmxlRHluYW1pY0ZpbHRlcnMoKTtcblxuICAgIGlmICh0aGlzLl9maWx0ZXJib3gpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmJveC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBsZXQgeyBmaWx0ZXJzIH0gPSB0aGlzLl9zdGF0ZS5nZXQoKTtcblxuICAgIGlmICghZmlsdGVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZpbHRlcnMgPSBmaWx0ZXJzLm1hcChmID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBmLCB7XG4gICAgICAgIHR5cGU6ICdGaWx0ZXJPcHRpb25zJyxcbiAgICAgICAgY29udHJvbDogdGhpcy5jb25maWcuZmllbGRDb250cm9sc1tmLmZpZWxkSWRdIHx8ICdtdWx0aW9wdGlvbidcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZmlsdGVyYm94ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmNyZWF0ZShcbiAgICAgICdGaWx0ZXJCb3gnLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcsIHtcbiAgICAgICAgcGFyZW50Q29udGFpbmVyOiB0aGlzLl9jb250YWluZXIsXG4gICAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uZmlsdGVyYm94YCxcbiAgICAgICAgY29udGFpbmVyOiAnLmpzLXl4dC1GYWNldHMnLFxuICAgICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICAgIHJlc2V0RmlsdGVyOiB0aGlzLmNvbmZpZy5yZXNldEZhY2V0LFxuICAgICAgICByZXNldEZpbHRlcnM6IHRoaXMuY29uZmlnLnJlc2V0RmFjZXRzLFxuICAgICAgICByZXNldEZpbHRlckxhYmVsOiB0aGlzLmNvbmZpZy5yZXNldEZhY2V0TGFiZWwsXG4gICAgICAgIHJlc2V0RmlsdGVyc0xhYmVsOiB0aGlzLmNvbmZpZy5yZXNldEZhY2V0c0xhYmVsLFxuICAgICAgICBpc0R5bmFtaWM6IHRydWUsXG4gICAgICAgIGZpbHRlcnNcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX2ZpbHRlcmJveC5tb3VudCgpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBHZW9Mb2NhdGlvbkNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi8uLi8uLi9jb3JlL21vZGVscy9maWx0ZXInO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5cbmNvbnN0IE1FVEVSU19QRVJfTUlMRSA9IDE2MDkuMzQ0O1xuXG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgLyoqXG4gICAqIFRoZSByYWRpdXMsIGluIG1pbGVzLCBhcm91bmQgdGhlIHVzZXIncyBsb2NhdGlvbiB0byBmaW5kIHJlc3VsdHMuXG4gICAqIElmIGxvY2F0aW9uIGFjY3VyYWN5IGlzIGxvdywgYSBsYXJnZXIgcmFkaXVzIG1heSBiZSB1c2VkIGF1dG9tYXRpY2FsbHlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHJhZGl1czogNTAsXG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJ0aWNhbCBrZXkgdG8gdXNlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB2ZXJ0aWNhbEtleTogbnVsbCxcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgc3VibWl0cyBhIHNlYXJjaCB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2VhcmNoT25DaGFuZ2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGl0bGU6ICdMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBsYWJlbDogJ0xvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIGljb24gdXJsIHRvIHNob3cgaW4gdGhlIGdlbyBidXR0b25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdlb0J1dHRvbkljb246ICcnLFxuXG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBzaG93IGluIHRoZSBnZW8gYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZW9CdXR0b25UZXh0OiAnVXNlIE15IExvY2F0aW9uJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyB3aGVuIGdlb2xvY2F0aW9uIGlzIGVuYWJsZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGVuYWJsZWRUZXh0OiAnQ3VycmVudCBMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIHNob3cgd2hlbiBsb2FkaW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGxvYWRpbmdUZXh0OiAnRmluZGluZyBZb3VyIExvY2F0aW9uLi4uJyxcblxuICAvKipcbiAgICogVGhlIHRleHQgdG8gc2hvdyBpZiB0aGUgdXNlcidzIGxvY2F0aW9uIGNhbm5vdCBiZSBmb3VuZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZXJyb3JUZXh0OiAnQ291bGQgTm90IEZpbmQgWW91ciBMb2NhdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBDU1Mgc2VsZWN0b3Igb2YgdGhlIHRvZ2dsZSBidXR0b25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJ1dHRvblNlbGVjdG9yOiAnLmpzLXl4dC1HZW9Mb2NhdGlvbkZpbHRlci1idXR0b24nLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIHNlbGVjdG9yIG9mIHRoZSBxdWVyeSBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgaW5wdXRTZWxlY3RvcjogJy5qcy15eHQtR2VvTG9jYXRpb25GaWx0ZXItaW5wdXQnXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBidXR0b24gdGhhdCB3aGVuIGNsaWNrZWQgYWRkcyBhIHN0YXRpYyBmaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9Mb2NhdGlvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcih7IC4uLkRFRkFVTFRfQ09ORklHLCAuLi5jb25maWcgfSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBzdHJpbmcgdG8gdXNlIGZvciB0aGUgaW5wdXQgYm94LCBwcm92aWRlZCB0byB0ZW1wbGF0ZSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKGAke1N0b3JhZ2VLZXlzLlFVRVJZfS4ke3RoaXMubmFtZX1gKSB8fCAnJztcbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWAsIHEgPT4ge1xuICAgICAgdGhpcy5xdWVyeSA9IHE7XG4gICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIHRvIHVzZSBmb3IgdGhlIGN1cnJlbnQgcXVlcnlcbiAgICAgKiBAdHlwZSB7RmlsdGVyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBKU09OLnBhcnNlKHRoaXMuZmlsdGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIGAke1N0b3JhZ2VLZXlzLkZJTFRFUn0uJHt0aGlzLm5hbWV9YCwgZiA9PiB7IHRoaXMuZmlsdGVyID0gZjsgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnR2VvTG9jYXRpb25GaWx0ZXInO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRUZW1wbGF0ZU5hbWUgKCkge1xuICAgIHJldHVybiAnY29udHJvbHMvZ2VvbG9jYXRpb24nO1xuICB9XG5cbiAgc2V0U3RhdGUgKGRhdGEpIHtcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSAnJztcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLl9jb25maWcuZW5hYmxlZFRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLmdlb0xvYWRpbmcpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5fY29uZmlnLmxvYWRpbmdUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5nZW9FcnJvcikge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLl9jb25maWcuZXJyb3JUZXh0O1xuICAgIH1cbiAgICBzdXBlci5zZXRTdGF0ZSh7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdGl0bGU6IHRoaXMuX2NvbmZpZy50aXRsZSxcbiAgICAgIGdlb0VuYWJsZWQ6IHRoaXMuX2VuYWJsZWQsXG4gICAgICBxdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIGxhYmVsVGV4dDogdGhpcy5fY29uZmlnLmxhYmVsLFxuICAgICAgZW5hYmxlZFRleHQ6IHRoaXMuX2NvbmZpZy5lbmFibGVkVGV4dCxcbiAgICAgIGxvYWRpbmdUZXh0OiB0aGlzLl9jb25maWcubG9hZGluZ1RleHQsXG4gICAgICBlcnJvclRleHQ6IHRoaXMuX2NvbmZpZy5lcnJvclRleHQsXG4gICAgICBnZW9CdXR0b25JY29uOiB0aGlzLl9jb25maWcuZ2VvQnV0dG9uSWNvbixcbiAgICAgIGdlb1ZhbHVlOiB0aGlzLl9lbmFibGVkIHx8IGRhdGEuZ2VvTG9hZGluZyB8fCBkYXRhLmdlb0Vycm9yID8gJycgOiB0aGlzLnF1ZXJ5LFxuICAgICAgZ2VvUGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgZ2VvQnV0dG9uVGV4dDogdGhpcy5fY29uZmlnLmdlb0J1dHRvblRleHRcbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0QXV0b0NvbXBsZXRlKHRoaXMuX2NvbmZpZy5pbnB1dFNlbGVjdG9yKTtcbiAgICBET00ub24odGhpcy5fY29uZmlnLmJ1dHRvblNlbGVjdG9yLCAnY2xpY2snLCAoKSA9PiB0aGlzLl90b2dnbGVHZW9GaWx0ZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIHdpcmUgdXAgb3VyIGF1dG8gY29tcGxldGUgb24gYW4gaW5wdXQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRvIGJpbmQgb3VyIGF1dG8gY29tcGxldGUgY29tcG9uZW50IHRvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdEF1dG9Db21wbGV0ZSAoaW5wdXRTZWxlY3Rvcikge1xuICAgIGlmICh0aGlzLl9hdXRvY29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdXRvY29tcGxldGUgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuY3JlYXRlKCdBdXRvQ29tcGxldGUnLCB7XG4gICAgICBwYXJlbnRDb250YWluZXI6IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgIG5hbWU6IGAke3RoaXMubmFtZX0uYXV0b2NvbXBsZXRlYCxcbiAgICAgIGlzRmlsdGVyU2VhcmNoOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiAnLmpzLXl4dC1HZW9Mb2NhdGlvbkZpbHRlci1hdXRvY29tcGxldGUnLFxuICAgICAgb3JpZ2luYWxRdWVyeTogdGhpcy5xdWVyeSxcbiAgICAgIG9yaWdpbmFsRmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgIGlucHV0RWw6IGlucHV0U2VsZWN0b3IsXG4gICAgICB2ZXJ0aWNhbEtleTogdGhpcy5fdmVydGljYWxLZXksXG4gICAgICBvblN1Ym1pdDogKHF1ZXJ5LCBmaWx0ZXIpID0+IHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmZpbHRlciA9IEZpbHRlci5mcm9tUmVzcG9uc2UoZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fc2F2ZURhdGFUb1N0b3JhZ2UocXVlcnksIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHN0YXRpYyBmaWx0ZXIgcmVwcmVzZW50aW5nIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90b2dnbGVHZW9GaWx0ZXIgKCkge1xuICAgIGlmICghbmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZ2VvRXJyb3I6IHRydWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZ2VvTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgIHBvc2l0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9idWlsZEZpbHRlcihwb3NpdGlvbik7XG4gICAgICAgICAgdGhpcy5fc2F2ZURhdGFUb1N0b3JhZ2UoJycsIGZpbHRlciwgcG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoYCR7U3RvcmFnZUtleXMuUVVFUll9LiR7dGhpcy5uYW1lfWApO1xuICAgICAgICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5kZWxldGUoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGdlb0Vycm9yOiB0cnVlIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgcHJvdmlkZWQgZmlsdGVyIHVuZGVyIHRoaXMgY29tcG9uZW50J3MgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHRvIHNhdmVcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlciBUaGUgZmlsdGVyIHRvIHNhdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBzYXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZURhdGFUb1N0b3JhZ2UgKHF1ZXJ5LCBmaWx0ZXIsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLnNldChgJHtTdG9yYWdlS2V5cy5RVUVSWX0uJHt0aGlzLm5hbWV9YCwgcXVlcnkpO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoYCR7U3RvcmFnZUtleXMuRklMVEVSfS4ke3RoaXMubmFtZX1gLCBmaWx0ZXIpO1xuICAgIHRoaXMuY29yZS5zZXRGaWx0ZXIodGhpcy5uYW1lLCBmaWx0ZXIpO1xuXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuR0VPTE9DQVRJT04sIHtcbiAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsXG4gICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSxcbiAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3lcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuc2VhcmNoT25DaGFuZ2UpIHtcbiAgICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRklMVEVSKTtcbiAgICAgIGxldCB0b3RhbEZpbHRlciA9IGZpbHRlcnNbMF07XG4gICAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRvdGFsRmlsdGVyID0gRmlsdGVyLmFuZCguLi5maWx0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlYXJjaFF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpIHx8ICcnO1xuICAgICAgY29uc3QgZmFjZXRGaWx0ZXIgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRBbGwoU3RvcmFnZUtleXMuRkFDRVRfRklMVEVSKVswXTtcblxuICAgICAgdGhpcy5jb3JlLnBlcnNpc3RlbnRTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmRlbGV0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKTtcbiAgICAgIHRoaXMuY29yZS52ZXJ0aWNhbFNlYXJjaCh0aGlzLl9jb25maWcudmVydGljYWxLZXksIHtcbiAgICAgICAgaW5wdXQ6IHNlYXJjaFF1ZXJ5LFxuICAgICAgICBmaWx0ZXI6IEpTT04uc3RyaW5naWZ5KHRvdGFsRmlsdGVyKSxcbiAgICAgICAgZmFjZXRGaWx0ZXI6IEpTT04uc3RyaW5naWZ5KGZhY2V0RmlsdGVyKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgcG9zaXRpb24sIGNvbnN0cnVjdCBhIEZpbHRlciBvYmplY3RcbiAgICogQHBhcmFtIHtQb3N0aXRpb259IHBvc2l0aW9uIFRoZSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7RmlsdGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkRmlsdGVyIChwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3kgfSA9IHBvc2l0aW9uLmNvb3JkcztcbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heChhY2N1cmFjeSwgdGhpcy5fY29uZmlnLnJhZGl1cyAqIE1FVEVSU19QRVJfTUlMRSk7XG4gICAgcmV0dXJuIEZpbHRlci5wb3NpdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlLCByYWRpdXMpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBEaXJlY3RBbnN3ZXJDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcblxuLyoqXG4gKiBFdmVudFR5cGVzIGFyZSBleHBsaWNpdCBzdHJpbmdzIGRlZmluZWRcbiAqIGZvciB3aGF0IHRoZSBzZXJ2ZXIgZXhwZWN0cyBmb3IgYW5hbHl0aWNzLlxuICpcbiAqIEBlbnVtXG4gKi9cbmNvbnN0IEV2ZW50VHlwZXMgPSB7XG4gIFRIVU1CU19VUDogJ1RIVU1CU19VUCcsXG4gIFRIVU1CU19ET1dOOiAnVEhVTUJTX0RPV04nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RBbnN3ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30sIHN5c3RlbUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoY29uZmlnLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjaWV2ZSB1cGRhdGVzIGZyb20gc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGluZGV4XG4gICAgICogQHR5cGUge1N0b3JhZ2VLZXl9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLkRJUkVDVF9BTlNXRVI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB1c2VkIGZvciBzdWJtaXR0aW5nIHRoZSBmZWVkYmFja1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fZm9ybUVsID0gY29uZmlnLmZvcm1FbCB8fCAnLmpzLWRpcmVjdEFuc3dlci1mZWVkYmFjay1mb3JtJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBgdGh1bWJzIHVwYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNVcFNlbGVjdG9yID0gY29uZmlnLnRodW1ic1VwU2VsZWN0b3IgfHwgJy5qcy1kaXJlY3RBbnN3ZXItdGh1bWJVcCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYHRodW1icyBkb3duYCBjc3Mgc2VsZWN0b3IgdG8gYmluZCB1aSBpbnRlcmFjdGlvbiB0byBmb3IgcmVwb3J0aW5nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IgPSBjb25maWcudGh1bWJzRG93blNlbGVjdG9yIHx8ICcuanMtZGlyZWN0QW5zd2VyLXRodW1iRG93bic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzcGxheSB0ZXh0IGZvciB0aGUgVmlldyBEZXRhaWxzIGNsaWNrIHRvIGFjdGlvbiBsaW5rXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl92aWV3RGV0YWlsc1RleHQgPSBjb25maWcudmlld0RldGFpbHNUZXh0IHx8ICdWaWV3IERldGFpbHMnO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0RpcmVjdEFuc3dlcic7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvZGlyZWN0YW5zd2VyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBiZWZvcmVNb3VudCwgb25seSBkaXNwbGF5IHRoZSBkaXJlY3QgYW5zd2VyIGNvbXBvbmVudCBpZiBpdCBoYXMgZGF0YVxuICAgKi9cbiAgYmVmb3JlTW91bnQgKCkge1xuICAgIGlmICghdGhpcy5oYXNTdGF0ZSgnYW5zd2VyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBET00gaXMgY29uc3RydWN0ZWQsXG4gICAqIHdlIHdhbnQgdG8gd2lyZSB1cCB0aGUgYmVoYXZpb3IgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIHF1YWxpdHkgZmVlZGJhY2sgcmVwb3J0aW5nICh0aHVtYnN1cC9kb3duKVxuICAgKi9cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gQXZvaWQgYmluZGluZ3MgaWYgdGhlIGZlZWRiYWNrIGhhcyBwcmV2aW91c2x5IGJlZW4gc3VibWl0dGVkXG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoJ2ZlZWRiYWNrU3VibWl0dGVkJykgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZvciBXQ0FHIGNvbXBsaWFuY2UsIHRoZSBmZWVkYmFjayBzaG91bGQgYmUgYSBzdWJtaXR0YWJsZSBmb3JtXG4gICAgRE9NLm9uKHRoaXMuX2Zvcm1FbCwgJ3N1Ym1pdCcsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybUVsID0gZS50YXJnZXQ7XG4gICAgICBsZXQgY2hlY2tlZFZhbHVlID0gRE9NLnF1ZXJ5KGZvcm1FbCwgJ2lucHV0OmNoZWNrZWQnKS52YWx1ZSA9PT0gJ3RydWUnO1xuXG4gICAgICB0aGlzLnJlcG9ydFF1YWxpdHkoY2hlY2tlZFZhbHVlKTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAnZmVlZGJhY2tTdWJtaXR0ZWQnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIElzIHRoaXMgYWN0dWFsbHkgbmVjZXNzYXJ5PyBJIGd1ZXNzIGl0J3Mgb25seSBuZWNlc3NhcnkgaWYgdGhlXG4gICAgLy8gc3VibWl0IGJ1dHRvbiBpcyBoaWRkZW4uXG4gICAgRE9NLm9uKHRoaXMuX3RodW1ic1VwU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICAgIERPTS5vbih0aGlzLl90aHVtYnNEb3duU2VsZWN0b3IsICdjbGljaycsICgpID0+IHsgRE9NLnRyaWdnZXIodGhpcy5fZm9ybUVsLCAnc3VibWl0Jyk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZVN0YXRlIGVuYWJsZXMgZm9yIHBhcnRpYWwgdXBkYXRlcyAodGhlIGRlbHRhIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3KVxuICAgKiBAdHlwZSB7b2JqZWN0fSBUaGUgbmV3IHN0YXRlIHRvIGFwcGx5IHRvIHRoZSBvbGRcbiAgICovXG4gIHVwZGF0ZVN0YXRlIChzdGF0ZSA9IHt9KSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCksIHN0YXRlKTtcbiAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIGV2ZW50T3B0aW9uczogdGhpcy5ldmVudE9wdGlvbnMoZGF0YSksXG4gICAgICB2aWV3RGV0YWlsc1RleHQ6IHRoaXMuX3ZpZXdEZXRhaWxzVGV4dFxuICAgIH0pKTtcbiAgfVxuXG4gIGV2ZW50T3B0aW9ucyAoZGF0YSkge1xuICAgIGlmICghZGF0YSB8fCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogZGF0YS5yZWxhdGVkSXRlbS52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgc2VhcmNoZXI6ICdVTklWRVJTQUwnLFxuICAgICAgZW50aXR5SWQ6IGRhdGEucmVsYXRlZEl0ZW0uZGF0YS5pZCxcbiAgICAgIGN0YUxhYmVsOiB0aGlzLl92aWV3RGV0YWlsc1RleHQudG9VcHBlckNhc2UoKS5yZXBsYWNlKCcgJywgJ18nKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlcG9ydFF1YWxpdHkgd2lsbCBzZW5kIHRoZSBxdWFsaXR5IGZlZWRiYWNrIHRvIGFuYWx5dGljc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzR29vZCB0cnVlIGlmIHRoZSBhbnN3ZXIgaXMgd2hhdCB5b3Ugd2VyZSBsb29raW5nIGZvclxuICAgKi9cbiAgcmVwb3J0UXVhbGl0eSAoaXNHb29kKSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gaXNHb29kID09PSB0cnVlID8gRXZlbnRUeXBlcy5USFVNQlNfVVAgOiBFdmVudFR5cGVzLlRIVU1CU19ET1dOO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KGV2ZW50VHlwZSlcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgJ2RpcmVjdEFuc3dlcic6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBSZXN1bHRzSXRlbUNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1Db25maWcpO1xuXG4gICAgLyoqXG4gICAgICogdmVydGljYWxDb25maWdJZCB1c2VkIGZvciBhbmFseXRpY3MgYW5kIHBhc3NlZCB0byBjaGlsZHJlblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbENvbmZpZ0lkID0gb3B0cy52ZXJ0aWNhbENvbmZpZ0lkO1xuXG4gICAgLyoqXG4gICAgICogaXNVbml2ZXJzYWwgaXMgdXNlZCBmb3IgYW5hbHl0aWNzIGFuZCBwYXNzZWQgdG8gY2hpbGRyZW4gYW5kIGlzIHNldCB0b1xuICAgICAqIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQgYnkgdGhlIFVuaXZlcnNhbFJlc3VsdHNDb21wb25lbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzVW5pdmVyc2FsID0gb3B0cy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdSZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2l0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIHRvIGNvbnN0cnVjdCB0aGUgZXZlbnRPcHRpb25zIG9iamVjdCBmb3IgdGhlIHRpdGxlIGxpbmtcbiAgICogQHBhcmFtIGVudGl0eUlkIFRoZSBJRCBvZiB0aGUgcmVzdWx0IGl0ZW0sIGlmIHByZXNlbnRcbiAgICogQHBhcmFtIHVybCBUaGUgdXJsIG9mIHRoZSByZXN1bHQgaXRlbSwgaWYgcHJlc2VudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZXZlbnRPcHRpb25zIChlbnRpdHlJZCwgdXJsKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICBzZWFyY2hlcjogdGhpcy5faXNVbml2ZXJzYWwgPyAnVU5JVkVSU0FMJyA6ICdWRVJUSUNBTCdcbiAgICB9O1xuXG4gICAgaWYgKGVudGl0eUlkKSB7XG4gICAgICBvcHRpb25zLmVudGl0eUlkID0gZW50aXR5SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXNzZXMgZXZlbnRPcHRpb25zIHRvIHRoZSB2aWV3TW9kZWxcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtSZXN1bHRzSXRlbUNvbXBvbmVudH1cbiAgICovXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucyhkYXRhLmlkLCBkYXRhLmxpbmspXG4gICAgfSkpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50ICovXG5cbmltcG9ydCBSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHNpdGVtY29tcG9uZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBleHRlbmRzIFJlc3VsdHNJdGVtQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihvcHRzLCBzeXN0ZW1Db25maWcpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ0xvY2F0aW9uUmVzdWx0c0l0ZW1Db21wb25lbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL2xvY2F0aW9ucmVzdWx0c2l0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgKi9cblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50IGV4dGVuZHMgUmVzdWx0c0l0ZW1Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbUNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvZXZlbnRyZXN1bHRzaXRlbSc7XG4gIH1cblxuICBzdGF0aWMgYXJlRHVwbGljYXRlTmFtZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQgKi9cblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBleHRlbmRzIFJlc3VsdHNJdGVtQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3Blb3BsZXJlc3VsdHNpdGVtJztcbiAgfVxuXG4gIHN0YXRpYyBhcmVEdXBsaWNhdGVOYW1lc0FsbG93ZWQgKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBNYXBQcm92aWRlciAqL1xuXG4vKipcbiAqIEEgTWFwUHJvdmlkZXIgaXMgYW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGF0IHNob3VsZCBiZSBpbXBsZW1lbnRlZFxuICogaW4gb3JkZXIgdG8gaW50ZWdyYXRlIHdpdGggYSBUaGlyZCBQYXJ0eSBNYXAgcHJvdmlkZXIgZm9yXG4gKiBpbnRlcmFjdGl2ZSBtYXBzLiBNYXBQcm92aWRlcnMgYXJlIHVzZWQgYnkgdGhlIE1hcENvbXBvbmVudC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGV4dGVuZCB0aGlzIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwUHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIEtleSB1c2VkIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBtYXAgcHJvdmlkZXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLCBkZWZhdWx0cyB0byAxNFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fem9vbSA9IGNvbmZpZy56b29tIHx8IDE0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29vcmRpbmF0ZXMgdG8gZGlzcGxheSBpZiB0aGVyZSBhcmUgbm8gcmVzdWx0cyByZXR1cm5lZFxuICAgICAqIE9ubHkgdXNlZCBpZiBzaG93RW1wdHlNYXAgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX2RlZmF1bHRQb3NpdGlvbiA9IGNvbmZpZy5kZWZhdWx0UG9zaXRpb24gfHwgeyBsYXQ6IDM3LjA5MDIsIGxuZzogLTk1LjcxMjkgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gZW1wdHkgbWFwIHNob3VsZCBiZSBzaG93biB3aGVuIHRoZXJlIGFyZSBubyByZXN1bHRzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fc2hvd0VtcHR5TWFwID0gY29uZmlnLnNob3dFbXB0eU1hcCB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIG1hcCBpbnN0YW5jZSwgY3JlYXRlZCBieSB0aGUgZXh0ZXJuYWwgbGliLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbWFwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSBib29sZWFuIHRyYWNraW5nIHdoZXRoZXIgb3Igbm90IHRoZSBleHRlcm5hbCBKUyBsaWJyYXJ5IGlzIGxvYWRlZCAoc2VlIFRPRE8gYmVsb3cpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGEgcGluIGlzIGNsaWNrZWQuIFRoZSBjbGlja2VkIGl0ZW0ocykgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fb25QaW5DbGljayA9IGNvbmZpZy5vblBpbkNsaWNrIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgSmF2YXNjcmlwdCBpcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fb25Mb2FkZWQgPSBjb25maWcub25Mb2FkZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VzdG9tIGNvbmZpZ3VyYXRpb24gb3ZlcnJpZGUgdG8gdXNlIGZvciB0aGUgbWFwIG1hcmtlcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX3BpbkNvbmZpZyA9IHR5cGVvZiBjb25maWcucGluID09PSAnZnVuY3Rpb24nID8gY29uZmlnLnBpbiA6IE9iamVjdC5hc3NpZ24oTWFwUHJvdmlkZXIuREVGQVVMVF9QSU5fQ09ORklHLCBjb25maWcucGluKTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gY29sbGFwc2UgcGlucyBhdCB0aGUgc2FtZSBsYXQvbG5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fY29sbGFwc2VQaW5zID0gY29uZmlnLmNvbGxhcHNlUGlucyB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHRvIHVzZSBmb3IgdGhlIG1hcCBtYXJrZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIFRPRE8oYmlsbHkpIENyZWF0ZSBhIGNvbmZpZ3VyYXRpb24gbW9kZWxcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QSU5fQ09ORklHICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjoge1xuICAgICAgICBhbmNob3I6IG51bGwsIC8vIGUuZy4geyB4OiAxLCB5OiAxIH1cbiAgICAgICAgc3ZnOiBudWxsLFxuICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgIHNjYWxlZFNpemU6IG51bGwgLy8gZS5nLiB7IHc6IDIwLCBoOiAyMCB9XG4gICAgICB9LFxuICAgICAgbGFiZWxUeXBlOiAnbnVtZXJpYydcbiAgICB9O1xuICB9XG5cbiAgb25Mb2FkZWQgKGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX29uTG9hZGVkID0gY2I7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICB9XG4gIH1cblxuICBpc0xvYWRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICB9XG5cbiAgbG9hZEpTICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgTWV0aG9kOiBsb2FkSlMnKTtcbiAgfVxuXG4gIGluaXQgKG1hcERhdGEpIHtcbiAgICAvLyBUT0RPKGJpbGx5KSBUaGlzIHNob3VsZCBiZSBiYXNlZCBvZmYgYSBwcm9taXNlIHRoYXQgZ2V0cyBjcmVhdGVkIGZyb20gbG9hZEpTXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIE1ldGhvZDogaW5pdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbGlzdCBvZiBtYXJrZXJzLCBjb21iaW5lIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBsYXQvbG5nIGludG8gYSBzaW5nbGUgbWFya2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IG1hcmtlcnMgVGhlIG1hcmtlcnMgdG8gY29sbGFwc2VcbiAgICovXG4gIF9jb2xsYXBzZU1hcmtlcnMgKG1hcmtlcnMpIHtcbiAgICBjb25zdCBsb2NhdGlvblRvSXRlbSA9IHt9O1xuICAgIG1hcmtlcnMuZm9yRWFjaChtID0+IHtcbiAgICAgIGxvY2F0aW9uVG9JdGVtW2Ake20ubGF0aXR1ZGV9JHttLmxvbmdpdHVkZX1gXVxuICAgICAgICA/IGxvY2F0aW9uVG9JdGVtW2Ake20ubGF0aXR1ZGV9JHttLmxvbmdpdHVkZX1gXS5wdXNoKG0pXG4gICAgICAgIDogbG9jYXRpb25Ub0l0ZW1bYCR7bS5sYXRpdHVkZX0ke20ubG9uZ2l0dWRlfWBdID0gW21dO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY29sbGFwc2VkTWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IFssIG1hcmtlcnNdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2F0aW9uVG9JdGVtKSkge1xuICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXIgPSB7XG4gICAgICAgICAgaXRlbTogbWFya2Vycy5tYXAobSA9PiBtLml0ZW0pLFxuICAgICAgICAgIGxhYmVsOiBtYXJrZXJzLmxlbmd0aCxcbiAgICAgICAgICBsYXRpdHVkZTogbWFya2Vyc1swXS5sYXRpdHVkZSxcbiAgICAgICAgICBsb25naXR1ZGU6IG1hcmtlcnNbMF0ubG9uZ2l0dWRlXG4gICAgICAgIH07XG4gICAgICAgIGNvbGxhcHNlZE1hcmtlcnMucHVzaChjb2xsYXBzZWRNYXJrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sbGFwc2VkTWFya2Vycy5wdXNoKG1hcmtlcnNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xsYXBzZWRNYXJrZXJzO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBHb29nbGVNYXBQcm92aWRlciAqL1xuXG5pbXBvcnQgTWFwUHJvdmlkZXIgZnJvbSAnLi9tYXBwcm92aWRlcic7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uLy4uL2RvbS9kb20nO1xuXG4vKiBnbG9iYWwgZ29vZ2xlICovXG5cbi8qKlxuICogR29vZ2xlTWFwUHJvdmlkZXIgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYSBNYXBQcm92aWRlclxuICogdGhhdCBoYW5kbGVzIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIHRoZSB0aGlyZCBwYXJ0eSBBUEkgdG8gZXhwb3NlIG1hcHMuXG4gKiBAZXh0ZW5kcyBNYXBQcm92aWRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb29nbGVNYXBQcm92aWRlciBleHRlbmRzIE1hcFByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIC8vIG5vcm1hbGl6ZSBiZWNhdXNlIGdvb2dsZSdzIHpvb20gaXMgZWZmZWN0aXZlbHkgMSB1bml0IG9mIGRpZmZlcmVuY2UgYXdheSBmcm9tIG1hcGJveCB6b29tXG4gICAgdGhpcy5fem9vbU9mZnNldCA9IDE7XG4gICAgdGhpcy5fem9vbSArPSB0aGlzLl96b29tT2Zmc2V0O1xuICAgIHRoaXMuX2NsaWVudElkID0gb3B0cy5jbGllbnRJZDtcbiAgICB0aGlzLl9zaWduYXR1cmUgPSBvcHRzLnNpZ25hdHVyZTtcblxuICAgIGlmICghdGhpcy5oYXNWYWxpZENsaWVudENyZWRlbnRpYWxzKCkgJiYgIXRoaXMuX2FwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGVNYXBzUHJvdmlkZXI6IE1pc3NpbmcgYGFwaUtleWAgb3Ige2BjbGllbnRJZGAsIGBzaWduYXR1cmVgfScpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRKUyAob25Mb2FkKSB7XG4gICAgaWYgKERPTS5xdWVyeSgnI3lleHQtbWFwLWpzJykpIHtcbiAgICAgIHRoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uTG9hZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzY3JpcHQgPSBET00uY3JlYXRlRWwoJ3NjcmlwdCcsIHtcbiAgICAgIGlkOiAneWV4dC1tYXAtanMnLFxuICAgICAgb25sb2FkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIHNyYzogYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz8ke3RoaXMuZ2VuZXJhdGVDcmVkZW50aWFscygpfWBcbiAgICB9KTtcblxuICAgIERPTS5hcHBlbmQoJ2JvZHknLCBzY3JpcHQpO1xuICB9XG5cbiAgZ2VuZXJhdGVDcmVkZW50aWFscyAoKSB7XG4gICAgaWYgKHRoaXMuaGFzVmFsaWRDbGllbnRDcmVkZW50aWFscygpKSB7XG4gICAgICByZXR1cm4gYGNsaWVudD0ke3RoaXMuX2NsaWVudElkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBga2V5PSR7dGhpcy5fYXBpS2V5fWA7XG4gICAgfVxuICB9XG5cbiAgaGFzVmFsaWRDbGllbnRDcmVkZW50aWFscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudElkO1xuICB9XG5cbiAgaW5pdCAoZWwsIG1hcERhdGEpIHtcbiAgICBpZiAoKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwTWFya2Vycy5sZW5ndGggPD0gMCkgJiYgIXRoaXMuX3Nob3dFbXB0eU1hcCkge1xuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE5PVEUoYmlsbHkpIFRoaXMgdGltZW91dCBpcyBhIGhhY2sgZm9yIGRlYWxpbmcgd2l0aCBhc3luYyBuYXR1cmUuXG4gICAgLy8gT25seSBoZXJlIGZvciBkZW1vIHB1cnBvc2VzLCBzbyB3ZSdsbCBmaXggbGF0ZXIuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgY29udGFpbmVyID0gRE9NLnF1ZXJ5KGVsKTtcbiAgICAgIHRoaXMubWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChjb250YWluZXIsIHtcbiAgICAgICAgem9vbTogdGhpcy5fem9vbSxcbiAgICAgICAgY2VudGVyOiB0aGlzLmdldENlbnRlck1hcmtlcihtYXBEYXRhKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFwcGx5IG91ciBzZWFyY2ggZGF0YSB0byBvdXIgR29vZ2xlTWFwXG4gICAgICBpZiAobWFwRGF0YSAmJiBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZE1hcmtlcnMgPSB0aGlzLl9jb2xsYXBzZVBpbnNcbiAgICAgICAgICA/IHRoaXMuX2NvbGxhcHNlTWFya2VycyhtYXBEYXRhLm1hcE1hcmtlcnMpXG4gICAgICAgICAgOiBtYXBEYXRhLm1hcE1hcmtlcnM7XG4gICAgICAgIGxldCBnb29nbGVNYXBNYXJrZXJDb25maWdzID0gR29vZ2xlTWFwTWFya2VyQ29uZmlnLmZyb20oXG4gICAgICAgICAgY29sbGFwc2VkTWFya2VycyxcbiAgICAgICAgICB0aGlzLl9waW5Db25maWcsXG4gICAgICAgICAgdGhpcy5tYXApO1xuXG4gICAgICAgIGxldCBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKGdvb2dsZU1hcE1hcmtlckNvbmZpZ3NbaV0pO1xuICAgICAgICAgIGlmICh0aGlzLl9vblBpbkNsaWNrKSB7XG4gICAgICAgICAgICBtYXJrZXIuYWRkTGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5fb25QaW5DbGljayhjb2xsYXBzZWRNYXJrZXJzW2ldLml0ZW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm91bmRzLmV4dGVuZChtYXJrZXIucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB0aGlzLm1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gIH1cblxuICBnZXRDZW50ZXJNYXJrZXIgKG1hcERhdGEpIHtcbiAgICByZXR1cm4gbWFwRGF0YSAmJiBtYXBEYXRhLm1hcENlbnRlciAmJiBtYXBEYXRhLm1hcENlbnRlci5sb25naXR1ZGUgJiYgbWFwRGF0YS5tYXBDZW50ZXIubGF0aXR1ZGVcbiAgICAgID8geyBsbmc6IG1hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSwgbGF0OiBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZSB9XG4gICAgICA6IHsgbG5nOiB0aGlzLl9kZWZhdWx0UG9zaXRpb24ubG5nLCBsYXQ6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sYXQgfTtcbiAgfVxufVxuXG4vLyBUT0RPKGJpbGx5KSBNb3ZlIHRvIG93biBjbGFzc1xuZXhwb3J0IGNsYXNzIEdvb2dsZU1hcE1hcmtlckNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGdvb2dsZSBtYXAsIHRoYXQgdGhlIG1hcmtlciBpcyBhcHBlbmRlZCB0b1xuICAgICAqIEB0eXBlIHtHb29nbGVNYXB9XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBvcHRzLm1hcCB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1hcmtlciAobGF0L2xuZylcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBvcHRzLnBvc2l0aW9uIHx8IHtcbiAgICAgIGxhdDogdW5kZWZpbmVkLFxuICAgICAgbG5nOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByb3BlcnRpZXMvc2V0dGluZ3Mgb2YgdGhlIGljb24gdXNlZCBmb3IgdGhlIG1hcmtlclxuICAgICAqIGUuZy4ge1xuICAgICAqICAgICAgICBhbmNob3I6IHsgeDogMCwgeTogMCB9XG4gICAgICogICAgICAgIHVybDogJ3BhdGgvdG8vdXJsLmpwZydcbiAgICAgKiAgICAgICAgc2NhbGVkU2l6ZTogeyB3OiAwLCBoOiAwIH1cbiAgICAgKiAgICAgICB9XG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaWNvbiA9IG9wdHMuaWNvbiB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgb2YgdGhlIG1hcmtlciB0byB1c2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBvcHRzLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGFuIGFycmF5IG9mIG1hcmtlciBjb25maWdzXG4gICAqIEBwYXJhbSB7R29vZ2xlTWFwTWFya2VyQ29uZmlnW119IGdvb2dsZU1hcE1hcmtlckNvbmZpZ3NcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZSAoZ29vZ2xlTWFwTWFya2VyQ29uZmlncykge1xuICAgIGxldCBzZXJpYWxpemVkTWFya2VycyA9IFtdO1xuICAgIGdvb2dsZU1hcE1hcmtlckNvbmZpZ3MuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICBzZXJpYWxpemVkTWFya2Vycy5wdXNoKGBtYXJrZXJzPWxhYmVsOiR7bWFya2VyLmxhYmVsfXwke21hcmtlci5wb3NpdGlvbi5sYXR9LCR7bWFya2VyLnBvc2l0aW9uLmxuZ31gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1hcmtlcnMuam9pbignJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzdG9yYWdlIGRhdGEgbW9kZWwgb2YgbWFya2VycyBpbnRvIEdvb2dsZUFQSU1hcmtlclxuICAgKiBAcGFyYW0ge29iamVjdFtdfSBtYXJrZXJzIFRoZSBkYXRhIG9mIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gcGluQ29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHtHb29nbGVNYXB9IG1hcCByZWZlcmVuY2UgdG8gdGhlIGdvb2dsZSBtYXAgdG8gYXBwbHkgdGhlIG1hcmtlciB0b1xuICAgKiBAcmV0dXJucyB7R29vZ2xlTWFwTWFya2VyQ29uZmlnW119XG4gICAqL1xuICBzdGF0aWMgZnJvbSAobWFya2VycywgcGluQ29uZmlnLCBtYXApIHtcbiAgICBsZXQgZ29vZ2xlTWFwTWFya2VyQ29uZmlncyA9IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXJrZXJzKSkge1xuICAgICAgbWFya2VycyA9IFttYXJrZXJzXTtcbiAgICB9XG5cbiAgICBtYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgLy8gU3VwcG9ydCBjb25maWd1cmF0aW9uIGFzIGEgZnVuY3Rpb25cbiAgICAgIGxldCBwaW5Db25maWdPYmogPSBwaW5Db25maWc7XG4gICAgICBpZiAodHlwZW9mIHBpbkNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwaW5Db25maWdPYmogPSBwaW5Db25maWcoXG4gICAgICAgICAgbWFya2VyLml0ZW0sXG4gICAgICAgICAgTWFwUHJvdmlkZXIuREVGQVVMVF9QSU5fQ09ORklHLFxuICAgICAgICAgIG1hcmtlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBvdXIgQ29uZmlndXJhdGlvbiBPYmplY3QgaW50byB0aGUgZXhwZWN0ZWRcbiAgICAgIC8vIEdvb2dsZSBBUEkgZm9ybWF0LlxuICAgICAgbGV0IGljb24gPSB7fTtcbiAgICAgIGlmIChwaW5Db25maWdPYmouYW5jaG9yKSB7XG4gICAgICAgIGljb24uYW5jaG9yID0gZ29vZ2xlLm1hcHMuUG9pbnQocGluQ29uZmlnT2JqLmFuY2hvci54LCBwaW5Db25maWdPYmouYW5jaG9yLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluQ29uZmlnT2JqLnNjYWxlZFNpemUpIHtcbiAgICAgICAgaWNvbi5zY2FsZWRTaXplID0gbmV3IGdvb2dsZS5tYXBzLlNpemUocGluQ29uZmlnT2JqLnNjYWxlZFNpemUudywgcGluQ29uZmlnT2JqLnNjYWxlZFNpemUuaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5Db25maWdPYmoudXJsKSB7XG4gICAgICAgIGljb24udXJsID0gcGluQ29uZmlnT2JqLnVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbkNvbmZpZ09iai5zdmcpIHtcbiAgICAgICAgaWNvbi51cmwgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsICR7ZW5jb2RlVVJJQ29tcG9uZW50KHBpbkNvbmZpZ09iai5zdmcpfWA7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYWJlbDtcbiAgICAgIGlmIChwaW5Db25maWdPYmoubGFiZWwpIHtcbiAgICAgICAgbGFiZWwgPSBwaW5Db25maWdPYmoubGFiZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IG1hcmtlci5sYWJlbC50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFKGJpbGx5KSBHb29nbGUgbWFwcyBkb2Vzbid0IGhhbmRsZSBlbXB0eSBpY29uIG9iamVjdHMgbmljZWx5XG4gICAgICAvLyBNYWtlIGdvb2dsZSBtYXBzIGhhcHB5IGlmIG5vIHNldHRpbmdzIGZvciBpY29uIGFyZSBwcm92aWRlZDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhpY29uKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWNvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZ29vZ2xlTWFwTWFya2VyQ29uZmlncy5wdXNoKFxuICAgICAgICBuZXcgR29vZ2xlTWFwTWFya2VyQ29uZmlnKHtcbiAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbGF0OiBtYXJrZXIubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IG1hcmtlci5sb25naXR1ZGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGljb246IGljb24sXG4gICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdvb2dsZU1hcE1hcmtlckNvbmZpZ3M7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE1hcEJveE1hcFByb3ZpZGVyICovXG5cbmltcG9ydCBNYXBQcm92aWRlciBmcm9tICcuL21hcHByb3ZpZGVyJztcbmltcG9ydCBET00gZnJvbSAnLi4vLi4vLi4vZG9tL2RvbSc7XG5cbi8qIGdsb2JhbCBtYXBib3hnbCAqL1xuXG4vKipcbiAqIE1hcEJveE1hcFByb3ZpZGVyIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGEgTWFwUHJvdmlkZXJcbiAqIHRoYXQgaGFuZGxlcyB0aGUgaW50ZWdyYXRpb24gd2l0aCB0aGUgdGhpcmQgcGFydHkgQVBJIHRvIGV4cG9zZSBtYXBzLlxuICogQGV4dGVuZHMgTWFwUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwQm94TWFwUHJvdmlkZXIgZXh0ZW5kcyBNYXBQcm92aWRlciB7XG4gIC8qKlxuICAgKiBMb2FkIHRoZSBleHRlcm5hbCBKUyBMaWJyYXJ5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uTG9hZCBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgSlMgaXMgbG9hZGVkLlxuICAgKi9cbiAgbG9hZEpTIChvbkxvYWQpIHtcbiAgICBsZXQgc2NyaXB0ID0gRE9NLmNyZWF0ZUVsKCdzY3JpcHQnLCB7XG4gICAgICBpZDogJ3lleHQtbWFwLWpzJyxcbiAgICAgIG9ubG9hZDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gdGhpcy5fYXBpS2V5O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uTG9hZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgc3JjOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDQuMS9tYXBib3gtZ2wuanMnXG4gICAgfSk7XG5cbiAgICBsZXQgY3NzID0gRE9NLmNyZWF0ZUVsKCdsaW5rJywge1xuICAgICAgaWQ6ICd5ZXh0LW1hcC1jc3MnLFxuICAgICAgcmVsOiAnc3R5bGVzaGVldCcsXG4gICAgICBocmVmOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDQuMS9tYXBib3gtZ2wuY3NzJ1xuICAgIH0pO1xuXG4gICAgRE9NLmFwcGVuZCgnYm9keScsIGNzcyk7XG4gICAgRE9NLmFwcGVuZCgnYm9keScsIHNjcmlwdCk7XG4gIH1cblxuICBpbml0IChlbCwgbWFwRGF0YSkge1xuICAgIGlmICgoIW1hcERhdGEgfHwgbWFwRGF0YS5tYXBNYXJrZXJzLmxlbmd0aCA8PSAwKSAmJiAhdGhpcy5fc2hvd0VtcHR5TWFwKSB7XG4gICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGNvbnRhaW5lciA9IERPTS5xdWVyeShlbCk7XG4gICAgdGhpcy5fbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHpvb206IHRoaXMuX3pvb20sXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12OScsXG4gICAgICBjZW50ZXI6IHRoaXMuZ2V0Q2VudGVyTWFya2VyKG1hcERhdGEpXG4gICAgfSk7XG5cbiAgICBpZiAobWFwRGF0YSAmJiBtYXBEYXRhLm1hcE1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjb2xsYXBzZWRNYXJrZXJzID0gdGhpcy5fY29sbGFwc2VQaW5zXG4gICAgICAgID8gdGhpcy5fY29sbGFwc2VNYXJrZXJzKG1hcERhdGEubWFwTWFya2VycylcbiAgICAgICAgOiBtYXBEYXRhLm1hcE1hcmtlcnM7XG4gICAgICBjb25zdCBtYXBib3hNYXBNYXJrZXJDb25maWdzID0gTWFwQm94TWFya2VyQ29uZmlnLmZyb20oXG4gICAgICAgIGNvbGxhcHNlZE1hcmtlcnMsXG4gICAgICAgIHRoaXMuX3BpbkNvbmZpZyxcbiAgICAgICAgdGhpcy5fbWFwKTtcblxuICAgICAgY29uc3QgYm91bmRzID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBib3hNYXBNYXJrZXJDb25maWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB3cmFwcGVyID0gbWFwYm94TWFwTWFya2VyQ29uZmlnc1tpXS53cmFwcGVyO1xuICAgICAgICBsZXQgY29vcmRzID0gbmV3IG1hcGJveGdsLkxuZ0xhdChcbiAgICAgICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzW2ldLnBvc2l0aW9uLmxvbmdpdHVkZSxcbiAgICAgICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzW2ldLnBvc2l0aW9uLmxhdGl0dWRlKTtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBtYXBib3hnbC5NYXJrZXIod3JhcHBlcikuc2V0TG5nTGF0KGNvb3Jkcyk7XG4gICAgICAgIGJvdW5kcy5leHRlbmQobWFya2VyLmdldExuZ0xhdCgpKTtcbiAgICAgICAgbWFya2VyLmFkZFRvKHRoaXMuX21hcCk7XG4gICAgICAgIGlmICh0aGlzLl9vblBpbkNsaWNrKSB7XG4gICAgICAgICAgbWFya2VyLmdldEVsZW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuX29uUGluQ2xpY2soY29sbGFwc2VkTWFya2Vyc1tpXS5pdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXBib3hNYXBNYXJrZXJDb25maWdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHRoaXMuX21hcC5maXRCb3VuZHMoYm91bmRzLCB7IHBhZGRpbmc6IDUwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldENlbnRlck1hcmtlciAobWFwRGF0YSkge1xuICAgIHJldHVybiBtYXBEYXRhICYmIG1hcERhdGEubWFwQ2VudGVyICYmIG1hcERhdGEubWFwQ2VudGVyLmxvbmdpdHVkZSAmJiBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZVxuICAgICAgPyBbbWFwRGF0YS5tYXBDZW50ZXIubG9uZ2l0dWRlLCBtYXBEYXRhLm1hcENlbnRlci5sYXRpdHVkZV1cbiAgICAgIDogeyBsbmc6IHRoaXMuX2RlZmF1bHRQb3NpdGlvbi5sbmcsIGxhdDogdGhpcy5fZGVmYXVsdFBvc2l0aW9uLmxhdCB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXBCb3hNYXJrZXJDb25maWcge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBtYXBib3ggbWFwLCB0aGF0IHRoZSBtYXJrZXIgaXMgYXBwZW5kZWQgdG9cbiAgICAgKiBAdHlwZSB7TWFwQm94fVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gb3B0cy5tYXAgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtYXJrZXIgKGxhdC9sbmcpXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbiB8fCB7XG4gICAgICBsYXRpdHVkZTogdW5kZWZpbmVkLFxuICAgICAgbG9uZ2l0dWRlOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGh0bWwgZWxlbWVudCB0byBiZSB1c2VkIGFzIHRoZSBtYXAgbWFya2VyXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZXIgPSBvcHRzLndyYXBwZXIgfHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIG9mIHRoZSBtYXJrZXIgdG8gdXNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsID0gb3B0cy5sYWJlbCB8fCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXJsIG9mIHRoZSBwaW4gZm9yIHRoZSBzdGF0aWMgbWFwXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRpY01hcFBpbiA9IG9wdHMuc3RhdGljTWFwUGluIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGFuIGFycmF5IG9mIG1hcmtlciBjb25maWdzXG4gICAqIEBwYXJhbSB7TWFwQm94TWFya2VyQ29uZmlnW119IG1hcGJveE1hcE1hcmtlckNvbmZpZ3NcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZSAobWFwYm94TWFwTWFya2VyQ29uZmlncykge1xuICAgIGxldCBzZXJpYWxpemVkTWFya2VycyA9IFtdO1xuICAgIG1hcGJveE1hcE1hcmtlckNvbmZpZ3MuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICBpZiAobWFya2VyLnN0YXRpY01hcFBpbikge1xuICAgICAgICBzZXJpYWxpemVkTWFya2Vycy5wdXNoKGB1cmwtJHttYXJrZXIuc3RhdGljTWFwUGlufSgke21hcmtlci5wb3NpdGlvbi5sb25naXR1ZGV9LCR7bWFya2VyLnBvc2l0aW9uLmxhdGl0dWRlfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRNYXJrZXJzLnB1c2goYHBpbi1zLSR7bWFya2VyLmxhYmVsfSgke21hcmtlci5wb3NpdGlvbi5sb25naXR1ZGV9LCR7bWFya2VyLnBvc2l0aW9uLmxhdGl0dWRlfSlgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1hcmtlcnMuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzdG9yYWdlIGRhdGEgbW9kZWwgb2YgbWFya2VycyBpbnRvIE1hcEJveE1hcmtlckNvbmZpZ1xuICAgKiBAcGFyYW0ge01hcEJveH0gQSByZWZlcmVuY2UgdG8gdGhlIG1hcGJveCBtYXAgdG8gYXBwbHkgdGhlIG1hcmtlciB0b1xuICAgKiBAcGFyYW0ge29iamVjdFtdfSBtYXJrZXJzIFRoZSBkYXRhIG9mIHRoZSBtYXJrZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBpbkNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgbWFya2VyXG4gICAqIEByZXR1cm5zIHtNYXBCb3hNYXJrZXJDb25maWdbXX1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChtYXJrZXJzLCBwaW5Db25maWcsIG1hcCkge1xuICAgIGxldCBtYXBib3hNYXBNYXJrZXJDb25maWdzID0gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hcmtlcnMpKSB7XG4gICAgICBtYXJrZXJzID0gW21hcmtlcnNdO1xuICAgIH1cblxuICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAvLyBTdXBwb3J0IGNvbmZpZ3VyYXRpb24gYXMgYSBmdW5jdGlvblxuICAgICAgbGV0IHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZztcbiAgICAgIGlmICh0eXBlb2YgcGluQ29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBpbkNvbmZpZ09iaiA9IHBpbkNvbmZpZyhcbiAgICAgICAgICBtYXJrZXIuaXRlbSxcbiAgICAgICAgICBNYXBQcm92aWRlci5ERUZBVUxUX1BJTl9DT05GSUcsXG4gICAgICAgICAgbWFya2VyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlciA9IHBpbkNvbmZpZ09iai53cmFwcGVyID8gcGluQ29uZmlnT2JqLndyYXBwZXIgOiBudWxsO1xuICAgICAgY29uc3Qgc3RhdGljTWFwUGluID0gcGluQ29uZmlnT2JqLnN0YXRpY01hcFBpbiA/IHBpbkNvbmZpZ09iai5zdGF0aWNNYXBQaW4gOiBudWxsO1xuXG4gICAgICBtYXBib3hNYXBNYXJrZXJDb25maWdzLnB1c2goXG4gICAgICAgIG5ldyBNYXBCb3hNYXJrZXJDb25maWcoe1xuICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBsYXRpdHVkZTogbWFya2VyLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBtYXJrZXIubG9uZ2l0dWRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgICAgIGxhYmVsOiBtYXJrZXIubGFiZWwsXG4gICAgICAgICAgc3RhdGljTWFwUGluOiBzdGF0aWNNYXBQaW5cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFwYm94TWFwTWFya2VyQ29uZmlncztcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgTWFwQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcblxuaW1wb3J0IEdvb2dsZU1hcFByb3ZpZGVyIGZyb20gJy4vcHJvdmlkZXJzL2dvb2dsZW1hcHByb3ZpZGVyJztcbmltcG9ydCBNYXBCb3hNYXBQcm92aWRlciBmcm9tICcuL3Byb3ZpZGVycy9tYXBib3htYXBwcm92aWRlcic7XG5cbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuXG5jb25zdCBQcm92aWRlclR5cGVzID0ge1xuICAnZ29vZ2xlJzogR29vZ2xlTWFwUHJvdmlkZXIsXG4gICdtYXBib3gnOiBNYXBCb3hNYXBQcm92aWRlclxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIHRoaXMgY29tcG9uZW50IHRvIGxpc3RlbiB0byB0aGUgc3RvcmFnZSBiYXNlZCBvbiB0aGlzIGtleVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWxpYXNlZCB1c2VkIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBtYXAgcHJvdmlkZXIgdG8gdXNlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9tYXBQcm92aWRlciA9IG9wdHMubWFwUHJvdmlkZXI7XG4gICAgaWYgKCF0aGlzLl9tYXBQcm92aWRlciB8fCAhKHRoaXMuX21hcFByb3ZpZGVyLnRvTG93ZXJDYXNlKCkgaW4gUHJvdmlkZXJUeXBlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFwQ29tcG9uZW50OiBJbnZhbGlkIE1hcCBQcm92aWRlcjsgbXVzdCBiZSBgZ29vZ2xlYCBvciBgbWFwQm94YCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIGFuIGluc3RhbmNlIG9mIHRoZSB7TWFwUHJvdmlkZXJ9IHRoYXQncyBjb25zdHJ1Y3RlZFxuICAgICAqIEB0eXBlIHtNYXBQcm92aWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ01hcCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvbWFwJztcbiAgfVxuXG4gIC8vIFRPRE8oYmlsbHkpIE1ha2UgUHJvdmlkZXJUeXBlcyBhIGZhY3RvcnkgY2xhc3NcbiAgZ2V0UHJvdmlkZXJJbnN0YW5jZSAodHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvdmlkZXJUeXBlc1t0eXBlLnRvTG93ZXJDYXNlKCldKHRoaXMuX2NvbmZpZyk7XG4gIH1cblxuICBvbkNyZWF0ZSAoKSB7XG4gICAgdGhpcy5fbWFwID0gdGhpcy5nZXRQcm92aWRlckluc3RhbmNlKHRoaXMuX21hcFByb3ZpZGVyKTtcbiAgICB0aGlzLl9tYXAubG9hZEpTKCk7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICB0aGlzLl9tYXAub25Mb2FkZWQoKCkgPT4ge1xuICAgICAgdGhpcy5fbWFwLmluaXQodGhpcy5fY29udGFpbmVyLCB0aGlzLmdldFN0YXRlKCdtYXAnKSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSwgdmFsKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKGRhdGEsIHZhbCk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFJlc3VsdHNDb21wb25lbnQgKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQnO1xuXG5pbXBvcnQgUmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL2xvY2F0aW9ucmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuaW1wb3J0IEV2ZW50UmVzdWx0c0l0ZW1Db21wb25lbnQgZnJvbSAnLi9ldmVudHJlc3VsdHNpdGVtY29tcG9uZW50JztcbmltcG9ydCBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Blb3BsZXJlc3VsdHNpdGVtY29tcG9uZW50JztcbmltcG9ydCBNYXBDb21wb25lbnQgZnJvbSAnLi4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5cbmNvbnN0IFJlc3VsdFR5cGUgPSB7XG4gIEVWRU5UOiAnZXZlbnQnLFxuICBMT0NBVElPTjogJ2xvY2F0aW9uJyxcbiAgUEVPUExFOiAncGVvcGxlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdWx0c0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihjb25maWcsIHN5c3RlbUNvbmZpZyk7XG5cbiAgICAvKipcbiAgICAgKiB2ZXJ0aWNhbENvbmZpZ0lkIHVzZWQgZm9yIGFuYWx5dGljcyBhbmQgcGFzc2VkIHRvIGNoaWxkcmVuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQgPSBjb25maWcudmVydGljYWxDb25maWdJZDtcblxuICAgIC8qKlxuICAgICAqIGlzVW5pdmVyc2FsIGlzIHNldCB0byB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIGJ5IHRoZSBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pc1VuaXZlcnNhbCA9IGNvbmZpZy5pc1VuaXZlcnNhbCB8fCBmYWxzZTtcblxuICAgIHRoaXMubW9kdWxlSWQgPSBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTO1xuICAgIHRoaXMuX2l0ZW1Db25maWcgPSB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICB0ZW1wbGF0ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIFtFdmVudFJlc3VsdHNJdGVtQ29tcG9uZW50LnR5cGVdOiB7XG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgdGVtcGxhdGU6IG51bGxcbiAgICAgIH0sXG4gICAgICBbTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudC50eXBlXToge1xuICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgIHRlbXBsYXRlOiBudWxsXG4gICAgICB9LFxuICAgICAgW1Blb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50LnR5cGVdOiB7XG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgdGVtcGxhdGU6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJJdGVtID09PSB1bmRlZmluZWQgJiYgY29uZmlnLl9wYXJlbnRPcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5yZW5kZXJJdGVtID0gY29uZmlnLl9wYXJlbnRPcHRzLnJlbmRlckl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5pdGVtVGVtcGxhdGUgPT09IHVuZGVmaW5lZCAmJiBjb25maWcuX3BhcmVudE9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZmlnLml0ZW1UZW1wbGF0ZSA9IGNvbmZpZy5fcGFyZW50T3B0cy5pdGVtVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWd1cmVJdGVtKHtcbiAgICAgIHJlbmRlcjogY29uZmlnLnJlbmRlckl0ZW0sXG4gICAgICB0ZW1wbGF0ZTogY29uZmlnLml0ZW1UZW1wbGF0ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCB0byB0aGUgdW5pdmVyc2FsIHBhZ2UgZm9yIHRoZSBubyByZXN1bHRzIHBhZ2UgdG8gbGluayBiYWNrIHRvIHdpdGggY3VycmVudCBxdWVyeVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl91bml2ZXJzYWxVcmwgPSBjb25maWcudW5pdmVyc2FsVXJsO1xuICB9XG5cbiAgbW91bnQgKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmdldFN0YXRlKCkpLmxlbmd0aCA+IDApIHtcbiAgICAgIHN1cGVyLm1vdW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGR1cGxpY2F0ZXNBbGxvd2VkICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBjb25zdCByZXN1bHRzID0gZGF0YS5yZXN1bHRzIHx8IFtdO1xuICAgIGNvbnN0IHNlYXJjaFN0YXRlID0gZGF0YS5zZWFyY2hTdGF0ZSB8fCBTZWFyY2hTdGF0ZXMuUFJFX1NFQVJDSDtcbiAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHJlc3VsdHM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIGluY2x1ZGVNYXA6IHRoaXMuX2NvbmZpZy5pbmNsdWRlTWFwLFxuICAgICAgbWFwQ29uZmlnOiB0aGlzLl9jb25maWcubWFwQ29uZmlnLFxuICAgICAgZXZlbnRPcHRpb25zOiB0aGlzLmV2ZW50T3B0aW9ucygpLFxuICAgICAgdW5pdmVyc2FsVXJsOiB0aGlzLl91bml2ZXJzYWxVcmwgPyB0aGlzLl91bml2ZXJzYWxVcmwgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoIDogJycsXG4gICAgICBzaG93Tm9SZXN1bHRzOiByZXN1bHRzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSlcbiAgICB9KSwgdmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgdG8gY29uc3RydWN0IHRoZSBldmVudE9wdGlvbnMgb2JqZWN0IGZvciB0aGUgdmlldyBhbGwgbGlua1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZXZlbnRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy5fdmVydGljYWxDb25maWdJZFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1ZlcnRpY2FsUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0cyc7XG4gIH1cblxuICBjb25maWd1cmVJdGVtIChjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2l0ZW1Db25maWcuZ2xvYmFsLnJlbmRlciA9IGNvbmZpZy5yZW5kZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb25maWcucmVuZGVyKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVJlbmRlcihrZXksIGNvbmZpZy5yZW5kZXJba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9pdGVtQ29uZmlnLmdsb2JhbC50ZW1wbGF0ZSA9IGNvbmZpZy50ZW1wbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZy50ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnNldEl0ZW1UZW1wbGF0ZShrZXksIGNvbmZpZy50ZW1wbGF0ZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRJdGVtVGVtcGxhdGUgKHR5cGUsIHRlbXBsYXRlKSB7XG4gICAgbGV0IGNsYXp6ID0gdGhpcy5nZXRJdGVtQ29tcG9uZW50KHR5cGUpO1xuICAgIHRoaXMuX2l0ZW1Db25maWdbY2xhenoudHlwZV0udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgfVxuXG4gIHNldEl0ZW1SZW5kZXIgKHR5cGUsIHJlbmRlcikge1xuICAgIGxldCBjbGF6eiA9IHRoaXMuZ2V0SXRlbUNvbXBvbmVudCh0eXBlKTtcbiAgICB0aGlzLl9pdGVtQ29uZmlnW2NsYXp6LnR5cGVdLnJlbmRlciA9IHJlbmRlcjtcbiAgfVxuXG4gIGdldEl0ZW1Db21wb25lbnQgKHR5cGUpIHtcbiAgICBsZXQgY29tcCA9IFJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSZXN1bHRUeXBlLkVWRU5UOlxuICAgICAgICBjb21wID0gRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJlc3VsdFR5cGUuTE9DQVRJT046XG4gICAgICAgIGNvbXAgPSBMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmVzdWx0VHlwZS5QRU9QTEU6XG4gICAgICAgIGNvbXAgPSBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cblxuICBhZGRDaGlsZCAoZGF0YSwgdHlwZSwgb3B0cykge1xuICAgIC8vIFRPRE8oYmlsbHkpIFJlZmFjdG9yIHRoZSB3YXkgY29uZmlndXJhdGlvbiBhbmQgZGF0YSBmbG93c1xuICAgIC8vIHRocm91Z2ggdG9wIGxldmVsIGNvbXBvbmVudHMgdG8gY2hpbGQgY29tcG9uZW50cy5cbiAgICBpZiAodHlwZSA9PT0gUmVzdWx0c0l0ZW1Db21wb25lbnQudHlwZSkge1xuICAgICAgbGV0IGNsYXp6ID0gdGhpcy5nZXRJdGVtQ29tcG9uZW50KGRhdGEudHlwZSk7XG4gICAgICBpZiAoY2xhenopIHtcbiAgICAgICAgdHlwZSA9IGNsYXp6LnR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBNYXBDb21wb25lbnQudHlwZSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgbWFwOiBkYXRhXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2NvbmZpZy5tYXBDb25maWcsIG9wdHMpO1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZENoaWxkKGRhdGEsIHR5cGUsIG5ld09wdHMpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSBwcm9wZXIgaXRlbSByZW5kZXJzIHRvIHRoZSB0aGUgY29tcG9uZW50c1xuICAgIC8vIGhhdmUganVzdCBiZWVuIGNvbnN0cnVjdGVkLiBQcmlvcml0aXplIGdsb2JhbCBvdmVyIGluZGl2aWR1YWwgaXRlbXMuXG4gICAgbGV0IGNvbXAgPSBzdXBlci5hZGRDaGlsZChkYXRhLCB0eXBlLCBPYmplY3QuYXNzaWduKG9wdHMsIHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IHRoaXMuX3ZlcnRpY2FsQ29uZmlnSWQsXG4gICAgICBpc1VuaXZlcnNhbDogdGhpcy5faXNVbml2ZXJzYWxcbiAgICB9KSk7XG4gICAgbGV0IGdsb2JhbENvbmZpZyA9IHRoaXMuX2l0ZW1Db25maWcuZ2xvYmFsO1xuICAgIGxldCBpdGVtQ29uZmlnID0gdGhpcy5faXRlbUNvbmZpZ1tjb21wLnR5cGVdO1xuICAgIGxldCBoYXNHbG9iYWxSZW5kZXIgPSB0eXBlb2YgZ2xvYmFsQ29uZmlnLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICBsZXQgaGFzR2xvYmFsVGVtcGxhdGUgPSB0eXBlb2YgZ2xvYmFsQ29uZmlnLnRlbXBsYXRlID09PSAnc3RyaW5nJztcblxuICAgIGlmIChoYXNHbG9iYWxSZW5kZXIpIHtcbiAgICAgIGNvbXAuc2V0UmVuZGVyKGdsb2JhbENvbmZpZy5yZW5kZXIpO1xuICAgIH1cblxuICAgIGlmIChoYXNHbG9iYWxUZW1wbGF0ZSkge1xuICAgICAgY29tcC5zZXRUZW1wbGF0ZShnbG9iYWxDb25maWcudGVtcGxhdGUpO1xuICAgIH1cblxuICAgIGlmICghaXRlbUNvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNHbG9iYWxSZW5kZXIgJiYgaXRlbUNvbmZpZy5yZW5kZXIpIHtcbiAgICAgIGNvbXAuc2V0UmVuZGVyKGl0ZW1Db25maWcucmVuZGVyKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB0ZW1wbGF0ZSBzcGVjaWZpYyBzaXR1YXRpb25cbiAgICBpZiAoIWhhc0dsb2JhbFRlbXBsYXRlICYmIGl0ZW1Db25maWcudGVtcGxhdGUpIHtcbiAgICAgIGNvbXAuc2V0VGVtcGxhdGUoaXRlbUNvbmZpZy50ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50ICovXG5pbXBvcnQgUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHNjb21wb25lbnQnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCBBbmFseXRpY3NFdmVudCBmcm9tICcuLi8uLi8uLi9jb3JlL2FuYWx5dGljcy9hbmFseXRpY3NldmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjY29yZGlvblJlc3VsdHNDb21wb25lbnQgZXh0ZW5kcyBSZXN1bHRzQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIGJhc2Ugc2VsZWN0b3IgdG8gdXNlIHdoZW4gZmluZGluZyBET00gdGFyZ2V0c1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5fc2VsZWN0b3JCYXNlID0gY29uZmlnLnNlbGVjdG9yQmFzZSB8fCAnLmpzLXl4dC1BY2NvcmRpb25SZXN1bHQnO1xuXG4gICAgLyoqXG4gICAgICogY29sbGFwc2VkIHN0YXRlIGNsYXNzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZENsYXNzID0gY29uZmlnLmNvbGxhcHNlZENsYXNzIHx8ICdpcy1jb2xsYXBzZWQnO1xuXG4gICAgLyoqXG4gICAgICogdmVydGljYWwgY29uZmlnIGlkIGlzIHJlcXVpcmVkIGZvciBhbmFseXRpY3NcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNhbENvbmZpZ0lkID0gY29uZmlnLnZlcnRpY2FsQ29uZmlnSWQgfHwgY29uZmlnLl9wYXJlbnRPcHRzLnZlcnRpY2FsQ29uZmlnSWQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgY29tcG9uZW50IHR5cGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnQWNjb3JkaW9uUmVzdWx0cyc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcmVzdWx0c2FjY29yZGlvbic7XG4gIH1cblxuICAvKipcbiAgICogb3ZlcnJpZGVzIG9uTW91bnQgdG8gYWRkIGJpbmRpbmdzIHRvIGNoYW5nZSB0aGUgaGVpZ2h0IG9uIGNsaWNrXG4gICAqIEByZXR1cm5zIHtBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uTW91bnQgKCkge1xuICAgIHN1cGVyLm9uTW91bnQoKTtcblxuICAgIC8vIE5PVEUoYW11bGxpbmdzKTogVGhpcyBpcyBhIGhhY2ssIHNpbmNlIGN1cnJlbnRseSBjb21wb25lbnRzIHdpdGggc2libGluZ3NcbiAgICAvLyBoYXZlIG5vIHdheSBvZiByZWZlcnJpbmcgdG8gdGhlaXIgb3duIGVsZW1lbnQuIFdlIGhhdmUgdG8gZ3JhYiB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IHNpbmNlIHNlY3Rpb25zIGdldCBhZGRlZCBpbiByZXZlcnNlLlxuICAgIGNvbnN0IHNlbGZFbCA9IHRoaXMuX2NvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZDtcblxuICAgIGNvbnN0IGFjY29yZGlvbkVscyA9IERPTS5xdWVyeUFsbChzZWxmRWwsIHRoaXMuX3NlbGVjdG9yQmFzZSk7XG4gICAgYWNjb3JkaW9uRWxzLmZvckVhY2goKGFjY29yZGlvbkVsKSA9PiB7XG4gICAgICBjb25zdCB0b2dnbGVFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy50b2dnbGVTZWxlY3RvcigpKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IERPTS5xdWVyeShhY2NvcmRpb25FbCwgdGhpcy5ib2R5U2VsZWN0b3IoKSk7XG4gICAgICB0aGlzLmNoYW5nZUhlaWdodChjb250ZW50RWwsIGFjY29yZGlvbkVsKTtcbiAgICAgIHRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGFjY29yZGlvbkVsLCB0b2dnbGVFbCwgY29udGVudEVsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRTdGF0ZSAoZGF0YSkge1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBtb2RpZmllcjogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRoZSBhY2NvcmRpb24gdG9nZ2xlIGJ1dHRvblxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHBhcmFtIHRvZ2dsZUVsIHtIVE1MRWxlbWVudH0gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0gY29udGVudEVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSB0YXJnZXRcbiAgICovXG4gIGhhbmRsZUNsaWNrICh3cmFwcGVyRWwsIHRvZ2dsZUVsLCBjb250ZW50RWwpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBBbmFseXRpY3NFdmVudCh0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAnUk9XX0VYUEFORCcgOiAnUk9XX0NPTExBUFNFJylcbiAgICAgIC5hZGRPcHRpb25zKHtcbiAgICAgICAgdmVydGljYWxDb25maWdJZDogdGhpcy52ZXJ0aWNhbENvbmZpZ0lkLFxuICAgICAgICBlbnRpdHlJZDogdG9nZ2xlRWwuZGF0YXNldC5lbnRpdHlJZFxuICAgICAgfSk7XG4gICAgd3JhcHBlckVsLmNsYXNzTGlzdC50b2dnbGUodGhpcy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgdGhpcy5jaGFuZ2VIZWlnaHQoY29udGVudEVsLCB3cmFwcGVyRWwpO1xuICAgIHRvZ2dsZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRoaXMuaXNDb2xsYXBzZWQod3JhcHBlckVsKSA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgIHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIucmVwb3J0KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGNvbGxhcHNlZFxuICAgKiBAcGFyYW0gd3JhcHBlckVsIHtIVE1MRWxlbWVudH0gdGhlIHRvZ2dsZSBjb250YWluZXJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvbGxhcHNlZCAod3JhcHBlckVsKSB7XG4gICAgaWYgKCF3cmFwcGVyRWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlckVsLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbGxhcHNlZENsYXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b2dnbGVzIHRoZSBoZWlnaHQgYmV0d2VlbiAwIGFuZCB0aGUgY29udGVudCBoZWlnaHQgZm9yIHNtb290aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHRhcmdldEVsIHtIVE1MRWxlbWVudH1cbiAgICogQHBhcmFtIHdyYXBwZXJFbCB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjaGFuZ2VIZWlnaHQgKHRhcmdldEVsLCB3cmFwcGVyRWwpIHtcbiAgICB0YXJnZXRFbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmlzQ29sbGFwc2VkKHdyYXBwZXJFbCkgPyAwIDogdGFyZ2V0RWwuc2Nyb2xsSGVpZ2h0fXB4YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIGNvbXBvc2luZyBjaGlsZCBlbGVtZW50IHNlbGVjdG9yc1xuICAgKiBAcGFyYW0gY2hpbGQge3N0cmluZ31cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJ1aWxkU2VsZWN0b3IgKGNoaWxkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3NlbGVjdG9yQmFzZX0ke2NoaWxkfWA7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9nZ2xlU2VsZWN0b3IgKCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkU2VsZWN0b3IoJy10b2dnbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoZWxwZXIgZm9yIHRoZSBjb250ZW50IGVsZW1lbnQgc2VsZWN0b3JcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGJvZHlTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRTZWxlY3RvcignLWJvZHknKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgU3RvcmFnZUtleXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hTdGF0ZXMgZnJvbSAnLi4vLi4vLi4vY29yZS9zdG9yYWdlL3NlYXJjaHN0YXRlcyc7XG5pbXBvcnQgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCBmcm9tICcuL2FjY29yZGlvbnJlc3VsdHNjb21wb25lbnQuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSwgc3lzdGVtT3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cywgc3lzdGVtT3B0cyk7XG5cbiAgICB0aGlzLm1vZHVsZUlkID0gU3RvcmFnZUtleXMuVU5JVkVSU0FMX1JFU1VMVFM7XG4gICAgdGhpcy5fbGltaXQgPSBvcHRzLmxpbWl0IHx8IDEwO1xuICB9XG5cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1VuaXZlcnNhbFJlc3VsdHMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB0byByZW5kZXJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFRlbXBsYXRlTmFtZSAoY29uZmlnKSB7XG4gICAgcmV0dXJuICdyZXN1bHRzL3VuaXZlcnNhbHJlc3VsdHMnO1xuICB9XG5cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbml0IChvcHRzKSB7XG4gICAgc3VwZXIuaW5pdChvcHRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhLCB2YWwpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IGRhdGEuc2VjdGlvbnMgfHwgW107XG4gICAgY29uc3Qgc2VhcmNoU3RhdGUgPSBkYXRhLnNlYXJjaFN0YXRlIHx8IFNlYXJjaFN0YXRlcy5QUkVfU0VBUkNIO1xuICAgIHJldHVybiBzdXBlci5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2VjdGlvbnM6IFtdIH0sIGRhdGEsIHtcbiAgICAgIGlzUHJlU2VhcmNoOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlBSRV9TRUFSQ0gsXG4gICAgICBpc1NlYXJjaExvYWRpbmc6IHNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0xPQURJTkcsXG4gICAgICBpc1NlYXJjaENvbXBsZXRlOiBzZWFyY2hTdGF0ZSA9PT0gU2VhcmNoU3RhdGVzLlNFQVJDSF9DT01QTEVURSxcbiAgICAgIHNob3dOb1Jlc3VsdHM6IHNlY3Rpb25zLmxlbmd0aCA9PT0gMCxcbiAgICAgIHF1ZXJ5OiB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5RVUVSWSlcbiAgICB9KSwgdmFsKTtcbiAgfVxuXG4gIGFkZENoaWxkIChkYXRhID0ge30sIHR5cGUsIG9wdHMpIHtcbiAgICBjb25zdCBjaGlsZE9wdHMgPSB7IC4uLm9wdHMsIC4uLnRoaXMuZ2V0Q2hpbGRDb25maWcoW2RhdGFbJ3ZlcnRpY2FsQ29uZmlnSWQnXV0pIH07XG4gICAgaWYgKGNoaWxkT3B0cy51c2VBY2NvcmRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50LnR5cGUsIGNoaWxkT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGRDaGlsZChkYXRhLCB0eXBlLCBjaGlsZE9wdHMpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb25maWcgKGNvbmZpZ0lkKSB7XG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIHZlcnRpY2FsQ29uZmlnSWQ6IGNvbmZpZ0lkLFxuICAgICAgaXNVbml2ZXJzYWw6IHRydWVcbiAgICB9O1xuICAgIGxldCBjb25maWcgPSB0aGlzLl9jb25maWcuY29uZmlnO1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRDb25maWcsIHRoaXMuX2NvbmZpZ1snY29uZmlnJ11bY29uZmlnSWRdIHx8IHRoaXMuX2NvbmZpZ1snY29uZmlnJ10pO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBQYWdpbmF0aW9uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBTdG9yYWdlS2V5cyBmcm9tICcuLi8uLi8uLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZWtleXMnO1xuaW1wb3J0IERPTSBmcm9tICcuLi8uLi9kb20vZG9tJztcbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgU2VhcmNoU3RhdGVzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zZWFyY2hzdGF0ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdpbmF0aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9LCBzeXN0ZW1Db25maWcgPSB7fSkge1xuICAgIHN1cGVyKGNvbmZpZywgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0aWNhbCBrZXkgdG8gdXNlIGZvciBzZWFyY2hlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0aWNhbEtleSA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9DT05GSUcpLnZlcnRpY2FsS2V5O1xuICAgIGlmICh0eXBlb2YgdGhpcy5fdmVydGljYWxLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAndmVydGljYWxLZXkgbm90IHByb3ZpZGVkLCBidXQgbmVjZXNzYXJ5IGZvciBwYWdpbmF0aW9uJyxcbiAgICAgICAgJ1BhZ2luYXRpb25Db21wb25lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBkaXNwbGF5cyB0aGUgZmlyc3QgcGFnZSBidXR0b25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQgPSBjb25maWcuc2hvd0ZpcnN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnNob3dGaXJzdDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGRpc3BsYXlzIHRoZSBsYXN0IHBhZ2UgYnV0dG9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQgPSBjb25maWcuc2hvd0xhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuc2hvd0xhc3Q7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIHRvIGluY2x1ZGUgd2l0aCBhbGwgYW5hbHl0aWMgZXZlbnRzIHNlbnQgYnkgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYW5hbHl0aWNzT3B0aW9ucyA9IHtcbiAgICAgIHZlcnRpY2FsS2V5OiB0aGlzLl92ZXJ0aWNhbEtleVxuICAgIH07XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBOdW1iZXIob2Zmc2V0KSk7XG4gICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uub24oJ3VwZGF0ZScsIFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIG9mZnNldCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2Uuc2V0KFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQsIE51bWJlcihvZmZzZXQpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLm9uKCd1cGRhdGUnLCBTdG9yYWdlS2V5cy5WRVJUSUNBTF9SRVNVTFRTLCByZXN1bHRzID0+IHtcbiAgICAgIGlmIChyZXN1bHRzLnNlYXJjaFN0YXRlID09PSBTZWFyY2hTdGF0ZXMuU0VBUkNIX0NPTVBMRVRFKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuICdQYWdpbmF0aW9uJztcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lICgpIHtcbiAgICByZXR1cm4gJ3Jlc3VsdHMvcGFnaW5hdGlvbic7XG4gIH1cblxuICBvbk1vdW50ICgpIHtcbiAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuVkVSVElDQUxfUkVTVUxUUykgfHwge307XG4gICAgY29uc3QgbGltaXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfQ09ORklHKS5saW1pdDtcbiAgICBjb25zdCBzaG93Q29udHJvbHMgPSByZXN1bHRzLnNlYXJjaFN0YXRlID09PSAnc2VhcmNoLWNvbXBsZXRlJyAmJiByZXN1bHRzLnJlc3VsdHNDb3VudCA+IGxpbWl0O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlNFQVJDSF9PRkZTRVQpIHx8IDA7XG4gICAgaWYgKCFzaG93Q29udHJvbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c1BhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLXByZXZpb3VzJyk7XG4gICAgY29uc3QgbmV4dFBhZ2VCdXR0b24gPSBET00ucXVlcnkodGhpcy5fY29udGFpbmVyLCAnLmpzLXl4dC1QYWdpbmF0aW9uLW5leHQnKTtcbiAgICBjb25zdCBtYXhQYWdlID0gTWF0aC50cnVuYygocmVzdWx0cy5yZXN1bHRzQ291bnQgLSAxKSAvIGxpbWl0KTtcblxuICAgIERPTS5vbihwcmV2aW91c1BhZ2VCdXR0b24sICdjbGljaycsICgpID0+IHRoaXMudXBkYXRlUGFnZShvZmZzZXQgLSBsaW1pdCkpO1xuICAgIERPTS5vbihuZXh0UGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKG9mZnNldCArIGxpbWl0KSk7XG5cbiAgICBpZiAodGhpcy5fZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCkge1xuICAgICAgY29uc3QgZmlyc3RQYWdlQnV0dG9uID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgJy5qcy15eHQtUGFnaW5hdGlvbi1maXJzdCcpO1xuICAgICAgRE9NLm9uKGZpcnN0UGFnZUJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4gdGhpcy51cGRhdGVQYWdlKDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGFzdFBhZ2VCdXR0b25FbmFibGVkKSB7XG4gICAgICBjb25zdCBsYXN0UGFnZUJ1dHRvbiA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMteXh0LVBhZ2luYXRpb24tbGFzdCcpO1xuICAgICAgRE9NLm9uKGxhc3RQYWdlQnV0dG9uLCAnY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZVBhZ2UobWF4UGFnZSAqIGxpbWl0KSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUGFnZSAob2Zmc2V0KSB7XG4gICAgdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VULCBvZmZzZXQpO1xuICAgIHRoaXMuY29yZS5wZXJzaXN0ZW50U3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX09GRlNFVCwgb2Zmc2V0KTtcbiAgICB0aGlzLmNvcmUudmVydGljYWxQYWdlKHRoaXMuX3ZlcnRpY2FsS2V5LCBvZmZzZXQpO1xuICB9XG5cbiAgc2Nyb2xsVG9Ub3AgKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIC8vIFNhZmFyaVxuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgfVxuXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlZFUlRJQ0FMX1JFU1VMVFMpIHx8IHt9O1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5nZXRTdGF0ZShTdG9yYWdlS2V5cy5TRUFSQ0hfT0ZGU0VUKSB8fCAwO1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRykubGltaXQ7XG4gICAgY29uc3QgcGFnZU51bWJlciA9IG9mZnNldCAvIGxpbWl0O1xuICAgIGNvbnN0IHNob3dDb250cm9scyA9IHJlc3VsdHMuc2VhcmNoU3RhdGUgPT09ICdzZWFyY2gtY29tcGxldGUnICYmIHJlc3VsdHMucmVzdWx0c0NvdW50ID4gbGltaXQ7XG4gICAgY29uc3QgaXNNb3JlUmVzdWx0cyA9IHJlc3VsdHMucmVzdWx0c0NvdW50ID4gb2Zmc2V0ICsgbGltaXQ7XG4gICAgY29uc3QgbWF4UGFnZSA9IE1hdGgudHJ1bmMoKHJlc3VsdHMucmVzdWx0c0NvdW50IC0gMSkgLyBsaW1pdCk7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKHtcbiAgICAgIHNob3dDb250cm9sczogc2hvd0NvbnRyb2xzLFxuICAgICAgZmlyc3RQYWdlQnV0dG9uRW5hYmxlZDogdGhpcy5fZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCxcbiAgICAgIGxhc3RQYWdlQnV0dG9uRW5hYmxlZDogdGhpcy5fbGFzdFBhZ2VCdXR0b25FbmFibGVkLFxuICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlciArIDEsXG4gICAgICBzaG93Rmlyc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyID4gMSxcbiAgICAgIHNob3dQcmV2aW91c1BhZ2VCdXR0b246IHBhZ2VOdW1iZXIgPiAwLFxuICAgICAgc2hvd05leHRQYWdlQnV0dG9uOiBpc01vcmVSZXN1bHRzLFxuICAgICAgc2hvd0xhc3RQYWdlQnV0dG9uOiBwYWdlTnVtYmVyIDwgbWF4UGFnZSAtIDEsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgRE9NIGZyb20gJy4uLy4uL2RvbS9kb20nO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4uLy4uLy4uL2NvcmUvc3RvcmFnZS9zdG9yYWdla2V5cyc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uIGZyb20gJy4uLy4uLy4uL2NvcmUvbW9kZWxzL3F1ZXN0aW9uc3VibWlzc2lvbic7XG5pbXBvcnQgeyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4uLy4uLy4uL2NvcmUvYW5hbHl0aWNzL2FuYWx5dGljc2V2ZW50JztcblxuLyoqXG4gKiBDb25maWd1cmFibGUgb3B0aW9ucyBmb3IgdGhlIGNvbXBvbmVudFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgREVGQVVMVF9DT05GSUcgPSB7XG4gIC8qKlxuICAgKiBUaGUgZW50aXR5IGlkZW50aWZpZXIgdGhhdCB0aGUgcXVlc3Rpb24gaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKiBUaGlzIGlzIHR5cGljYWxseSBhbiBvcmdhbml6YXRpb24gb2JqZWN0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICAnZW50aXR5SWQnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiBDU1Mgc2VsZWN0b3IgdXNlZCB0byByZWZlcmVuY2UgdGhlIGZvcm0gZm9yIHRoZSBjb21wb25lbnQuXG4gICAqIEB0eXBlIHtzdHJpbmd9IENTUyBzZWxlY3RvclxuICAgKi9cbiAgJ2Zvcm1TZWxlY3Rvcic6ICdmb3JtJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgZS1tYWlsIGFkZHJlc3MgaW5wdXRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdlbWFpbExhYmVsJzogJ0VtYWlsJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgbmFtZSBpbnB1dFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ25hbWVMYWJlbCc6ICdOYW1lJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgcXVlc3Rpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdxdWVzdGlvbkxhYmVsJzogJ1F1ZXN0aW9uJyxcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGFiZWwgdG8gdXNlIGZvciB0aGUgUHJpdmFjeSBQb2xpY3lcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdwcml2YWN5UG9saWN5VGV4dCc6ICdCeSBzdWJtaXR0aW5nIG15IGVtYWlsIGFkZHJlc3MsIEkgY29uc2VudCB0byBiZWluZyBjb250YWN0ZWQgdmlhIGVtYWlsIGF0IHRoZSBhZGRyZXNzIHByb3ZpZGVkLicsXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSBTdWJtaXQgYnV0dG9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnYnV0dG9uTGFiZWwnOiAnU3VibWl0JyxcblxuICAvKipcbiAgICogVGhlIHRpdGxlIHRvIGRpc3BsYXkgaW4gdGhlIHRpdGxlIGJhclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3NlY3Rpb25UaXRsZSc6ICdBc2sgYSBRdWVzdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiB0byBkaXNwbGF5IGluIHRoZSB0aXRsZSBiYXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd0ZWFzZXInOiAnQ2Fu4oCZdCBmaW5kIHdoYXQgeW91XFwncmUgbG9va2luZyBmb3I/IEFzayBhIHF1ZXN0aW9uIGJlbG93LicsXG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBpY29uIHRvIHVzZSBpbiB0aGUgdGl0bGUgYmFyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnc2VjdGlvblRpdGxlSWNvbk5hbWUnOiAnc3VwcG9ydCcsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIGZlZWRiYWNrIGZvcm0gYWhlYWQgb2YgdGhlIFF1ZXN0aW9uIGlucHV0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnZGVzY3JpcHRpb24nOiAnRW50ZXIgeW91ciBxdWVzdGlvbiBhbmQgY29udGFjdCBpbmZvcm1hdGlvbiwgYW5kIHdlXFwnbGwgZ2V0IGJhY2sgdG8geW91IHdpdGggYSByZXNwb25zZSBzaG9ydGx5LicsXG5cbiAgLyoqXG4gICAqIFRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciByZXF1aXJlZCBpbnB1dHNcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICdyZXF1aXJlZElucHV0UGxhY2Vob2xkZXInOiAnKHJlcXVpcmVkKScsXG5cbiAgLyoqXG4gICAqIFRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgcXVlc3Rpb24gdGV4dCBhcmVhXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncXVlc3Rpb25JbnB1dFBsYWNlaG9sZGVyJzogJ0VudGVyIHlvdXIgcXVlc3Rpb24gaGVyZScsXG5cbiAgLyoqXG4gICAqIFRoZSBjb25maXJtYXRpb24gdGV4dCB0byBkaXNwbGF5IGFmdGVyIHN1Y2Nlc3NmdWxseSBzdWJtaXR0aW5nIGZlZWRiYWNrXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAncXVlc3Rpb25TdWJtaXNzaW9uQ29uZmlybWF0aW9uVGV4dCc6ICdUaGFuayB5b3UgZm9yIHlvdXIgcXVlc3Rpb24hJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcHJpdmFjeSBwb2xpY3kgdXJsIGxhYmVsXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICovXG4gICdwcml2YWN5UG9saWN5VXJsTGFiZWwnOiAnTGVhcm4gbW9yZSBoZXJlLicsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHByaXZhY3kgcG9saWN5IHVybFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lVcmwnOiAnJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcHJpdmFjeSBwb2xpY3kgZXJyb3IgdGV4dCwgc2hvd24gd2hlbiB0aGUgdXNlciBkb2VzIG5vdCBhZ3JlZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ByaXZhY3lQb2xpY3lFcnJvclRleHQnOiAnKiBZb3UgbXVzdCBhZ3JlZSB0byB0aGUgcHJpdmFjeSBwb2xpY3kgdG8gc3VibWl0IGEgcXVlc3Rpb24uJyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZW1haWwgZm9ybWF0IGVycm9yIHRleHQsIHNob3duIHdoZW4gdGhlIHVzZXIgc3VibWl0cyBhbiBpbnZhbGlkIGVtYWlsXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAnZW1haWxGb3JtYXRFcnJvclRleHQnOiAnKiBQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IGlzIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgJ2V4cGFuZGVkJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQgaXMgYSBjb21wb25lbnQgdGhhdCBjcmVhdGVzIGEgZm9ybVxuICogdGhhdHMgZGlzcGxheWVkIHdoZW5ldmVyIGEgcXVlcnkgaXMgcnVuLiBJdCBlbmFibGVzIHRoZSB1c2VyXG4gKiB0byBzdWJtaXQgcXVlc3Rpb25zIHRoYXQgdGhleSBjYW50IGZpbmQgdGhlIGFuc3dlciBmb3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSwgc3lzdGVtQ29uZmlnID0ge30pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRywgY29uZmlnKSwgc3lzdGVtQ29uZmlnKTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgc3RvcmFnZSBtb2RlbFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tb2R1bGVJZCA9IFN0b3JhZ2VLZXlzLlFVRVNUSU9OX1NVQk1JU1NJT047XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxvY2FsZSBhcyBzZXQgaW4gdGhlIGdsb2JhbCBjb25maWdcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxlID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuTE9DQUxFKTtcblxuICAgIC8qKlxuICAgICAqIE5PVEUoYmlsbHkpIGlmIHRoaXMgaXMgYSBwYXR0ZXJuIHdlIHdhbnQgdG8gZm9sbG93IGZvciBjb25maWd1cmF0aW9uXG4gICAgICogd2Ugc2hvdWxkIGJha2UgaXQgaW50byB0aGUgY29yZSBjbGFzcy5cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG5cbiAgICB0aGlzLmNvcmUuZ2xvYmFsU3RvcmFnZS5vbigndXBkYXRlJywgU3RvcmFnZUtleXMuUVVFUllfSUQsICgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXN0aW9uVGV4dCA9IHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLmdldFN0YXRlKFN0b3JhZ2VLZXlzLlFVRVJZKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV3IFF1ZXN0aW9uU3VibWlzc2lvbih7XG4gICAgICAgIHF1ZXN0aW9uVGV4dDogcXVlc3Rpb25UZXh0LFxuICAgICAgICBleHBhbmRlZDogdGhpcy5fY29uZmlnLmV4cGFuZGVkXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ3F1ZXN0aW9ucy9xdWVzdGlvbnN1Ym1pc3Npb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMgaW50ZXJmYWNlIGFsaWFzIGZvciB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGdldCB0eXBlICgpIHtcbiAgICByZXR1cm4gJ1FBU3VibWlzc2lvbic7XG4gIH1cblxuICAvKipcbiAgICogdmFsaWRhdGlvbkNvbmZpZyBjb250YWlucyBhIGJ1bmNoIG9mIHJ1bGVzXG4gICAqIHRoYXQgYXJlIHVzZWQgdG8gdmFsaWRhdGUgYWdpbnN0IGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICovXG4gIHZhbGlkYXRlQ29uZmlnICgpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLmVudGl0eUlkID09PSBudWxsIHx8IHRoaXMuX2NvbmZpZy5lbnRpdHlJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKFxuICAgICAgICAnYGVudGl0eUlkYCBpcyBhIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZvciBRdWVzdGlvbiBTdWJtaXNzaW9uJyxcbiAgICAgICAgJ1F1ZXN0aW9uU3VibWlzc2lvbicpO1xuICAgIH1cbiAgfVxuXG4gIGJlZm9yZU1vdW50ICgpIHtcbiAgICAvLyBBdm9pZCBtb3VudGluZyB0aGUgY29tcG9uZW50IGlmIHRoZXJlcyBubyBkYXRhXG4gICAgLy8gTm90ZSwgMSBiZWNhdXNlIGBjb25maWdgIGlzIGFsd2F5cyBwYXJ0IG9mIHRoZSBzdGF0ZS5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRTdGF0ZSgpKS5sZW5ndGggPiAxO1xuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgbGV0IHRyaWdnZXJFbCA9IERPTS5xdWVyeSh0aGlzLl9jb250YWluZXIsICcuanMtY29udGVudC12aXNpYmlsaXR5LXRvZ2dsZScpO1xuICAgIGlmICh0cmlnZ2VyRWwgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYmluZEZvcm1Ub2dnbGUodHJpZ2dlckVsKTtcbiAgICB9XG5cbiAgICBsZXQgZm9ybUVsID0gRE9NLnF1ZXJ5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY29uZmlnLmZvcm1TZWxlY3Rvcik7XG4gICAgaWYgKGZvcm1FbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEZvcm1Gb2N1cyhmb3JtRWwpO1xuICAgIHRoaXMuYmluZEZvcm1TdWJtaXQoZm9ybUVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybUZvY3VzIHdpbGwgd2lyZSB1cCB0aGUgRE9NIGZvY3VzIGV2ZW50IHRvIHNlcnZlcnNpZGUgcmVwb3J0aW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm1FbFxuICAgKi9cbiAgYmluZEZvcm1Gb2N1cyAoZm9ybUVsKSB7XG4gICAgaWYgKHRoaXMuYW5hbHl0aWNzUmVwb3J0ZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVzdGlvblRleHQgPSBET00ucXVlcnkoZm9ybUVsLCAnLmpzLXF1ZXN0aW9uLXRleHQnKTtcbiAgICBET00ub24ocXVlc3Rpb25UZXh0LCAnZm9jdXMnLCAoKSA9PiB7XG4gICAgICB0aGlzLmFuYWx5dGljc1JlcG9ydGVyLnJlcG9ydCh0aGlzLmdldEFuYWx5dGljc0V2ZW50KCdRVUVTVElPTl9GT0NVUycpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybVN1Ym1pdCBoYW5kbGVzIHN1Ym1pdHRpbmcgdGhlIHF1ZXN0aW9uIHRvIHRoZSBzZXJ2ZXIsXG4gICAqIGFuZCBzdWJtaXRzIGFuIGV2ZW50IHRvIHNlcnZlcnNpZGUgcmVwb3J0aW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm1FbFxuICAgKi9cbiAgYmluZEZvcm1TdWJtaXQgKGZvcm1FbCkge1xuICAgIERPTS5vbihmb3JtRWwsICdzdWJtaXQnLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5hbmFseXRpY3NSZXBvcnRlci5yZXBvcnQodGhpcy5nZXRBbmFseXRpY3NFdmVudCgnUVVFU1RJT05fU1VCTUlUJykpO1xuXG4gICAgICAvLyBUT0RPKGJpbGx5KSB3ZSBwcm9iYWJseSB3YW50IHRvIGRpc2FibGUgdGhlIGZvcm0gZnJvbSBiZWluZyBzdWJtaXR0ZWQgdHdpY2VcbiAgICAgIGNvbnN0IGVycm9ycyA9IHRoaXMudmFsaWRhdGUoZm9ybUVsKTtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gdGhpcy5wYXJzZShmb3JtRWwpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oZm9ybURhdGEsIGVycm9ycykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvcmUuc3VibWl0UXVlc3Rpb24oe1xuICAgICAgICAnZW50aXR5SWQnOiB0aGlzLl9jb25maWcuZW50aXR5SWQsXG4gICAgICAgICdxdWVzdGlvbkxhbmd1YWdlJzogdGhpcy5sb2NhbGUsXG4gICAgICAgICdzaXRlJzogJ0ZJUlNUUEFSVFknLFxuICAgICAgICAnbmFtZSc6IGZvcm1EYXRhLm5hbWUsXG4gICAgICAgICdlbWFpbCc6IGZvcm1EYXRhLmVtYWlsLFxuICAgICAgICAncXVlc3Rpb25UZXh0JzogZm9ybURhdGEucXVlc3Rpb25UZXh0LFxuICAgICAgICAncXVlc3Rpb25EZXNjcmlwdGlvbic6IGZvcm1EYXRhLnF1ZXN0aW9uRGVzY3JpcHRpb25cbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIG5ldyBRdWVzdGlvblN1Ym1pc3Npb24oZm9ybURhdGEsIHtcbiAgICAgICAgICAgICAgJ25ldHdvcmsnOiAnV2VcXCdyZSBzb3JyeSwgYW4gZXJyb3Igb2NjdXJyZWQuJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kRm9ybVRvZ2dsZSBoYW5kbGVzIGV4cGFuZGluZyBhbmQgbWltaW1pemluZyB0aGUgY29tcG9uZW50J3MgZm9ybS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdHJpZ2dlckVsXG4gICAqL1xuICBiaW5kRm9ybVRvZ2dsZSAodHJpZ2dlckVsKSB7XG4gICAgRE9NLm9uKHRyaWdnZXJFbCwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgbmV3IFF1ZXN0aW9uU3VibWlzc2lvbih7XG4gICAgICAgICAgLi4uZm9ybURhdGEsXG4gICAgICAgICAgJ2V4cGFuZGVkJzogIWZvcm1EYXRhLnF1ZXN0aW9uRXhwYW5kZWQsXG4gICAgICAgICAgJ3N1Ym1pdHRlZCc6IGZvcm1EYXRhLnF1ZXN0aW9uU3VibWl0dGVkIH0sXG4gICAgICAgIGZvcm1EYXRhLmVycm9ycykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBmb3JtLCBhbmQgYnVpbGRzIGEgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW5wdXQgbmFtZXNcbiAgICogYW5kIHRleHQgZmllbGRzLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHBhcnNlIChmb3JtRWwpIHtcbiAgICBjb25zdCBpbnB1dEZpZWxkcyA9IERPTS5xdWVyeUFsbChmb3JtRWwsICcuanMtcXVlc3Rpb24tZmllbGQnKTtcbiAgICBpZiAoIWlucHV0RmllbGRzIHx8IGlucHV0RmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGxldCBvYmogPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0RmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdmFsID0gaW5wdXRGaWVsZHNbaV0udmFsdWU7XG4gICAgICBpZiAoaW5wdXRGaWVsZHNbaV0udHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICB2YWwgPSBpbnB1dEZpZWxkc1tpXS5jaGVja2VkO1xuICAgICAgfVxuICAgICAgb2JqW2lucHV0RmllbGRzW2ldLm5hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBmaWVsZHMgZm9yIGNvcnJlY3QgZm9ybWF0dGluZ1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtRWxcbiAgICogQHJldHVybnMge09iamVjdH0gZXJyb3JzIG9iamVjdCBpZiBhbnkgZXJyb3JzIGZvdW5kXG4gICAqL1xuICB2YWxpZGF0ZSAoZm9ybUVsKSB7XG4gICAgbGV0IGVycm9ycyA9IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IERPTS5xdWVyeUFsbChmb3JtRWwsICcuanMtcXVlc3Rpb24tZmllbGQnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFmaWVsZHNbaV0uY2hlY2tWYWxpZGl0eSgpKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgLy8gc2V0IGZvY3VzIHN0YXRlIG9uIGZpcnN0IGVycm9yXG4gICAgICAgICAgZmllbGRzW2ldLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZHNbaV0ubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgIGVycm9yc1snZW1haWxFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghZmllbGRzW2ldLnZhbGlkaXR5LnZhbHVlTWlzc2luZykge1xuICAgICAgICAgICAgICBlcnJvcnNbJ2VtYWlsRXJyb3JUZXh0J10gPSB0aGlzLl9jb25maWcuZW1haWxGb3JtYXRFcnJvclRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGVycm9yc1snbmFtZUVycm9yJ10gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncHJpdmFjeVBvbGljeSc6XG4gICAgICAgICAgICBlcnJvcnNbJ3ByaXZhY3lQb2xpY3lFcnJvclRleHQnXSA9IHRoaXMuX2NvbmZpZy5wcml2YWN5UG9saWN5RXJyb3JUZXh0O1xuICAgICAgICAgICAgZXJyb3JzWydwcml2YWN5UG9saWN5RXJyb3InXSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdxdWVzdGlvblRleHQnOlxuICAgICAgICAgICAgZXJyb3JzWydxdWVzdGlvblRleHRFcnJvciddID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvcHRpb25zIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb250ZXh0IG9mIGEgcmVwb3J0YWJsZSBldmVudFxuICAgKi9cbiAgZ2V0QW5hbHl0aWNzRXZlbnQgKGV2ZW50VHlwZSkge1xuICAgIGNvbnN0IGFuYWx5dGljc0V2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KGV2ZW50VHlwZSk7XG4gICAgYW5hbHl0aWNzRXZlbnQuYWRkT3B0aW9ucyh7XG4gICAgICB2ZXJ0aWNhbENvbmZpZ0lkOiB0aGlzLl92ZXJ0aWNhbEtleSxcbiAgICAgIHNlYXJjaGVyOiB0aGlzLl92ZXJ0aWNhbEtleSA/ICdWRVJUSUNBTCcgOiAnVU5JVkVSU0FMJ1xuICAgIH0pO1xuICAgIHJldHVybiBhbmFseXRpY3NFdmVudDtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHSWNvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEBwYXJhbSBjb25maWcubmFtZVxuICAgKiBAcGFyYW0gY29uZmlnLnBhdGhcbiAgICogQHBhcmFtIGNvbmZpZy5jb21wbGV4Q29udGVudHNcbiAgICogQHBhcmFtIGNvbmZpZy52aWV3Qm94XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBpY29uXG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgLyoqXG4gICAgICogYW4gc3ZnIHBhdGggZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IGNvbmZpZy5wYXRoO1xuICAgIC8qKlxuICAgICAqIGlmIG5vdCB1c2luZyBhIHBhdGgsIGEgdGhlIG1hcmt1cCBmb3IgYSBjb21wbGV4IFNWR1xuICAgICAqL1xuICAgIHRoaXMuY29tcGxleENvbnRlbnRzID0gY29uZmlnLmNvbXBsZXhDb250ZW50cztcbiAgICAvKipcbiAgICAgKiB0aGUgdmlldyBib3ggZGVmaW5pdGlvbiwgZGVmYXVsdHMgdG8gMjR4MjRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmlld0JveCA9IGNvbmZpZy52aWV3Qm94IHx8ICcwIDAgMjQgMjQnO1xuICAgIC8qKlxuICAgICAqIGFjdHVhbCBjb250ZW50cyB1c2VkXG4gICAgICovXG4gICAgdGhpcy5jb250ZW50cyA9IHRoaXMucGF0aERlZmluaXRpb24oKTtcbiAgfVxuXG4gIHBhdGhEZWZpbml0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb21wbGV4Q29udGVudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXhDb250ZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gYDxwYXRoIGQ9XCIke3RoaXMucGF0aH1cIj48L3BhdGg+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBzdmcgbWFya3VwXG4gICAqL1xuICBtYXJrdXAgKCkge1xuICAgIHJldHVybiBgPHN2ZyB2aWV3Qm94PVwiJHt0aGlzLnZpZXdCb3h9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPiR7dGhpcy5jb250ZW50c308L3N2Zz5gO1xuICB9XG59XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAndGh1bWInLFxuICB2aWV3Qm94OiAnMCAwIDI0IDIyJyxcbiAgcGF0aDogJ00xNS4yNzMgMUg1LjQ1NWMtLjkwNiAwLTEuNjguNTUtMi4wMDggMS4zNDJMLjE1MyAxMC4wOTdBMi4xOSAyLjE5IDAgMDAwIDEwLjl2Mi4yYzAgMS4yMS45ODIgMi4yIDIuMTgyIDIuMmg2Ljg4M0w4LjAzIDIwLjMyN2wtLjAzMy4zNTJjMCAuNDUxLjE4Ni44NjkuNDggMS4xNjZMOS42MzMgMjNsNy4xNzgtNy4yNDlhMi4xNiAyLjE2IDAgMDAuNjQ0LTEuNTUxdi0xMWMwLTEuMjEtLjk4Mi0yLjItMi4xODItMi4yem0wIDEzLjJsLTQuNzM1IDQuNzc0TDExLjc1IDEzLjFIMi4xODJ2LTIuMmwzLjI3My03LjdoOS44MTh2MTF6TTE5LjYzNiAxSDI0djEzLjJoLTQuMzY0VjF6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncmVjZWlwdCcsXG4gIHBhdGg6ICdNMTQuNjA2IDkuNWMtLjY3MS0uNTE1LTEuNTkxLS44MzMtMi42MDYtLjgzMyAxLjAxNSAwIDEuOTM1LjMxOCAyLjYwNi44MzN6bS03Ljk4NSAwSDEuNjU1QTEuNjYgMS42NiAwIDAxMCA3LjgzM1YzLjY2N0MwIDIuNzQ3Ljc0MSAyIDEuNjU1IDJoMjAuNjlBMS42NiAxLjY2IDAgMDEyNCAzLjY2N3Y0LjE2NkExLjY2IDEuNjYgMCAwMTIyLjM0NSA5LjVoLTQuOTY2VjIySDYuNjIxVjkuNWgyLjc3M0g2LjYyem0xMC43NTgtMS42NjdoNC45NjZWMy42NjdIMS42NTV2NC4xNjZoNC45NjZ2LTIuNWgxMC43NTh2Mi41eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ3BhbnRoZW9uJyxcbiAgcGF0aDogJ005Ljk0NyAxNi41OThoLjI1MlY5LjQxMmgtLjI1MmEuNDMyLjQzMiAwIDAxLS4yMy0uMDY1Yy0uMDctLjA0My0uMTA2LS4wOTMtLjEwNi0uMTVMOS4xNSA3Ljgydi0uMTVjMC0uMDQ0LjAyOC0uMDguMDg0LS4xMDlhLjY5MS42OTEgMCAwMS4xMDUtLjA4Ni4yNTQuMjU0IDAgMDEuMTQ2LS4wNDNIMTMuNmMuMDU2IDAgLjEwNC4wMTUuMTQ2LjA0My4wNDIuMDMuMDkxLjA1OC4xNDcuMDg2YS4yNzEuMjcxIDAgMDEuMDYzLjEwOGMuMDE0LjA0My4wMDcuMDkzLS4wMi4xNWwtLjQyIDEuMzc4YS4zNzQuMzc0IDAgMDEtLjE0Ny4xNS4zNy4zNyAwIDAxLS4xOS4wNjVoLS4yNTF2Ny4xODZoLjI1MmEuMzcuMzcgMCAwMS4xODkuMDY1Yy4wNy4wNDMuMTE5LjA5My4xNDcuMTVsLjQyIDEuMzc4Yy4wMjcuMDI4LjAzNC4wNzEuMDIuMTI5YS4yNzUuMjc1IDAgMDEtLjA2My4xMjkgMS4zNjQgMS4zNjQgMCAwMC0uMTQ3LjA4Ni4yNTQuMjU0IDAgMDEtLjE0Ni4wNDNIOS40ODVhLjI1NC4yNTQgMCAwMS0uMTQ2LS4wNDMuNjkxLjY5MSAwIDAxLS4xMDUtLjA4NmMtLjA1Ni0uMDI5LS4wODQtLjA3Mi0uMDg0LS4xM3YtLjEyOGwuNDYxLTEuMzc3YzAtLjA1OC4wMzUtLjEwOC4xMDUtLjE1MWEuNDMyLjQzMiAwIDAxLjIzMS0uMDY1em01Ljc5MiAwaC4yNTJWOS40MTJoLS4yNTJhLjQzMi40MzIgMCAwMS0uMjMtLjA2NS4zNzQuMzc0IDAgMDEtLjE0OC0uMTVsLS40Mi0xLjM3N2MtLjAyNy0uMDI5LS4wMzQtLjA3Mi0uMDItLjEzYS4yNzUuMjc1IDAgMDEuMDYzLS4xMjljLjA1Ni0uMDI4LjEwNS0uMDU3LjE0Ni0uMDg2YS4yNTQuMjU0IDAgMDEuMTQ3LS4wNDNoNC4xMTRjLjA1NSAwIC4xMDQuMDE1LjE0Ni4wNDNhLjY5MS42OTEgMCAwMS4xMDUuMDg2Yy4wNTYuMDMuMDg0LjA3Mi4wODQuMTN2LjEyOWwtLjQyIDEuMzc3YS4zNzQuMzc0IDAgMDEtLjE0Ni4xNS40MzIuNDMyIDAgMDEtLjIzMS4wNjVoLS4yMXY3LjE4NmguMjFhLjQzLjQzIDAgMDEuMjMuMDY1Yy4wNy4wNDMuMTIuMDkzLjE0OC4xNWwuNDIgMS4zNzh2LjE1YzAgLjA0My0uMDI5LjA4LS4wODUuMTA4YS42OTEuNjkxIDAgMDEtLjEwNS4wODYuMjU0LjI1NCAwIDAxLS4xNDYuMDQzaC00LjExNGEuMjU0LjI1NCAwIDAxLS4xNDctLjA0MyAxLjM2NCAxLjM2NCAwIDAwLS4xNDYtLjA4Ni4yNzEuMjcxIDAgMDEtLjA2My0uMTA4Yy0uMDE0LS4wNDMtLjAwNy0uMDkzLjAyLS4xNWwuNDItMS4zNzdhLjM3NC4zNzQgMCAwMS4xNDctLjE1MS40MzIuNDMyIDAgMDEuMjMxLS4wNjV6bS0xMS43OTQtLjA4NmguMjUyVjkuNDk4aC0uMjUyYS4zMzQuMzM0IDAgMDEtLjIxLS4wNjUuMzg2LjM4NiAwIDAxLS4xMjYtLjE5M2wtLjQyLTEuMzc3YS4yNDguMjQ4IDAgMDEtLjAyLS4xNzIuODU0Ljg1NCAwIDAxLjA2My0uMTczYy4wMjgtLjA1Ny4wNy0uMS4xMjYtLjEyOWEuMzY1LjM2NSAwIDAxLjE2OC0uMDQzaDQuMDdjLjA1NyAwIC4xMTMuMDE1LjE2OS4wNDNhLjI3OC4yNzggMCAwMS4xMjYuMTMuODU0Ljg1NCAwIDAxLjA2Mi4xNzIuMjQ4LjI0OCAwIDAxLS4wMi4xNzJsLS40MiAxLjM3N2EuMzg2LjM4NiAwIDAxLS4xMjYuMTkzLjMzNC4zMzQgMCAwMS0uMjEuMDY1aC0uMjF2Ny4wMTRoLjIxYy4wODQgMCAuMTU0LjAyOS4yMS4wODZhLjY3My42NzMgMCAwMS4xMjYuMTcybC40MiAxLjM3OGEuMjQ4LjI0OCAwIDAxLjAyLjE3Mi44NTQuODU0IDAgMDEtLjA2Mi4xNzIuMjc4LjI3OCAwIDAxLS4xMjYuMTI5LjM2NS4zNjUgMCAwMS0uMTY4LjA0M0gzLjUyNmEuMzY1LjM2NSAwIDAxLS4xNjgtLjA0My4yNzguMjc4IDAgMDEtLjEyNi0uMTMuODU0Ljg1NCAwIDAxLS4wNjMtLjE3MS4yNDguMjQ4IDAgMDEuMDItLjE3MmwuNDItMS4zNzhhLjY3My42NzMgMCAwMS4xMjYtLjE3Mi4yODEuMjgxIDAgMDEuMjEtLjA4NnpNMS43NjMgNi42NThhLjcxNy43MTcgMCAwMS0uNTA0LS4xOTQuNjQ0LjY0NCAwIDAxLS4yMS0uNDk1di0uNDNhLjczLjczIDAgMDEuMTA1LS4zODcuNjguNjggMCAwMS4yNzMtLjI1OUM0LjMwOSAzLjQwMiA2LjU0IDIuMjc2IDguMTIxIDEuNTE1IDkuNzAyLjc1NSAxMC40OTMuMzYxIDEwLjQ5My4zMzJjLjUzMS0uMjU4Ljk3Mi0uMzY2IDEuMzIyLS4zMjMuMzUuMDQzLjczNC4xNjUgMS4xNTQuMzY2bDguMzEgNC41MThjLjE0LjA1OC4yNDUuMTQ0LjMxNS4yNTlhLjczLjczIDAgMDEuMTA1LjM4N3YuNDNjMCAuMjAxLS4wNy4zNjYtLjIxLjQ5NWEuNzE3LjcxNyAwIDAxLS41MDQuMTk0SDEuNzYzem0tLjcxNCAxMy4zNGEuNTQuNTQgMCAwMS4xNjgtLjM4Ny41MTYuNTE2IDAgMDEuMzc4LS4xNzJoMTkuNjQyYy4xNjggMCAuMzA4LjA1Ny40Mi4xNzJhLjU0MS41NDEgMCAwMS4xNjguMzg3di44MThhLjUyMi41MjIgMCAwMS0uMTY4LjQwOC42MDUuNjA1IDAgMDEtLjQyLjE1MUgxLjU5NWEuNTUxLjU1MSAwIDAxLS4zNzgtLjE1LjUyMi41MjIgMCAwMS0uMTY4LS40MXYtLjgxN3ptMjEuNDA1IDIuMDIyYy4xNCAwIC4yNjYuMDU4LjM3OC4xNzNhLjU5Mi41OTIgMCAwMS4xNjguNDN2LjgxOGEuNTQxLjU0MSAwIDAxLS4xNjguMzg3LjUxNi41MTYgMCAwMS0uMzc4LjE3MkwuNTQ2IDIzLjk1N2EuNTE2LjUxNiAwIDAxLS4zNzgtLjE3Mi41NDEuNTQxIDAgMDEtLjE2OC0uMzg3di0uODE4YS41OS41OSAwIDAxLjE2OC0uNDMuNTE2LjUxNiAwIDAxLjM3OC0uMTczbDIxLjkwOC4wNDN6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnbWljJyxcbiAgcGF0aDogJ00xMiAxNWMxLjY2IDAgMi45OS0xLjM0IDIuOTktM0wxNSA2YzAtMS42Ni0xLjM0LTMtMy0zUzkgNC4zNCA5IDZ2NmMwIDEuNjYgMS4zNCAzIDMgM3ptNS4zLTNjMCAzLTIuNTQgNS4xLTUuMyA1LjFTNi43IDE1IDYuNyAxMkg1YzAgMy40MSAyLjcyIDYuMjMgNiA2LjcyVjIyaDJ2LTMuMjhjMy4yOC0uNDggNi0zLjMgNi02LjcyaC0xLjd6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnZGlyZWN0aW9ucycsXG4gIHBhdGg6ICdNMjMuNjQ5IDExLjE1NEwxMi44NDYuMzVhMS4xOTUgMS4xOTUgMCAwMC0xLjY5MiAwTC4zNSAxMS4xNTRhMS4xOTUgMS4xOTUgMCAwMDAgMS42OTJMMTEuMTU0IDIzLjY1YTEuMTk1IDEuMTk1IDAgMDAxLjY5MiAwTDIzLjY1IDEyLjg0NmMuNDY4LS40NTYuNDY4LTEuMjEyIDAtMS42OTJ6bS05LjI1NCAzLjg1M3YtMy4wMDFIOS41OTN2My42aC0yLjR2LTQuOGMwLS42Ni41NC0xLjIgMS4yLTEuMmg2LjAwMlY2LjYwNGw0LjIgNC4yLTQuMiA0LjIwMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjYWxlbmRhcicsXG4gIHBhdGg6ICdNMTguMTExIDEzLjJIMTJ2Nmg2LjExMXYtNnpNMTYuODkgMHYyLjRINy4xMVYwSDQuNjY3djIuNEgzLjQ0NGMtMS4zNTYgMC0yLjQzMiAxLjA4LTIuNDMyIDIuNEwxIDIxLjZDMSAyMi45MiAyLjA4OCAyNCAzLjQ0NCAyNGgxNy4xMTJDMjEuOSAyNCAyMyAyMi45MiAyMyAyMS42VjQuOGMwLTEuMzItMS4xLTIuNC0yLjQ0NC0yLjRoLTEuMjIzVjBIMTYuODl6bTMuNjY3IDIxLjZIMy40NDRWOC40aDE3LjExMnYxMy4yeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2NhbGxvdXQnLFxuICBwYXRoOiAnTTIxLjk5IDRjMC0xLjEtLjg5LTItMS45OS0ySDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTRsNCA0LS4wMS0xOHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdpbmZvJyxcbiAgcGF0aDogJ00xMiA4LjRBMS4yIDEuMiAwIDEwMTIgNmExLjIgMS4yIDAgMDAwIDIuNHpNMTIgMGM2LjYyNCAwIDEyIDUuMzc2IDEyIDEycy01LjM3NiAxMi0xMiAxMlMwIDE4LjYyNCAwIDEyIDUuMzc2IDAgMTIgMHptMCAxOGMuNjYgMCAxLjItLjU0IDEuMi0xLjJWMTJjMC0uNjYtLjU0LTEuMi0xLjItMS4yLS42NiAwLTEuMi41NC0xLjIgMS4ydjQuOGMwIC42Ni41NCAxLjIgMS4yIDEuMnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdicmllZmNhc2UnLFxuICBwYXRoOiAnTTIwIDdoLTRWNWMwLTEuMTEtLjg5LTItMi0yaC00Yy0xLjExIDAtMiAuODktMiAydjJINGMtMS4xMSAwLTEuOTkuODktMS45OSAyTDIgMjBjMCAxLjExLjg5IDIgMiAyaDE2YzEuMTEgMCAyLS44OSAyLTJWOWMwLTEuMTEtLjg5LTItMi0yem0tNiAwaC00VjVoNHYyeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2thYm9iJyxcbiAgdmlld0JveDogJzAgMCAzIDExJyxcbiAgY29tcGxleENvbnRlbnRzOiBgPGNpcmNsZSBjeD1cIjEuNVwiIGN5PVwiMS41XCIgcj1cIjEuNVwiLz48Y2lyY2xlIGN4PVwiMS41XCIgY3k9XCI1LjVcIiByPVwiMS41XCIvPjxjaXJjbGUgY3g9XCIxLjVcIiBjeT1cIjkuNVwiIHI9XCIxLjVcIi8+YFxufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAncGVyc29uJyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNOSA5YzIuNDg2IDAgNC41LTIuMDE0IDQuNS00LjVTMTEuNDg2IDAgOSAwYTQuNDk5IDQuNDk5IDAgMDAtNC41IDQuNUM0LjUgNi45ODYgNi41MTQgOSA5IDl6bTAgMi4yNWMtMy4wMDQgMC05IDEuNTA4LTkgNC41djEuMTI1QzAgMTcuNDk0LjUwNiAxOCAxLjEyNSAxOGgxNS43NWMuNjE5IDAgMS4xMjUtLjUwNiAxLjEyNS0xLjEyNVYxNS43NWMwLTIuOTkyLTUuOTk2LTQuNS05LTQuNXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdtYWduaWZ5aW5nX2dsYXNzJyxcbiAgcGF0aDogJ00xNi4xMjQgMTMuMDUxYTUuMTU0IDUuMTU0IDAgMTEwLTEwLjMwOCA1LjE1NCA1LjE1NCAwIDAxMCAxMC4zMDhNMTYuMTE0IDBhNy44ODYgNy44ODYgMCAwMC02LjQ2IDEyLjQwN0wwIDIyLjA2IDEuOTQgMjRsOS42NTMtOS42NTNBNy44ODYgNy44ODYgMCAxMDE2LjExMyAwJ1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnb2ZmaWNlJyxcbiAgcGF0aDogJ00xMiA3VjNIMnYxOGgyMFY3SDEyek02IDE5SDR2LTJoMnYyem0wLTRINHYtMmgydjJ6bTAtNEg0VjloMnYyem0wLTRINFY1aDJ2MnptNCAxMkg4di0yaDJ2MnptMC00SDh2LTJoMnYyem0wLTRIOFY5aDJ2MnptMC00SDhWNWgydjJ6bTEwIDEyaC04di0yaDJ2LTJoLTJ2LTJoMnYtMmgtMlY5aDh2MTB6bS0yLThoLTJ2Mmgydi0yem0wIDRoLTJ2Mmgydi0yeidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2xpbmsnLFxuICBwYXRoOiAnTTIuMjggMTJBMy43MjMgMy43MjMgMCAwMTYgOC4yOGg0LjhWNkg2Yy0zLjMxMiAwLTYgMi42ODgtNiA2czIuNjg4IDYgNiA2aDQuOHYtMi4yOEg2QTMuNzIzIDMuNzIzIDAgMDEyLjI4IDEyem00LjkyIDEuMmg5LjZ2LTIuNEg3LjJ2Mi40ek0xOCA2aC00Ljh2Mi4yOEgxOEEzLjcyMyAzLjcyMyAwIDAxMjEuNzIgMTIgMy43MjMgMy43MjMgMCAwMTE4IDE1LjcyaC00LjhWMThIMThjMy4zMTIgMCA2LTIuNjg4IDYtNnMtMi42ODgtNi02LTZ6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAnd2luZG93JyxcbiAgcGF0aDogJ00zIDEzaDhWM0gzdjEwem0wIDhoOHYtNkgzdjZ6bTEwIDBoOFYxMWgtOHYxMHptMC0xOHY2aDhWM2gtOHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwaG9uZScsXG4gIHBhdGg6ICdNNC44MjcgMTAuMzg3YTIwLjE5OCAyMC4xOTggMCAwMDguNzg2IDguNzg2bDIuOTM0LTIuOTMzYy4zNi0uMzYuODkzLS40OCAxLjM2LS4zMmExNS4yMSAxNS4yMSAwIDAwNC43Ni43NmMuNzMzIDAgMS4zMzMuNiAxLjMzMyAxLjMzM3Y0LjY1NEMyNCAyMy40IDIzLjQgMjQgMjIuNjY3IDI0IDEwLjE0NyAyNCAwIDEzLjg1MyAwIDEuMzMzIDAgLjYuNiAwIDEuMzMzIDBINmMuNzMzIDAgMS4zMzMuNiAxLjMzMyAxLjMzMyAwIDEuNjY3LjI2NyAzLjI2Ny43NiA0Ljc2LjE0Ny40NjcuMDQuOTg3LS4zMzMgMS4zNmwtMi45MzMgMi45MzR6J1xufSk7XG4iLCJpbXBvcnQgU1ZHSWNvbiBmcm9tICcuL2ljb24uanMnO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFNWR0ljb24oe1xuICBuYW1lOiAndGFnJyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNMTcuNDY5IDguNjIybC04LjEtOC4xQTEuNzg5IDEuNzg5IDAgMDA4LjEgMEgxLjhDLjgxIDAgMCAuODEgMCAxLjh2Ni4zYzAgLjQ5NS4xOTguOTQ1LjUzMSAxLjI3OGw4LjEgOC4xYy4zMjQuMzI0Ljc3NC41MjIgMS4yNjkuNTIyYTEuNzYgMS43NiAwIDAwMS4yNjktLjUzMWw2LjMtNi4zQTEuNzYgMS43NiAwIDAwMTggOS45YzAtLjQ5NS0uMjA3LS45NTQtLjUzMS0xLjI3OHpNMy4xNSA0LjVjLS43NDcgMC0xLjM1LS42MDMtMS4zNS0xLjM1IDAtLjc0Ny42MDMtMS4zNSAxLjM1LTEuMzUuNzQ3IDAgMS4zNS42MDMgMS4zNSAxLjM1IDAgLjc0Ny0uNjAzIDEuMzUtMS4zNSAxLjM1eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2RvY3VtZW50JyxcbiAgcGF0aDogJ000IDZIMnYxNGMwIDEuMS45IDIgMiAyaDE0di0ySDRWNnptMTYtNEg4Yy0xLjEgMC0yIC45LTIgMnYxMmMwIDEuMS45IDIgMiAyaDEyYzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS0xIDlIOVY5aDEwdjJ6bS00IDRIOXYtMmg2djJ6bTQtOEg5VjVoMTB2MnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdjaGV2cm9uJyxcbiAgdmlld0JveDogJzAgMCA3IDknLFxuICBjb21wbGV4Q29udGVudHM6IGA8ZyBmaWxsLXJ1bGU9XCJldmVub2RkXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xIC04KVwiPjxwYXRoIGQ9XCJtMi42NDE3MDA0IDgtMS4xNDE3MDA0IDEuMDU3NSAzLjcwODUwMjAyIDMuNDQyNS0zLjcwODUwMjAyIDMuNDQyNSAxLjE0MTcwMDQgMS4wNTc1IDQuODU4Mjk5Ni00LjV6XCIvPjwvZz5gXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdzdXBwb3J0JyxcbiAgcGF0aDogJ00xMiwwIEM1LjM3NiwwIDAsNS4zNzYgMCwxMiBDMCwxOC42MjQgNS4zNzYsMjQgMTIsMjQgQzE4LjYyNCwyNCAyNCwxOC42MjQgMjQsMTIgQzI0LDUuMzc2IDE4LjYyNCwwIDEyLDAgWiBNMTMsMTkgTDExLDE5IEwxMSwxNyBMMTMsMTcgTDEzLDE5IFogTTE1LjA3LDExLjI1IEwxNC4xNywxMi4xNyBDMTMuNDUsMTIuOSAxMywxMy41IDEzLDE1IEwxMSwxNSBMMTEsMTQuNSBDMTEsMTMuNCAxMS40NSwxMi40IDEyLjE3LDExLjY3IEwxMy40MSwxMC40MSBDMTMuNzgsMTAuMDUgMTQsOS41NSAxNCw5IEMxNCw3LjkgMTMuMSw3IDEyLDcgQzEwLjksNyAxMCw3LjkgMTAsOSBMOCw5IEM4LDYuNzkgOS43OSw1IDEyLDUgQzE0LjIxLDUgMTYsNi43OSAxNiw5IEMxNiw5Ljg4IDE1LjY0LDEwLjY4IDE1LjA3LDExLjI1IFonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICd5ZXh0JyxcbiAgdmlld0JveDogJzAgMCAzMCAzMCcsXG4gIHBhdGg6ICdNMjUuNTE3IDI4LjE0MnYuMDk1aC0uMjA0di45MDVoLS4wNjZ2LS45MDVoLS4xOTd2LS4wOTVoLjQ2N3ptLjY2NyAwaC4wNjZ2MWgtLjA2NnYtLjgyNWwtLjI0LjU5NWgtLjAxM2wtLjI0LS41OTV2LjgyNWgtLjA2NnYtMWguMDY2bC4yNDcuNjEuMjQ2LS42MXpNMTUgMjguOGM3LjYyMiAwIDEzLjgtNi4xNzggMTMuOC0xMy44IDAtNy42MjItNi4xNzgtMTMuOC0xMy44LTEzLjhDNy4zNzggMS4yIDEuMiA3LjM3OCAxLjIgMTVjMCA3LjYyMiA2LjE3OCAxMy44IDEzLjggMTMuOHpNMTUgMGM4LjI4NCAwIDE1IDYuNzE2IDE1IDE1IDAgOC4yODQtNi43MTYgMTUtMTUgMTUtOC4yODQgMC0xNS02LjcxNi0xNS0xNUMwIDYuNzE2IDYuNzE2IDAgMTUgMHptLjQ1IDE2LjY1di0xLjJoNi42djEuMmgtMi43djUuNGgtMS4ydi01LjRoLTIuN3ptLTEuNTk5LTEuMzVsLjg0OS44NDktMi42MDEgMi42MDEgMi42MDEgMi42MDEtLjg0OS44NDktMi42MDEtMi42MDFMOC42NDkgMjIuMmwtLjg0OS0uODQ5IDIuNjAxLTIuNjAxTDcuOCAxNi4xNDlsLjg0OS0uODQ5IDIuNjAxIDIuNjAxIDIuNjAxLTIuNjAxek0xOC42NzUgOWEyLjE3NSAyLjE3NSAwIDAwLTEuODQ3IDMuMzIzbDIuOTk1LTIuOTk1QTIuMTYzIDIuMTYzIDAgMDAxOC42NzUgOXptMCA1LjU1YTMuMzc1IDMuMzc1IDAgMTEyLjgzMy01LjIwOWwtMy43ODkgMy43ODhhMi4xNzUgMi4xNzUgMCAwMDMuMTMtMS45NTRoMS4yMDFhMy4zNzUgMy4zNzUgMCAwMS0zLjM3NSAzLjM3NXptLTcuNDI1LTMuNzM0TDEzLjc4IDcuOGwuOTIuNzcxLTIuODUgMy4zOTd2Mi41ODJoLTEuMnYtMi41ODJMNy44IDguNTdsLjkyLS43NzEgMi41MyAzLjAxNnonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdwaW4nLFxuICB2aWV3Qm94OiAnMCAwIDEzIDE4JyxcbiAgcGF0aDogJ205LjM3NSAwYy0zLjUyNDQ2NDI5IDAtNi4zNzUgMi44MTctNi4zNzUgNi4zIDAgNC43MjUgNi4zNzUgMTEuNyA2LjM3NSAxMS43czYuMzc1LTYuOTc1IDYuMzc1LTExLjdjMC0zLjQ4My0yLjg1MDUzNTctNi4zLTYuMzc1LTYuM3ptLjAwMDAwMDE4IDguNTUwMDAwMDdjLTEuMjU2Nzg1NzYgMC0yLjI3Njc4NTc5LTEuMDA4LTIuMjc2Nzg1NzktMi4yNXMxLjAyMDAwMDAzLTIuMjUgMi4yNzY3ODU3OS0yLjI1YzEuMjU2Nzg1NzIgMCAyLjI3Njc4NTgyIDEuMDA4IDIuMjc2Nzg1ODIgMi4yNXMtMS4wMjAwMDAxIDIuMjUtMi4yNzY3ODU4MiAyLjI1eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2dlYXInLFxuICBwYXRoOiAnTTEyIDEwYy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnptNy03SDVhMiAyIDAgMDAtMiAydjE0YTIgMiAwIDAwMiAyaDE0YTIgMiAwIDAwMi0yVjVhMiAyIDAgMDAtMi0yem0tMS43NSA5YzAgLjIzLS4wMi40Ni0uMDUuNjhsMS40OCAxLjE2Yy4xMy4xMS4xNy4zLjA4LjQ1bC0xLjQgMi40MmMtLjA5LjE1LS4yNy4yMS0uNDMuMTVsLTEuNzQtLjdjLS4zNi4yOC0uNzYuNTEtMS4xOC42OWwtLjI2IDEuODVjLS4wMy4xNy0uMTguMy0uMzUuM2gtMi44Yy0uMTcgMC0uMzItLjEzLS4zNS0uMjlsLS4yNi0xLjg1Yy0uNDMtLjE4LS44Mi0uNDEtMS4xOC0uNjlsLTEuNzQuN2MtLjE2LjA2LS4zNCAwLS40My0uMTVsLTEuNC0yLjQyYS4zNTMuMzUzIDAgMDEuMDgtLjQ1bDEuNDgtMS4xNmMtLjAzLS4yMy0uMDUtLjQ2LS4wNS0uNjkgMC0uMjMuMDItLjQ2LjA1LS42OGwtMS40OC0xLjE2YS4zNTMuMzUzIDAgMDEtLjA4LS40NWwxLjQtMi40MmMuMDktLjE1LjI3LS4yMS40My0uMTVsMS43NC43Yy4zNi0uMjguNzYtLjUxIDEuMTgtLjY5bC4yNi0xLjg1Yy4wMy0uMTcuMTgtLjMuMzUtLjNoMi44Yy4xNyAwIC4zMi4xMy4zNS4yOWwuMjYgMS44NWMuNDMuMTguODIuNDEgMS4xOC42OWwxLjc0LS43Yy4xNi0uMDYuMzQgMCAuNDMuMTVsMS40IDIuNDJjLjA5LjE1LjA1LjM0LS4wOC40NWwtMS40OCAxLjE2Yy4wMy4yMy4wNS40Ni4wNS42OXonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdsaWdodF9idWxiJyxcbiAgdmlld0JveDogJzAgMCAzMiAzNScsXG4gIHBhdGg6ICdNMTEuNTg1IDMxLjA1Nmw4LjM4LS40OTN2LS45ODZsLTguMzguNDkzek0xMS41ODUgMzMuMDI4TDE1Ljc3NSAzNWw0LjE5LTEuOTcyVjMxLjU1bC04LjM4LjQ5M3YuOTg2em02LjkyNi0uNDA3bC0yLjczNiAxLjI5LTIuMTMtMS4wMDQgNC44NjYtLjI4NnpNMTUuNzc1IDcuMzk0Yy00LjYzIDAtOC4zOCAzLjIwNS04LjM4IDguMzggMCA1LjE3NyA0LjE5IDYuOTAyIDQuMTkgMTIuODE4di40OTNsOC4zOC0uNDkzYzAtNS45MTYgNC4xOS04LjE4OCA0LjE5LTEyLjgxN2E4LjM4IDguMzggMCAwMC04LjM4LTguMzh6bTUuNjE3IDEzLjQ4Yy0xLjAyNSAxLjgzNy0yLjE3NCAzLjg5Mi0yLjM4MSA2Ljc4NmwtNi40NC4zOGMtLjEyOS0zLjAxLTEuMjktNS4wMjEtMi4zMi02LjgwOC0uNDkzLS44LS45MjgtMS42MzYtMS4yOTktMi41aDEzLjU1NmMtLjMyNS43MDgtLjcwNCAxLjQwMy0xLjExNiAyLjE0MnptMS40NzktMy4xMjhIOC42MjdhNy43OTMgNy43OTMgMCAwMS0uMjQ3LTEuOTcxYzAtNC4zNTMgMy4wNDItNy4zOTUgNy4zOTUtNy4zOTVhNy4zOTQgNy4zOTQgMCAwMTcuMzk0IDcuMzk1IDYuNzM5IDYuNzM5IDAgMDEtLjMgMS45NzFoLjAwMnpNMjYuNjIgMTUuMjgyaDQuOTN2MWgtNC45M3pNMjMuMDk0IDcuNzU2bDIuMDkxLTIuMDkxLjY5OC42OTctMi4wOTIgMi4wOTJ6TTE1LjI4MiAwaDF2NC45M2gtMXpNNS42NjYgNi4zNjJsLjY5Ny0uNjk3IDIuMDkxIDIuMDkxLS42OTcuNjk3ek0wIDE1LjI4Mmg0LjkzdjFIMHonXG59KTtcbiIsImltcG9ydCBTVkdJY29uIGZyb20gJy4vaWNvbi5qcyc7XG5leHBvcnQgZGVmYXVsdCBuZXcgU1ZHSWNvbih7XG4gIG5hbWU6ICdyZWNlaXB0JyxcbiAgdmlld0JveDogJzAgMCAxOCAxOCcsXG4gIHBhdGg6ICdNOC45OTEgMEM0LjAyMyAwIDAgNC4wMzIgMCA5czQuMDIzIDkgOC45OTEgOUMxMy45NjggMTggMTggMTMuOTY4IDE4IDlzLTQuMDMyLTktOS4wMDktOXptMy44MTYgMTQuNEw5IDEyLjEwNSA1LjE5MyAxNC40bDEuMDA4LTQuMzI5LTMuMzU3LTIuOTA3IDQuNDI4LS4zNzhMOSAyLjdsMS43MjggNC4wNzcgNC40MjguMzc4LTMuMzU3IDIuOTA3eidcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2Nsb3NlJyxcbiAgY29tcGxleENvbnRlbnRzOiBgXG4gICAgPHBhdGggZD1cIk03IDhsOS43MTYgOS43MTZtMC05LjcxNkw3IDE3LjcxNlwiIFxuICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIi8+XG4gIGBcbn0pO1xuIiwiaW1wb3J0IFNWR0ljb24gZnJvbSAnLi9pY29uLmpzJztcbmV4cG9ydCBkZWZhdWx0IG5ldyBTVkdJY29uKHtcbiAgbmFtZTogJ2VsZW1lbnRzJyxcbiAgcGF0aDogJ00xMywxNSBMMTMsMTcgTDIxLDE3IEwyMSwxOSBMMTMsMTkgTDEzLDIxIEwxMSwyMSBMMTEsMTUgTDEzLDE1IFogTTksMTcgTDksMTkgTDMsMTkgTDMsMTcgTDksMTcgWiBNOSwxNSBMNywxNSBMNywxMyBMMywxMyBMMywxMSBMNywxMSBMNyw5IEw5LDkgTDksMTUgWiBNMjEsMTEgTDIxLDEzIEwxMSwxMyBMMTEsMTEgTDIxLDExIFogTTE3LDMgTDE3LDUgTDIxLDUgTDIxLDcgTDE3LDcgTDE3LDkgTDE1LDkgTDE1LDMgTDE3LDMgWiBNMTMsNSBMMTMsNyBMMyw3IEwzLDUgTDEzLDUgWidcbn0pO1xuIiwiaW1wb3J0IHRodW1iSWNvbiBmcm9tICcuL3RodW1iLmpzJztcbmltcG9ydCByZWNlaXB0SWNvbiBmcm9tICcuL3JlY2VpcHQuanMnO1xuaW1wb3J0IHBhbnRoZW9uSWNvbiBmcm9tICcuL3BhbnRoZW9uLmpzJztcbmltcG9ydCBtaWNJY29uIGZyb20gJy4vbWljLmpzJztcbmltcG9ydCBkaXJlY3Rpb25zSWNvbiBmcm9tICcuL2RpcmVjdGlvbnMuanMnO1xuaW1wb3J0IGNhbGVuZGFySWNvbiBmcm9tICcuL2NhbGVuZGFyLmpzJztcbmltcG9ydCBjYWxsb3V0SWNvbiBmcm9tICcuL2NhbGxvdXQuanMnO1xuaW1wb3J0IGluZm9JY29uIGZyb20gJy4vaW5mby5qcyc7XG5pbXBvcnQgYnJpZWZjYXNlSWNvbiBmcm9tICcuL2JyaWVmY2FzZS5qcyc7XG5pbXBvcnQga2Fib2JJY29uIGZyb20gJy4va2Fib2IuanMnO1xuaW1wb3J0IHBlcnNvbkljb24gZnJvbSAnLi9wZXJzb24uanMnO1xuaW1wb3J0IG1hZ25pZnlpbmdHbGFzc0ljb24gZnJvbSAnLi9tYWduaWZ5aW5nX2dsYXNzLmpzJztcbmltcG9ydCBvZmZpY2VJY29uIGZyb20gJy4vb2ZmaWNlLmpzJztcbmltcG9ydCBsaW5rSWNvbiBmcm9tICcuL2xpbmsuanMnO1xuaW1wb3J0IHdpbmRvd0ljb24gZnJvbSAnLi93aW5kb3cuanMnO1xuaW1wb3J0IHBob25lSWNvbiBmcm9tICcuL3Bob25lLmpzJztcbmltcG9ydCB0YWdJY29uIGZyb20gJy4vdGFnLmpzJztcbmltcG9ydCBkb2N1bWVudEljb24gZnJvbSAnLi9kb2N1bWVudC5qcyc7XG5pbXBvcnQgY2hldnJvbkljb24gZnJvbSAnLi9jaGV2cm9uLmpzJztcbmltcG9ydCBzdXBwb3J0SWNvbiBmcm9tICcuL3N1cHBvcnQuanMnO1xuaW1wb3J0IHlleHRJY29uIGZyb20gJy4veWV4dC5qcyc7XG5pbXBvcnQgcGluSWNvbiBmcm9tICcuL3Bpbi5qcyc7XG5pbXBvcnQgZ2Vhckljb24gZnJvbSAnLi9nZWFyLmpzJztcbmltcG9ydCBsaWdodEJ1bGJJY29uIGZyb20gJy4vbGlnaHRfYnVsYi5qcyc7XG5pbXBvcnQgc3Rhckljb24gZnJvbSAnLi9zdGFyLmpzJztcbmltcG9ydCBjbG9zZSBmcm9tICcuL2Nsb3NlLmpzJztcbmltcG9ydCBlbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJztcblxuY29uc3QgaWNvbnNBcnJheSA9IFtcbiAgdGh1bWJJY29uLFxuICByZWNlaXB0SWNvbixcbiAgcGFudGhlb25JY29uLFxuICBtaWNJY29uLFxuICBkaXJlY3Rpb25zSWNvbixcbiAgY2FsZW5kYXJJY29uLFxuICBjYWxsb3V0SWNvbixcbiAgaW5mb0ljb24sXG4gIGJyaWVmY2FzZUljb24sXG4gIGthYm9iSWNvbixcbiAgcGVyc29uSWNvbixcbiAgbWFnbmlmeWluZ0dsYXNzSWNvbixcbiAgb2ZmaWNlSWNvbixcbiAgbGlua0ljb24sXG4gIHdpbmRvd0ljb24sXG4gIHBob25lSWNvbixcbiAgdGFnSWNvbixcbiAgZG9jdW1lbnRJY29uLFxuICBjaGV2cm9uSWNvbixcbiAgc3VwcG9ydEljb24sXG4gIHlleHRJY29uLFxuICBwaW5JY29uLFxuICBnZWFySWNvbixcbiAgbGlnaHRCdWxiSWNvbixcbiAgZWxlbWVudHMsXG4gIGNsb3NlXG5dO1xuXG5jb25zdCBJY29ucyA9IHt9O1xuXG5pY29uc0FycmF5LmZvckVhY2goaWNvbiA9PiB7XG4gIEljb25zW2ljb24ubmFtZV0gPSBpY29uLm1hcmt1cCgpO1xufSk7XG5cbkljb25zLmRlZmF1bHQgPSBzdGFySWNvbi5tYXJrdXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbnM7XG4iLCIvKiogQG1vZHVsZSBJY29uQ29tcG9uZW50ICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCBJY29ucyBmcm9tICcuLi8uLi9pY29ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogSWNvbkNvbXBvbmVudFxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcGFyYW0gb3B0cy5pY29uTmFtZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gb3B0cy5jdXN0b21JY29uIHtzdHJpbmd9XG4gICAqIEBwYXJhbSBvcHRzLmljb25Vcmwge3N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30sIHN5c3RlbU9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMsIHN5c3RlbU9wdHMpO1xuXG4gICAgLyoqXG4gICAgICogbmFtZSBvZiBhbiBpY29uIGZyb20gdGhlIGRlZmF1bHQgaWNvbiBzZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWNvbk5hbWUgPSBvcHRzLmljb25OYW1lIHx8ICdkZWZhdWx0JztcblxuICAgIC8qKlxuICAgICAqIHRoZSBtYXJrdXAgZm9yIGEgZnVsbHkgY3VzdG9tIGljb25cbiAgICAgKiBAdHlwZSB7KnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY3VzdG9tSWNvbiA9IG9wdHMuY3VzdG9tSWNvbiB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIHRoZSB1cmwgdG8gYSBjdXN0b20gaW1hZ2UgaWNvblxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaWNvblVybCA9IG9wdHMuaWNvblVybCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldHRlciBmb3IgdGhlIGltYWdlIHBhc3RlZCB0byBoYW5kbGViYXJzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW1hZ2UgKCkge1xuICAgIGlmICh0aGlzLmN1c3RvbUljb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUljb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaWNvblVybCkge1xuICAgICAgcmV0dXJuIGA8aW1nIHNyYz1cIiR7dGhpcy5pY29uVXJsfVwiIGFsdD1cIlwiIGNsYXNzPVwiSWNvbi1pbWFnZVwiPmA7XG4gICAgfVxuXG4gICAgaWYgKEljb25zW3RoaXMuaWNvbk5hbWVdKSB7XG4gICAgICByZXR1cm4gSWNvbnNbdGhpcy5pY29uTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEljb25zLmRlZmF1bHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiAnSWNvbkNvbXBvbmVudCc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHRvIHJlbmRlclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0VGVtcGxhdGVOYW1lIChjb25maWcpIHtcbiAgICByZXR1cm4gJ2ljb25zL2ljb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIGFsbG93aW5nIGR1cGxpY2F0ZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3RhdGljIGFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogb3ZlcnJpZGVzIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSB0byBwcm92aWRlIG5hbWUgYW5kIG1hcmt1cFxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcmV0dXJucyB7SWNvbkNvbXBvbmVudH1cbiAgICovXG4gIHNldFN0YXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgaW1hZ2U6IHRoaXMuaW1hZ2UsXG4gICAgICBuYW1lOiB0aGlzLmljb25OYW1lID8gdGhpcy5pY29uTmFtZSA6ICdjdXN0b20nXG4gICAgfSkpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50JztcblxuaW1wb3J0IE5hdmlnYXRpb25Db21wb25lbnQgZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb25jb21wb25lbnQnO1xuXG5pbXBvcnQgU2VhcmNoQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL3NlYXJjaGNvbXBvbmVudCc7XG5pbXBvcnQgRmlsdGVyU2VhcmNoQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL2ZpbHRlcnNlYXJjaGNvbXBvbmVudCc7XG5pbXBvcnQgQXV0b0NvbXBsZXRlQ29tcG9uZW50IGZyb20gJy4vc2VhcmNoL2F1dG9jb21wbGV0ZWNvbXBvbmVudCc7XG5pbXBvcnQgU3BlbGxDaGVja0NvbXBvbmVudCBmcm9tICcuL3NlYXJjaC9zcGVsbGNoZWNrY29tcG9uZW50JztcbmltcG9ydCBMb2NhdGlvbkJpYXNDb21wb25lbnQgZnJvbSAnLi9zZWFyY2gvbG9jYXRpb25iaWFzY29tcG9uZW50JztcblxuaW1wb3J0IEZpbHRlckJveENvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZmlsdGVyYm94Y29tcG9uZW50JztcbmltcG9ydCBGaWx0ZXJPcHRpb25zQ29tcG9uZW50IGZyb20gJy4vZmlsdGVycy9maWx0ZXJvcHRpb25zY29tcG9uZW50JztcbmltcG9ydCBSYW5nZUZpbHRlckNvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvcmFuZ2VmaWx0ZXJjb21wb25lbnQnO1xuaW1wb3J0IERhdGVSYW5nZUZpbHRlckNvbXBvbmVudCBmcm9tICcuL2ZpbHRlcnMvZGF0ZXJhbmdlZmlsdGVyY29tcG9uZW50JztcbmltcG9ydCBGYWNldHNDb21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2ZhY2V0c2NvbXBvbmVudCc7XG5pbXBvcnQgR2VvTG9jYXRpb25Db21wb25lbnQgZnJvbSAnLi9maWx0ZXJzL2dlb2xvY2F0aW9uY29tcG9uZW50JztcblxuaW1wb3J0IERpcmVjdEFuc3dlckNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvZGlyZWN0YW5zd2VyY29tcG9uZW50JztcbmltcG9ydCBSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9yZXN1bHRzY29tcG9uZW50JztcbmltcG9ydCBBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9hY2NvcmRpb25yZXN1bHRzY29tcG9uZW50LmpzJztcbmltcG9ydCBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy91bml2ZXJzYWxyZXN1bHRzY29tcG9uZW50JztcbmltcG9ydCBQYWdpbmF0aW9uQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9wYWdpbmF0aW9uY29tcG9uZW50JztcblxuaW1wb3J0IFJlc3VsdHNJdGVtQ29tcG9uZW50IGZyb20gJy4vcmVzdWx0cy9yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvbG9jYXRpb25yZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5pbXBvcnQgRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvZXZlbnRyZXN1bHRzaXRlbWNvbXBvbmVudCc7XG5cbmltcG9ydCBQZW9wbGVSZXN1bHRzSXRlbUNvbXBvbmVudCBmcm9tICcuL3Jlc3VsdHMvcGVvcGxlcmVzdWx0c2l0ZW1jb21wb25lbnQnO1xuXG5pbXBvcnQgTWFwQ29tcG9uZW50IGZyb20gJy4vbWFwL21hcGNvbXBvbmVudCc7XG5pbXBvcnQgUXVlc3Rpb25TdWJtaXNzaW9uQ29tcG9uZW50IGZyb20gJy4vcXVlc3Rpb25zL3F1ZXN0aW9uc3VibWlzc2lvbmNvbXBvbmVudCc7XG5cbmltcG9ydCBJY29uQ29tcG9uZW50IGZyb20gJy4vaWNvbnMvaWNvbmNvbXBvbmVudC5qcyc7XG5cbmNvbnN0IENPTVBPTkVOVF9DTEFTU19MSVNUID0gW1xuICAvLyBDb3JlIENvbXBvbmVudFxuICBDb21wb25lbnQsXG5cbiAgLy8gTmF2aWdhdGlvbiBDb21wb25lbnRzXG4gIE5hdmlnYXRpb25Db21wb25lbnQsXG5cbiAgLy8gU2VhcmNoIENvbXBvbmVudHNcbiAgU2VhcmNoQ29tcG9uZW50LFxuICBGaWx0ZXJTZWFyY2hDb21wb25lbnQsXG4gIEF1dG9Db21wbGV0ZUNvbXBvbmVudCxcbiAgU3BlbGxDaGVja0NvbXBvbmVudCxcbiAgTG9jYXRpb25CaWFzQ29tcG9uZW50LFxuXG4gIC8vIEZpbHRlciBDb21wb25lbnRzXG4gIEZpbHRlckJveENvbXBvbmVudCxcbiAgRmlsdGVyT3B0aW9uc0NvbXBvbmVudCxcbiAgUmFuZ2VGaWx0ZXJDb21wb25lbnQsXG4gIERhdGVSYW5nZUZpbHRlckNvbXBvbmVudCxcbiAgRmFjZXRzQ29tcG9uZW50LFxuICBHZW9Mb2NhdGlvbkNvbXBvbmVudCxcblxuICAvLyBSZXN1bHRzIENvbXBvbmVudHNcbiAgRGlyZWN0QW5zd2VyQ29tcG9uZW50LFxuICBVbml2ZXJzYWxSZXN1bHRzQ29tcG9uZW50LFxuICBSZXN1bHRzQ29tcG9uZW50LFxuICBQYWdpbmF0aW9uQ29tcG9uZW50LFxuICBSZXN1bHRzSXRlbUNvbXBvbmVudCxcbiAgQWNjb3JkaW9uUmVzdWx0c0NvbXBvbmVudCxcbiAgTG9jYXRpb25SZXN1bHRzSXRlbUNvbXBvbmVudCxcbiAgRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCxcbiAgUGVvcGxlUmVzdWx0c0l0ZW1Db21wb25lbnQsXG4gIE1hcENvbXBvbmVudCxcblxuICAvLyBRdWVzdGlvbnMgQ29tcG9uZW50c1xuICBRdWVzdGlvblN1Ym1pc3Npb25Db21wb25lbnQsXG5cbiAgLy8gSGVscGVyIENvbXBvbmVudHNcbiAgSWNvbkNvbXBvbmVudFxuXTtcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IHJlZ2lzdHJ5IGlzIGEgbWFwIHRoYXQgY29udGFpbnNcbiAqIGFsbCBhdmFpbGFibGUgY29tcG9uZW50IGNsYXNzZXMgdXNlZCBmb3IgY3JlYXRpb24gb3IgZXh0ZW5zaW9uLlxuICogRWFjaCBjb21wb25lbnQgY2xhc3MgaGFzIGEgdW5pcXVlIHR5cGUsIHdoaWNoIGlzIHVzZWQgYXMgdGhlIGtleSBmb3IgdGhlIHJlZ2lzdHJ5XG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENvbXBvbmVudD59XG4gKi9cbmV4cG9ydCBjb25zdCBDT01QT05FTlRfUkVHSVNUUlkgPSBDT01QT05FTlRfQ0xBU1NfTElTVC5yZWR1Y2UoKHJlZ2lzdHJ5LCBjbGF6eikgPT4ge1xuICByZWdpc3RyeVtjbGF6ei50eXBlXSA9IGNsYXp6O1xuICByZXR1cm4gcmVnaXN0cnk7XG59LCB7fSk7XG4iLCIvKiogQG1vZHVsZSBDb21wb25lbnRNYW5hZ2VyICovXG5cbmltcG9ydCB7IEFuc3dlcnNDb21wb25lbnRFcnJvciB9IGZyb20gJy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycyc7XG5pbXBvcnQgRE9NIGZyb20gJy4uL2RvbS9kb20nO1xuaW1wb3J0IHsgQ09NUE9ORU5UX1JFR0lTVFJZIH0gZnJvbSAnLi9yZWdpc3RyeSc7XG5cbi8qKlxuICogQ29tcG9uZW50TWFuYWdlciBpcyBhIFNpbmdsZXRvbmUgdGhhdCBjb250YWlucyBib3RoIGFuIGludGVybmFsIHJlZ2lzdHJ5IG9mXG4gKiBlbGlnaWJsZSBjb21wb25lbnRzIHRvIGJlIGNyZWF0ZWQsIGFzIHdlbGwgYXMga2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnRcbiAqIGluc3RhbnRpYXRlZCBhbmQgYWN0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogQUxMIGNvbXBvbmVudHMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSB7Q29tcG9uZW50TWFuYWdlcn0gdmlhIGl0cyBgY3JlYXRlYCBtZXRob2QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGFjdGl2ZSBjb21wb25lbnRzIGlzIGFuIGludGVybmFsIGNvbnRhaW5lciB0byBrZWVwIHRyYWNrXG4gICAgICogb2YgYWxsIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlQ29tcG9uZW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNvcmUgbGlicmFyeSBkZXBlbmRlbmN5XG4gICAgICpcbiAgICAgKiBUaGUgQ29yZSBjb250YWlucyBib3RoIHRoZSBzdG9yYWdlIEFORCBzZXJ2aWNlcyB0aGF0IGFyZSBuZWVkZWQgZm9yIHBlcmZvcm1pbmcgb3BlcmF0aW9uc1xuICAgICAqIGxpa2Ugc2VhcmNoIGFuZCBhdXRvIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogVGhlIHN0b3JhZ2UgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIHN0YXRlIG9mIEFMTCBjb21wb25lbnRzLlxuICAgICAqIFdoZW5ldmVyIHRoZSBzdG9yYWdlIGlzIHVwZGF0ZWQsIHRoZSBzdGF0ZSBnZXRzIHB1c2hlZCBkb3duIHRvIHRoZSBuZWNlc3NhcnkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7Q29yZX1cbiAgICAgKi9cbiAgICB0aGlzLl9jb3JlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHJlbmRlcmVyIHRvIHVzZSBmb3IgYWxsIGNvbXBvbmVudHNcbiAgICAgKiBAdHlwZSB7SGFuZGxlYmFyc1JlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBhbmFseXRpY3MgcmVwb3J0ZXIgZGVwZW5kZW5jeVxuICAgICAqL1xuICAgIHRoaXMuX2FuYWx5dGljc1JlcG9ydGVyID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSAoKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICB0aGlzLmluc3RhbmNlID0gbmV3IENvbXBvbmVudE1hbmFnZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIHNldFJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRDb3JlIChjb3JlKSB7XG4gICAgdGhpcy5fY29yZSA9IGNvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBbmFseXRpY3NSZXBvcnRlciAocmVwb3J0ZXIpIHtcbiAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVycyBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgY3JlYXRpb24gYW5kIG92ZXJyaWRlLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gVGhlIENvbXBvbmVudCBDbGFzcyB0byByZWdpc3RlclxuICAgKi9cbiAgcmVnaXN0ZXIgKGNvbXBvbmVudENsYXp6KSB7XG4gICAgQ09NUE9ORU5UX1JFR0lTVFJZW2NvbXBvbmVudENsYXp6LnR5cGVdID0gY29tcG9uZW50Q2xheno7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgY29uc3RydWN0aW5nIGFueSBhbmQgYWxsIGNvbXBvbmVudHMuXG4gICAqIEl0IHdpbGwgaW5zdGFudGlhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCwgYW5kIGJvdGggYXBwbHlcbiAgICogaW5pdGlhbCBzdGF0ZSBmcm9tIHRoZSBzdG9yYWdlIGFuZCBiaW5kIGl0IHRvIHRoZSBzdG9yYWdlIGZvciB1cGRhdGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50VHlwZSBUaGUgY29tcG9uZW50IHR5cGUgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBpcGUgdG8gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICBjcmVhdGUgKGNvbXBvbmVudFR5cGUsIG9wdHMpIHtcbiAgICAvLyBFdmVyeSBjb21wb25lbnQgbmVlZHMgbG9jYWwgYWNjZXNzIHRvIHRoZSBjb21wb25lbnQgbWFuYWdlclxuICAgIC8vIGJlY2F1c2Ugc29tZXRpbWVzIGNvbXBvbmVudHMgaGF2ZSBzdWJjb21wb25lbnRzIHRoYXQgbmVlZCB0byBiZVxuICAgIC8vIGNvbnN0cnVjdGVkIGR1cmluZyBjcmVhdGlvblxuICAgIGxldCBzeXN0ZW1PcHRzID0ge1xuICAgICAgY29yZTogdGhpcy5fY29yZSxcbiAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlcixcbiAgICAgIGFuYWx5dGljc1JlcG9ydGVyOiB0aGlzLl9hbmFseXRpY3NSZXBvcnRlcixcbiAgICAgIGNvbXBvbmVudE1hbmFnZXI6IHRoaXNcbiAgICB9O1xuXG4gICAgbGV0IGNvbXBvbmVudENsYXNzID0gQ09NUE9ORU5UX1JFR0lTVFJZW2NvbXBvbmVudFR5cGVdO1xuXG4gICAgaWYgKFxuICAgICAgIWNvbXBvbmVudENsYXNzLmFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCgpICYmXG4gICAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNvbWUoYyA9PiBjLm5hbWUgPT09IG9wdHMubmFtZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBBbnN3ZXJzQ29tcG9uZW50RXJyb3IoXG4gICAgICAgIGBBbm90aGVyIGNvbXBvbmVudCB3aXRoIG5hbWUgJHtvcHRzLm5hbWV9IGFscmVhZHkgZXhpc3RzYCxcbiAgICAgICAgY29tcG9uZW50VHlwZSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgaXNUd2luOiB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNvbWUoY29tcG9uZW50ID0+IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci50eXBlID09PSBjb21wb25lbnRUeXBlKSxcbiAgICAgIC4uLm9wdHNcbiAgICB9O1xuXG4gICAgLy8gSW5zdGFudGlhdGUgb3VyIG5ldyBjb21wb25lbnQgYW5kIGtlZXAgdHJhY2sgb2YgaXRcbiAgICBsZXQgY29tcG9uZW50ID1cbiAgICAgIG5ldyBDT01QT05FTlRfUkVHSVNUUllbY29tcG9uZW50VHlwZV0oY29uZmlnLCBzeXN0ZW1PcHRzKVxuICAgICAgICAuaW5pdChjb25maWcpO1xuXG4gICAgdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGdsb2JhbCBzdG9yYWdlIHRvIHBvd2VyIHN0YXRlLCBhcHBseSB0aGUgc3RhdGVcbiAgICAvLyBmcm9tIHRoZSBzdG9yYWdlIHRvIHRoZSBjb21wb25lbnQsIGFuZCB0aGVuIGJpbmQgdGhlIGNvbXBvbmVudFxuICAgIC8vIHN0YXRlIHRvIHRoZSBzdG9yYWdlIHZpYSBpdHMgdXBkYXRlc1xuICAgIGlmICh0aGlzLl9jb3JlICYmIHRoaXMuX2NvcmUuZ2xvYmFsU3RvcmFnZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbXBvbmVudC5tb2R1bGVJZCA9PT0gdW5kZWZpbmVkIHx8IGNvbXBvbmVudC5tb2R1bGVJZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb3JlLmdsb2JhbFN0b3JhZ2VcbiAgICAgICAgLm9uKCd1cGRhdGUnLCBjb21wb25lbnQubW9kdWxlSWQsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29tcG9uZW50LnNldFN0YXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgY29tcG9uZW50IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGNvbXBvbmVudHMgYW5kIHJlbW92ZVxuICAgKiB0aGUgYXNzb2NpYXRlZCBzdG9yYWdlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZSAoY29tcG9uZW50KSB7XG4gICAgdGhpcy5fY29yZS5nbG9iYWxTdG9yYWdlLm9mZigndXBkYXRlJywgY29tcG9uZW50Lm1vZHVsZUlkKTtcblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWN0aXZlQ29tcG9uZW50cy5maW5kSW5kZXgoYyA9PiBjLm5hbWUgPT09IGNvbXBvbmVudC5uYW1lKTtcbiAgICB0aGlzLl9hY3RpdmVDb21wb25lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29tcG5lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVCeU5hbWUgKG5hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9hY3RpdmVDb21wb25lbnRzLmZpbmQoYyA9PiBjLm5hbWUgPT09IG5hbWUpO1xuICAgIGNvbXBvbmVudC5yZW1vdmUoKTtcbiAgICBET00uZW1wdHkoY29tcG9uZW50Ll9jb250YWluZXIpO1xuICB9XG5cbiAgZ2V0QWN0aXZlQ29tcG9uZW50ICh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNvbXBvbmVudHMuZmluZChjID0+IGMuY29uc3RydWN0b3IudHlwZSA9PT0gdHlwZSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIE5hdmlnYXRpb25Db25maWcgKi9cblxuZXhwb3J0IGNsYXNzIFRhYkNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSB0YWIgdGhhdCBpcyBleHBvc2VkIGZvciB0aGUgbGlua1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBsZXRlIFVSTCwgaW5jbHVkaW5nIHRoZSBwYXJhbXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudXJsID0gY29uZmlnLnVybCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlcnNpZGUgdmVydGljYWwgY29uZmlnIGlkIHRoYXQgdGhpcyBpcyByZWZlcmVuY2VkIHRvLlxuICAgICAqIEJ5IHByb3ZpZGluZyB0aGlzLCBlbmFibGVzIGR5bmFtaWMgc29ydGluZyBiYXNlZCBvbiByZXN1bHRzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jb25maWdJZCA9IGNvbmZpZy5jb25maWdJZCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhpcyB0YWIgZmlyc3QgaW4gdGhlIG9yZGVyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0ZpcnN0ID0gY29uZmlnLmlzRmlyc3QgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGFwcGx5IGEgc3BlY2lhbCBjbGFzcyB0byB0aGVcbiAgICAgKiBtYXJrdXAgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWN0aXZlIHRhYlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNBY3RpdmUgPSBjb25maWcuaXNBY3RpdmUgfHwgZmFsc2U7XG4gIH1cblxuICB2YWxpZGF0ZSAoKSB7XG4gIH1cblxuICBzdGF0aWMgZnJvbSAodGFicykge1xuICAgIGxldCB0YWJDb25maWdzID0gW107XG4gICAgaWYgKHRhYnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRhYkNvbmZpZ3M7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRhYiA9IHRhYnNbaV07XG4gICAgICB0YWJDb25maWdzLnB1c2gobmV3IFRhYkNvbmZpZyh0YWIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYkNvbmZpZ3M7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbkNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIHRoaXMudGFic0NvbmZpZyA9IFRhYkNvbmZpZy5mcm9tKGNvbmZpZy50YWJzKTtcbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgKi9cblxuaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlL2NvcmUnO1xuXG5pbXBvcnQge1xuICBUZW1wbGF0ZUxvYWRlcixcbiAgUmVuZGVyZXJzLFxuICBET01cbn0gZnJvbSAnLi91aS9pbmRleCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vdWkvY29tcG9uZW50cy9jb21wb25lbnQnO1xuXG5pbXBvcnQgRXJyb3JSZXBvcnRlciBmcm9tICcuL2NvcmUvZXJyb3JzL2Vycm9ycmVwb3J0ZXInO1xuaW1wb3J0IENvbnNvbGVFcnJvclJlcG9ydGVyIGZyb20gJy4vY29yZS9lcnJvcnMvY29uc29sZWVycm9ycmVwb3J0ZXInO1xuaW1wb3J0IHsgQW5hbHl0aWNzUmVwb3J0ZXIsIE5vb3BBbmFseXRpY3NSZXBvcnRlciB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgUGVyc2lzdGVudFN0b3JhZ2UgZnJvbSAnLi91aS9zdG9yYWdlL3BlcnNpc3RlbnRzdG9yYWdlJztcbmltcG9ydCBHbG9iYWxTdG9yYWdlIGZyb20gJy4vY29yZS9zdG9yYWdlL2dsb2JhbHN0b3JhZ2UnO1xuaW1wb3J0IHsgQW5zd2Vyc0NvbXBvbmVudEVycm9yIH0gZnJvbSAnLi9jb3JlL2Vycm9ycy9lcnJvcnMnO1xuaW1wb3J0IEFuYWx5dGljc0V2ZW50IGZyb20gJy4vY29yZS9hbmFseXRpY3MvYW5hbHl0aWNzZXZlbnQnO1xuaW1wb3J0IFN0b3JhZ2VLZXlzIGZyb20gJy4vY29yZS9zdG9yYWdlL3N0b3JhZ2VrZXlzJztcbmltcG9ydCBTZWFyY2hDb25maWcgZnJvbSAnLi9jb3JlL21vZGVscy9zZWFyY2hjb25maWcnO1xuaW1wb3J0IEF1dG9Db21wbGV0ZUFwaSBmcm9tICcuL2NvcmUvc2VhcmNoL2F1dG9jb21wbGV0ZWFwaSc7XG5pbXBvcnQgTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2UgZnJvbSAnLi9jb3JlL3NlYXJjaC9tb2NrYXV0b2NvbXBsZXRlc2VydmljZSc7XG5pbXBvcnQgUXVlc3Rpb25BbnN3ZXJBcGkgZnJvbSAnLi9jb3JlL3NlYXJjaC9xdWVzdGlvbmFuc3dlcmFwaSc7XG5pbXBvcnQgTW9ja1F1ZXN0aW9uQW5zd2VyU2VydmljZSBmcm9tICcuL2NvcmUvc2VhcmNoL21vY2txdWVzdGlvbmFuc3dlcnNlcnZpY2UnO1xuaW1wb3J0IFNlYXJjaEFwaSBmcm9tICcuL2NvcmUvc2VhcmNoL3NlYXJjaGFwaSc7XG5pbXBvcnQgTW9ja1NlYXJjaFNlcnZpY2UgZnJvbSAnLi9jb3JlL3NlYXJjaC9tb2Nrc2VhcmNoc2VydmljZSc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuL3VpL2NvbXBvbmVudHMvY29tcG9uZW50bWFuYWdlcic7XG5pbXBvcnQgTmF2aWdhdGlvbkNvbmZpZyBmcm9tICcuL2NvcmUvbW9kZWxzL25hdmlnYXRpb25jb25maWcnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL3NlcnZpY2VzL3NlYXJjaHNlcnZpY2UnKS5kZWZhdWx0fSBTZWFyY2hTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL3NlcnZpY2VzL2F1dG9jb21wbGV0ZXNlcnZpY2UnKS5kZWZhdWx0fSBBdXRvQ29tcGxldGVTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL3NlcnZpY2VzL3F1ZXN0aW9uYW5zd2Vyc2VydmljZScpLmRlZmF1bHR9IFF1ZXN0aW9uQW5zd2VyU2VydmljZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9zZXJ2aWNlcy9lcnJvcnJlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEVycm9yUmVwb3J0ZXJTZXJ2aWNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlL3NlcnZpY2VzL2FuYWx5dGljc3JlcG9ydGVyc2VydmljZScpLmRlZmF1bHR9IEFuYWx5dGljc1JlcG9ydGVyU2VydmljZSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFNlcnZpY2VzXG4gKiBAcHJvcGVydHkge1NlYXJjaFNlcnZpY2V9IHNlYXJjaFNlcnZpY2VcbiAqIEBwcm9wZXJ0eSB7QXV0b0NvbXBsZXRlU2VydmljZX0gYXV0b0NvbXBsZXRlU2VydmljZVxuICogQHByb3BlcnR5IHtRdWVzdGlvbkFuc3dlclNlcnZpY2V9IHF1ZXN0aW9uQW5zd2VyU2VydmljZVxuICogQHByb3BlcnR5IHtFcnJvclJlcG9ydGVyU2VydmljZX0gZXJyb3JSZXBvcnRlclNlcnZpY2VcbiAqL1xuXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgbG9jYWxlOiAnZW4nXG59O1xuXG4vKipcbiAqIFRoZSBtYWluIEFuc3dlcnMgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIEFuc3dlcnMge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaWYgKCFBbnN3ZXJzLnNldEluc3RhbmNlKHRoaXMpKSB7XG4gICAgICByZXR1cm4gQW5zd2Vycy5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBDb21wb25lbnQgYmFzZSBjbGFzcyBmb3IgY3VzdG9tXG4gICAgICogY29tcG9uZW50cyB0byBleHRlbmRcbiAgICAgKi9cbiAgICB0aGlzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBBbmFseXRpY3NFdmVudCBiYXNlIGNsYXNzIGZvciByZXBvcnRpbmdcbiAgICAgKiBjdXN0b20gYW5hbHl0aWNzXG4gICAgICovXG4gICAgdGhpcy5BbmFseXRpY3NFdmVudCA9IEFuYWx5dGljc0V2ZW50O1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2Ugb2YgdGhlIHJlbmRlcmVyIHRvIHVzZSBmb3IgdGhlIGNvbXBvbmVudHNcbiAgICAgKiBUaGlzIGlzIHByb3ZpZGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcnMuSGFuZGxlYmFycygpO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNvbXBvbmVudCBtYW5hZ2VyXG4gICAgICogQHR5cGUge0NvbXBvbmVudE1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb21wb25lbnRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCByZWZlcmVuY2UgdG8gdGhlIGNvcmUgYXBpXG4gICAgICogQHR5cGUge0NvcmV9XG4gICAgICovXG4gICAgdGhpcy5jb3JlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIG9uY2UgdGhlIGxpYnJhcnkgaXMgcmVhZHkuXG4gICAgICogVHlwaWNhbGx5IGZpcmVkIGFmdGVyIHRlbXBsYXRlcyBhcmUgZmV0Y2hlZCBmcm9tIHNlcnZlciBmb3IgcmVuZGVyaW5nLlxuICAgICAqL1xuICAgIHRoaXMuX29uUmVhZHkgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZWxpZ2libGVGb3JBbmFseXRpY3MgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXJ2aWNlc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3NlcnZpY2VzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBbmFseXRpY3NSZXBvcnRlclNlcnZpY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlclNlcnZpY2UgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIHNldEluc3RhbmNlIChpbnN0YW5jZSkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBpbml0IChjb25maWcpIHtcbiAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUUywgY29uZmlnKTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5hcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYGFwaUtleWAuIFR5cGUgbXVzdCBiZSB7c3RyaW5nfScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmV4cGVyaWVuY2VLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYGV4cGVyaWVuY2VLZXlgLiBUeXBlIG11c3QgYmUge3N0cmluZ30nKTtcbiAgICB9XG5cbiAgICBjb25maWcuc2VhcmNoID0gbmV3IFNlYXJjaENvbmZpZyhjb25maWcuc2VhcmNoKTtcbiAgICBjb25maWcubmF2aWdhdGlvbiA9IG5ldyBOYXZpZ2F0aW9uQ29uZmlnKGNvbmZpZy5uYXZpZ2F0aW9uKTtcblxuICAgIGNvbnN0IGdsb2JhbFN0b3JhZ2UgPSBuZXcgR2xvYmFsU3RvcmFnZSgpO1xuICAgIGNvbnN0IHBlcnNpc3RlbnRTdG9yYWdlID0gbmV3IFBlcnNpc3RlbnRTdG9yYWdlKHtcbiAgICAgIHVwZGF0ZUxpc3RlbmVyOiBjb25maWcub25TdGF0ZUNoYW5nZSxcbiAgICAgIHJlc2V0TGlzdGVuZXI6IGRhdGEgPT4gZ2xvYmFsU3RvcmFnZS5zZXRBbGwoZGF0YSlcbiAgICB9KTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldEFsbChwZXJzaXN0ZW50U3RvcmFnZS5nZXRBbGwoKSk7XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VBUkNIX0NPTkZJRywgY29uZmlnLnNlYXJjaCk7XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuTkFWSUdBVElPTl9DT05GSUcsIGNvbmZpZy5uYXZpZ2F0aW9uKTtcbiAgICBnbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5MT0NBTEUsIGNvbmZpZy5sb2NhbGUpO1xuICAgIGxldCBzZXNzaW9uVHJhY2tpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5zZXNzaW9uVHJhY2tpbmdFbmFibGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHNlc3Npb25UcmFja2luZ0VuYWJsZWQgPSBjb25maWcuc2Vzc2lvblRyYWNraW5nRW5hYmxlZDtcbiAgICB9XG4gICAgZ2xvYmFsU3RvcmFnZS5zZXQoU3RvcmFnZUtleXMuU0VTU0lPTlNfT1BUX0lOLCBzZXNzaW9uVHJhY2tpbmdFbmFibGVkKTtcblxuICAgIHRoaXMuX3NlcnZpY2VzID0gY29uZmlnLm1vY2sgPyBnZXRNb2NrU2VydmljZXMoKSA6IGdldFNlcnZpY2VzKGNvbmZpZyk7XG5cbiAgICB0aGlzLmNvcmUgPSBuZXcgQ29yZSh7XG4gICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICBnbG9iYWxTdG9yYWdlOiBnbG9iYWxTdG9yYWdlLFxuICAgICAgcGVyc2lzdGVudFN0b3JhZ2U6IHBlcnNpc3RlbnRTdG9yYWdlLFxuICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICBmaWVsZEZvcm1hdHRlcnM6IGNvbmZpZy5maWVsZEZvcm1hdHRlcnMsXG4gICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgbG9jYWxlOiBjb25maWcubG9jYWxlLFxuICAgICAgc2VhcmNoU2VydmljZTogdGhpcy5fc2VydmljZXMuc2VhcmNoU2VydmljZSxcbiAgICAgIGF1dG9Db21wbGV0ZVNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLmF1dG9Db21wbGV0ZVNlcnZpY2UsXG4gICAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IHRoaXMuX3NlcnZpY2VzLnF1ZXN0aW9uQW5zd2VyU2VydmljZVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZpZy5vblN0YXRlQ2hhbmdlICYmIHR5cGVvZiBjb25maWcub25TdGF0ZUNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uZmlnLm9uU3RhdGVDaGFuZ2UocGVyc2lzdGVudFN0b3JhZ2UuZ2V0QWxsKCksIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNcbiAgICAgIC5zZXRDb3JlKHRoaXMuY29yZSlcbiAgICAgIC5zZXRSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcblxuICAgIHRoaXMuX2VsaWdpYmxlRm9yQW5hbHl0aWNzID0gY29uZmlnLmJ1c2luZXNzSWQgIT0gbnVsbDtcbiAgICBpZiAodGhpcy5fZWxpZ2libGVGb3JBbmFseXRpY3MpIHtcbiAgICAgIC8vIFRPRE8oYW11bGxpbmdzKTogSW5pdGlhbGl6ZSB3aXRoIG90aGVyIHNlcnZpY2VzXG4gICAgICBjb25zdCByZXBvcnRlciA9IGNvbmZpZy5tb2NrXG4gICAgICAgID8gbmV3IE5vb3BBbmFseXRpY3NSZXBvcnRlcigpXG4gICAgICAgIDogbmV3IEFuYWx5dGljc1JlcG9ydGVyKFxuICAgICAgICAgIHRoaXMuY29yZSxcbiAgICAgICAgICBjb25maWcuZXhwZXJpZW5jZUtleSxcbiAgICAgICAgICBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICAgICAgY29uZmlnLmJ1c2luZXNzSWQsXG4gICAgICAgICAgY29uZmlnLmFuYWx5dGljc09wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9hbmFseXRpY3NSZXBvcnRlclNlcnZpY2UgPSByZXBvcnRlcjtcblxuICAgICAgdGhpcy5jb21wb25lbnRzLnNldEFuYWx5dGljc1JlcG9ydGVyKHJlcG9ydGVyKTtcbiAgICAgIGluaXRTY3JvbGxMaXN0ZW5lcihyZXBvcnRlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RGVmYXVsdEluaXRpYWxTZWFyY2goY29uZmlnLnNlYXJjaCk7XG5cbiAgICB0aGlzLl9vblJlYWR5ID0gY29uZmlnLm9uUmVhZHkgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBpZiAoY29uZmlnLnVzZVRlbXBsYXRlcyA9PT0gZmFsc2UgfHwgY29uZmlnLnRlbXBsYXRlQnVuZGxlKSB7XG4gICAgICBpZiAoY29uZmlnLnRlbXBsYXRlQnVuZGxlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaW5pdChjb25maWcudGVtcGxhdGVCdW5kbGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblJlYWR5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUZW1wbGF0ZXMgYXJlIGN1cnJlbnRseSBkb3dubG9hZGVkIHNlcGFyYXRlbHkgZnJvbSB0aGUgQ09SRSBhbmQgVUkgYnVuZGxlLlxuICAgIC8vIEZ1dHVyZSBlbmhhbmNlbWVudCBpcyB0byBzaGlwIHRoZSBjb21wb25lbnRzIHdpdGggdGVtcGxhdGVzIGluIGEgc2VwYXJhdGUgYnVuZGxlLlxuICAgIHRoaXMudGVtcGxhdGVzID0gbmV3IFRlbXBsYXRlTG9hZGVyKHtcbiAgICAgIHRlbXBsYXRlVXJsOiBjb25maWcudGVtcGxhdGVVcmxcbiAgICB9KS5vbkxvYWRlZCgodGVtcGxhdGVzKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluaXQodGVtcGxhdGVzKTtcblxuICAgICAgdGhpcy5fb25SZWFkeSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkb21SZWFkeSAoY2IpIHtcbiAgICBET00ub25SZWFkeShjYik7XG4gIH1cblxuICBvblJlYWR5IChjYikge1xuICAgIHRoaXMuX29uUmVhZHkgPSBjYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGN1c3RvbSBjb21wb25lbnQgdHlwZSBzbyBpdCBjYW4gYmUgY3JlYXRlZCB2aWFcbiAgICogYWRkQ29tcG9uZW50IGFuZCB1c2VkIGFzIGEgY2hpbGQgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRDbGFzc1xuICAgKi9cbiAgcmVnaXN0ZXJDb21wb25lbnRUeXBlIChjb21wb25lbnRDbGFzcykge1xuICAgIHRoaXMuY29tcG9uZW50cy5yZWdpc3Rlcihjb21wb25lbnRDbGFzcyk7XG4gIH1cblxuICBhZGRDb21wb25lbnQgKHR5cGUsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBjb250YWluZXI6IG9wdHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tcG9uZW50cy5jcmVhdGUodHlwZSwgb3B0cykubW91bnQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgQW5zd2Vyc0NvbXBvbmVudEVycm9yKCdGYWlsZWQgdG8gYWRkIGNvbXBvbmVudCcsIHR5cGUsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCAtIGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuIC0gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50IChuYW1lKSB7XG4gICAgdGhpcy5jb21wb25lbnRzLnJlbW92ZUJ5TmFtZShuYW1lKTtcbiAgfVxuXG4gIGNyZWF0ZUNvbXBvbmVudCAob3B0cykge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuY3JlYXRlKCdDb21wb25lbnQnLCBvcHRzKS5tb3VudCgpO1xuICB9XG5cbiAgcmVnaXN0ZXJIZWxwZXIgKG5hbWUsIGNiKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZWdpc3RlckhlbHBlcihuYW1lLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogT3B0IGluIG9yIG91dCBvZiBjb252ZXJ0aW9uIHRyYWNraW5nIGFuYWx5dGljc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEluXG4gICAqL1xuICBzZXRDb252ZXJzaW9uc09wdEluIChvcHRJbikge1xuICAgIGlmICh0aGlzLl9lbGlnaWJsZUZvckFuYWx5dGljcykge1xuICAgICAgdGhpcy5fYW5hbHl0aWNzUmVwb3J0ZXJTZXJ2aWNlLnNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQob3B0SW4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcHQgaW4gb3Igb3V0IG9mIHNlc3Npb24gY29va2llc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEluXG4gICAqL1xuICBzZXRTZXNzaW9uc09wdEluIChvcHRJbikge1xuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldChTdG9yYWdlS2V5cy5TRVNTSU9OU19PUFRfSU4sIG9wdEluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc2VhcmNoIHF1ZXJ5IG9uIGluaXRpYWxpemF0aW9uIGZvciB2ZXJ0aWNhbCBzZWFyY2hlcnMgdGhhdCBoYXZlIGFcbiAgICogZGVmYXVsdEluaXRpYWxTZWFyY2ggcHJvdmlkZWQsIGlmIHRoZSB1c2VyIGhhc24ndCBhbHJlYWR5IHByb3ZpZGVkIHRoZWlyXG4gICAqIG93biB2aWEgVVJMIHBhcmFtLlxuICAgKiBAcGFyYW0ge1NlYXJjaENvbmZpZ30gc2VhcmNoQ29uZmlnXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0RGVmYXVsdEluaXRpYWxTZWFyY2ggKHNlYXJjaENvbmZpZykge1xuICAgIGlmIChzZWFyY2hDb25maWcuZGVmYXVsdEluaXRpYWxTZWFyY2ggPT0gbnVsbCB8fCAhc2VhcmNoQ29uZmlnLnZlcnRpY2FsS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXBvcHVsYXRlZFF1ZXJ5ID0gdGhpcy5jb3JlLmdsb2JhbFN0b3JhZ2UuZ2V0U3RhdGUoU3RvcmFnZUtleXMuUVVFUlkpO1xuICAgIGlmIChwcmVwb3B1bGF0ZWRRdWVyeSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29yZS5nbG9iYWxTdG9yYWdlLnNldCgncXVlcnlUcmlnZ2VyJywgJ2luaXRpYWxpemUnKTtcbiAgICB0aGlzLmNvcmUuc2V0UXVlcnkoc2VhcmNoQ29uZmlnLmRlZmF1bHRJbml0aWFsU2VhcmNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm5zIHtTZXJ2aWNlc31cbiAqL1xuZnVuY3Rpb24gZ2V0U2VydmljZXMgKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHNlYXJjaFNlcnZpY2U6IG5ldyBTZWFyY2hBcGkoe1xuICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5LFxuICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgbG9jYWxlOiBjb25maWcubG9jYWxlXG4gICAgfSksXG4gICAgYXV0b0NvbXBsZXRlU2VydmljZTogbmV3IEF1dG9Db21wbGV0ZUFwaSh7XG4gICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICBleHBlcmllbmNlS2V5OiBjb25maWcuZXhwZXJpZW5jZUtleSxcbiAgICAgIGV4cGVyaWVuY2VWZXJzaW9uOiBjb25maWcuZXhwZXJpZW5jZVZlcnNpb24sXG4gICAgICBsb2NhbGU6IGNvbmZpZy5sb2NhbGVcbiAgICB9KSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBRdWVzdGlvbkFuc3dlckFwaSh7XG4gICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXlcbiAgICB9KSxcbiAgICBlcnJvclJlcG9ydGVyU2VydmljZTogbmV3IEVycm9yUmVwb3J0ZXIoe1xuICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5LFxuICAgICAgZXhwZXJpZW5jZUtleTogY29uZmlnLmV4cGVyaWVuY2VLZXksXG4gICAgICBleHBlcmllbmNlVmVyc2lvbjogY29uZmlnLmV4cGVyaWVuY2VWZXJzaW9uLFxuICAgICAgcHJpbnRWZXJib3NlOiBjb25maWcuZGVidWcsXG4gICAgICBzZW5kVG9TZXJ2ZXI6ICFjb25maWcuc3VwcHJlc3NFcnJvclJlcG9ydHNcbiAgICB9KVxuICB9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtTZXJ2aWNlc31cbiAqL1xuZnVuY3Rpb24gZ2V0TW9ja1NlcnZpY2VzICgpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWFyY2hTZXJ2aWNlOiBuZXcgTW9ja1NlYXJjaFNlcnZpY2UoKSxcbiAgICBhdXRvQ29tcGxldGVTZXJ2aWNlOiBuZXcgTW9ja0F1dG9Db21wbGV0ZVNlcnZpY2UoKSxcbiAgICBxdWVzdGlvbkFuc3dlclNlcnZpY2U6IG5ldyBNb2NrUXVlc3Rpb25BbnN3ZXJTZXJ2aWNlKCksXG4gICAgZXJyb3JSZXBvcnRlclNlcnZpY2U6IG5ldyBDb25zb2xlRXJyb3JSZXBvcnRlcigpXG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRvIHNlbmQgYW5hbHl0aWNzIGV2ZW50c1xuICogd2hlbiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBib3R0b20uIERlYm91bmNlcyBzY3JvbGwgZXZlbnRzIHNvXG4gKiB0aGV5IGFyZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHVzZXIgc3RvcHMgc2Nyb2xsaW5nXG4gKi9cbmZ1bmN0aW9uIGluaXRTY3JvbGxMaXN0ZW5lciAocmVwb3J0ZXIpIHtcbiAgY29uc3QgREVCT1VOQ0VfVElNRSA9IDEwMDtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuXG4gIGNvbnN0IHNlbmRFdmVudCA9ICgpID0+IHtcbiAgICBpZiAoKHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5wYWdlWU9mZnNldCkgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEFuYWx5dGljc0V2ZW50KCdTQ1JPTExfVE9fQk9UVE9NX09GX1BBR0UnKTtcbiAgICAgIHJlcG9ydGVyLnJlcG9ydChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEV2ZW50LCBERUJPVU5DRV9USU1FKTtcbiAgfSk7XG59XG5cbmNvbnN0IEFOU1dFUlMgPSBuZXcgQW5zd2VycygpO1xuZXhwb3J0IGRlZmF1bHQgQU5TV0VSUztcbiJdLCJuYW1lcyI6WyJQUkVfU0VBUkNIIiwiU0VBUkNIX0xPQURJTkciLCJTRUFSQ0hfQ09NUExFVEUiLCJSZXN1bHQiLCJkYXRhIiwiX3JhdyIsInJhdyIsIl9mb3JtYXR0ZWQiLCJmb3JtYXR0ZWQiLCJfaGlnaGxpZ2h0ZWQiLCJoaWdobGlnaHRlZCIsIm9yZGluYWwiLCJ0aXRsZSIsImRldGFpbHMiLCJsaW5rIiwiaWQiLCJzdWJ0aXRsZSIsIm1vZGlmaWVyIiwiYmlnRGF0ZSIsImltYWdlIiwiY2FsbHNUb0FjdGlvbiIsImNvbGxhcHNlZCIsIkhpZ2hsaWdodGVkVmFsdWUiLCJ2YWx1ZSIsInNob3J0VmFsdWUiLCJtYXRjaGVkU3Vic3RyaW5ncyIsIl9zb3J0TWF0Y2hlZFN1YnN0cmluZ3MiLCJidWlsZEhpZ2hsaWdodGVkVmFsdWUiLCJpbnZlcnRlZFN1YnN0cmluZ3MiLCJfZ2V0SW52ZXJ0ZWRTdWJzdHJpbmdzIiwibGVuZ3RoIiwidmFsIiwiaGlnaGxpZ2h0ZWRTdWJzdHJpbmdzIiwiaGlnaGxpZ2h0ZWRWYWx1ZSIsIm5leHRTdGFydCIsImoiLCJzdGFydCIsIk51bWJlciIsIm9mZnNldCIsImVuZCIsInNsaWNlIiwiam9pbiIsInNvcnQiLCJhIiwiYiIsInZhbHVlTGVuZ3RoIiwiaSIsInN1YnN0cmluZyIsIm5leHRPZmZzZXQiLCJwdXNoIiwiQW5zd2Vyc0Jhc2VFcnJvciIsImVycm9yQ29kZSIsIm1lc3NhZ2UiLCJib3VuZGFyeSIsImNhdXNlZEJ5IiwiZXJyb3JNZXNzYWdlIiwicmVwb3J0ZWQiLCJmcm9tIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0cmluZyIsInRvU3RyaW5nIiwiYnVpbHRpbkVycm9yIiwiZXJyb3IiLCJBbnN3ZXJzQmFzaWNFcnJvciIsInN0YWNrIiwiRXJyb3IiLCJBbnN3ZXJzQ29uZmlnRXJyb3IiLCJBbnN3ZXJzQ29tcG9uZW50RXJyb3IiLCJjb21wb25lbnQiLCJBbnN3ZXJzRW5kcG9pbnRFcnJvciIsIkFuc3dlcnNDb3JlRXJyb3IiLCJBbnN3ZXJzU3RvcmFnZUVycm9yIiwic3RvcmFnZUtleSIsIkFuc3dlcnNBbmFseXRpY3NFcnJvciIsImV2ZW50IiwiUmVzdWx0RmFjdG9yeSIsInJlc3VsdHNEYXRhIiwiZm9ybWF0dGVycyIsInZlcnRpY2FsSWQiLCJzb3VyY2UiLCJyZXN1bHRzIiwiZnJvbUdvb2dsZUN1c3RvbVNlYXJjaEVuZ2luZSIsImZyb21CaW5nQ3VzdG9tU2VhcmNoRW5naW5lIiwiZnJvbVplbmRlc2tTZWFyY2hFbmdpbmUiLCJmcm9tQWxnb2xpYVNlYXJjaEVuZ2luZSIsImhpZ2hsaWdodGVkRmllbGRzIiwiZnJvbUtub3dsZWRnZU1hbmFnZXIiLCJmcm9tR2VuZXJpYyIsImVudGl0eVByb2ZpbGVEYXRhIiwiaGlnaGxpZ2h0ZWRFbnRpdHlQcm9maWxlRGF0YSIsIk9iamVjdCIsImtleXMiLCJmb3JtYXR0ZWREYXRhIiwiZW50cmllcyIsImZvckVhY2giLCJmaWVsZE5hbWUiLCJmaWVsZFZhbCIsInVuZGVmaW5lZCIsImhpZ2hsaWdodGVkRmllbGRWYWwiLCJlbnRpdHlGaWVsZFZhbHVlIiwiaGlnaGxpZ2h0ZWRFbnRpdHlGaWVsZFZhbHVlIiwiaXNEaXJlY3RBbnN3ZXIiLCJoaWdobGlnaHRlZERhdGEiLCJoaWdobGlnaHRlZEZpZWxkTmFtZSIsImhpZ2hsaWdodGVkRmllbGQiLCJjb21wdXRlSGlnaGxpZ2h0ZWREYXRhIiwiaGlnaGxpZ2h0ZWREYXRhVmFsdWUiLCJpbmRleCIsIm5hbWUiLCJ0cnVuY2F0ZSIsImRlc2NyaXB0aW9uIiwid2Vic2l0ZSIsImZvcm1hdHRlZEVudGl0eVByb2ZpbGVEYXRhIiwiY29tcHV0ZUZvcm1hdHRlZERhdGEiLCJyZXN1bHREZXRhaWxzIiwiaHRtbFRpdGxlIiwicmVwbGFjZSIsImh0bWxTbmlwcGV0Iiwic25pcHBldCIsInVybCIsImh0bWxfdXJsIiwib2JqZWN0SUQiLCJzdHIiLCJsaW1pdCIsInRyYWlsaW5nIiwic2VwIiwid29yZHMiLCJzcGxpdCIsIm1heCIsInRydW5jYXRlZCIsIndvcmQiLCJTZWN0aW9uIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZXMiLCJ2ZXJ0aWNhbENvbmZpZ0lkIiwicmVzdWx0c0NvdW50IiwiZW5jb2RlZFN0YXRlIiwiYXBwbGllZFF1ZXJ5RmlsdGVycyIsIkFwcGxpZWRRdWVyeUZpbHRlciIsImZhY2V0cyIsIm1hcCIsInBhcnNlTWFwIiwidmVydGljYWxVUkwiLCJtYXBNYXJrZXJzIiwiY2VudGVyQ29vcmRpbmF0ZXMiLCJyZXN1bHQiLCJ5ZXh0RGlzcGxheUNvb3JkaW5hdGUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsIml0ZW0iLCJsYWJlbCIsIm1vZHVsZXMiLCJ1cmxzIiwic2VjdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhcHBsaWVkUXVlcnlGaWx0ZXIiLCJrZXkiLCJkaXNwbGF5S2V5IiwiZGlzcGxheVZhbHVlIiwiZmlsdGVycyIsIlVuaXZlcnNhbFJlc3VsdHMiLCJxdWVyeUlkIiwicmVzcG9uc2UiLCJEaXJlY3RBbnN3ZXIiLCJkaXJlY3RBbnN3ZXIiLCJhc3NpZ24iLCJmcmVlemUiLCJhbnN3ZXIiLCJyZWxhdGVkSXRlbSIsImZpZWxkQXBpTmFtZSIsImZpZWxkVmFsdWVzIiwiTmF2aWdhdGlvbiIsInRhYk9yZGVyIiwibmF2IiwiVmVydGljYWxSZXN1bHRzIiwibWVyZ2VkIiwiY29uY2F0IiwiU3BlbGxDaGVjayIsInF1ZXJ5IiwiY29ycmVjdGVkUXVlcnkiLCJjb3JyZWN0ZWRRdWVyeURpc3BsYXkiLCJ0eXBlIiwic2hvdWxkU2hvdyIsIm9yaWdpbmFsUXVlcnkiLCJnZXQiLCJOQVZJR0FUSU9OIiwiVU5JVkVSU0FMX1JFU1VMVFMiLCJWRVJUSUNBTF9SRVNVTFRTIiwiQVVUT0NPTVBMRVRFIiwiRElSRUNUX0FOU1dFUiIsIkZJTFRFUiIsIlFVRVJZIiwiUVVFUllfSUQiLCJGQUNFVF9GSUxURVIiLCJEWU5BTUlDX0ZJTFRFUlMiLCJQQVJBTVMiLCJHRU9MT0NBVElPTiIsIklOVEVOVFMiLCJRVUVTVElPTl9TVUJNSVNTSU9OIiwiU0VBUkNIX0NPTkZJRyIsIlNFQVJDSF9PRkZTRVQiLCJTUEVMTF9DSEVDSyIsIkxPQ0FUSU9OX0JJQVMiLCJTRVNTSU9OU19PUFRfSU4iLCJOQVZJR0FUSU9OX0NPTkZJRyIsIkxPQ0FMRSIsIkR5bmFtaWNGaWx0ZXJzIiwiZHluYW1pY0ZpbHRlcnMiLCJmIiwiZmllbGRJZCIsIm9wdGlvbnMiLCJvIiwiY291bnRMYWJlbCIsInNlbGVjdGVkIiwiZmlsdGVyIiwiU2VhcmNoSW50ZW50cyIsImludGVudHMiLCJuZWFyTWUiLCJpbmNsdWRlcyIsIkxvY2F0aW9uQmlhcyIsImFjY3VyYWN5IiwibG9jYXRpb25EaXNwbGF5TmFtZSIsIlNlYXJjaERhdGFUcmFuc2Zvcm1lciIsIlN0b3JhZ2VLZXlzIiwic2VhcmNoSW50ZW50cyIsInNwZWxsQ2hlY2siLCJsb2NhdGlvbkJpYXMiLCJRdWVzdGlvblN1Ym1pc3Npb24iLCJxdWVzdGlvbiIsImVycm9ycyIsImVtYWlsIiwicHJpdmFjeVBvbGljeSIsInF1ZXN0aW9uVGV4dCIsInF1ZXN0aW9uRGVzY3JpcHRpb24iLCJxdWVzdGlvbkV4cGFuZGVkIiwiZXhwYW5kZWQiLCJxdWVzdGlvblN1Ym1pdHRlZCIsInN1Ym1pdHRlZCIsIkZpbHRlciIsInJlc3BvbnNlRmlsdGVyIiwicGFyc2UiLCJncm91cHMiLCJncm91cEZpbHRlcnMiLCJmaWVsZCIsIm9yIiwiYW5kIiwiX2Zyb21NYXRjaGVyIiwibWluIiwibGF0IiwibG5nIiwicmFkaXVzIiwibWF0Y2hlciIsIkNvcmUiLCJjb25maWciLCJfYXBpS2V5IiwiYXBpS2V5IiwiX2V4cGVyaWVuY2VLZXkiLCJleHBlcmllbmNlS2V5IiwiX2V4cGVyaWVuY2VWZXJzaW9uIiwiZXhwZXJpZW5jZVZlcnNpb24iLCJfbG9jYWxlIiwibG9jYWxlIiwiX2ZpZWxkRm9ybWF0dGVycyIsImZpZWxkRm9ybWF0dGVycyIsImdsb2JhbFN0b3JhZ2UiLCJwZXJzaXN0ZW50U3RvcmFnZSIsIl9zZWFyY2hlciIsInNlYXJjaFNlcnZpY2UiLCJfYXV0b0NvbXBsZXRlIiwiYXV0b0NvbXBsZXRlU2VydmljZSIsIl9xdWVzdGlvbkFuc3dlciIsInF1ZXN0aW9uQW5zd2VyU2VydmljZSIsInZlcnRpY2FsS2V5IiwiYXBwZW5kIiwic2V0Iiwic2VhcmNoTG9hZGluZyIsInZlcnRpY2FsU2VhcmNoIiwiZ2V0U3RhdGUiLCJnZW9sb2NhdGlvbiIsImlzRHluYW1pY0ZpbHRlcnNFbmFibGVkIiwiX2lzRHluYW1pY0ZpbHRlcnNFbmFibGVkIiwic2tpcFNwZWxsQ2hlY2siLCJxdWVyeVRyaWdnZXIiLCJzZXNzaW9uVHJhY2tpbmdFbmFibGVkIiwidGhlbiIsInRyYW5zZm9ybVZlcnRpY2FsIiwibWVyZ2VkUmVzdWx0cyIsImFsbEZpbHRlcnMiLCJnZXRBbGwiLCJ0b3RhbEZpbHRlciIsImZhY2V0RmlsdGVyIiwiaW5wdXQiLCJxdWVyeVN0cmluZyIsInVuaXZlcnNhbFNlYXJjaCIsInRyYW5zZm9ybSIsIm5hbWVzcGFjZSIsInF1ZXJ5VW5pdmVyc2FsIiwiYmFyS2V5IiwicXVlcnlWZXJ0aWNhbCIsInF1ZXJ5RmlsdGVyIiwic3VibWl0UXVlc3Rpb24iLCJldnQiLCJtb2R1bGVJZCIsImNiIiwib24iLCJkb2N1bWVudCIsIndpbmRvdyIsIkRPTSIsImQiLCJwIiwiaHRtbCIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJmcmFnIiwiY3JlYXRlUmFuZ2UiLCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQiLCJhcHBlbmRDaGlsZCIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImJvZHkiLCJwYXJlbnQiLCJzZWxlY3RvciIsIkhUTUxFbGVtZW50IiwiV2luZG93IiwiSFRNTERvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZWFkeVN0YXRlIiwiZWwiLCJvcHRzX2RhdGEiLCJub2RlIiwicHJvcHMiLCJhZGRDbGFzcyIsImluc2VydEFkamFjZW50SFRNTCIsImNsYXNzTmFtZSIsImNsYXNzZXMiLCJsZW4iLCJjbGFzc0xpc3QiLCJhZGQiLCJpbm5lckhUTUwiLCJzdHlsZXMiLCJwcm9wIiwic3R5bGUiLCJhdHRyIiwic2V0QXR0cmlidXRlIiwiYXR0cnMiLCJzZXR0aW5ncyIsImUiLCJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3R4dCIsInRhcmdldCIsImlzRXF1YWxOb2RlIiwibWF0Y2hlcyIsInBhcmVudE5vZGUiLCJTZWFyY2hQYXJhbXMiLCJfcGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwicGFyYW1zIiwic2VhcmNoIiwiaW5kZXhPZiIsImVuY29kZWRQYXJhbXMiLCJrZXlWYWwiLCJkZWNvZGUiLCJTdHJpbmciLCJlbmNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsIlJlbmRlcmVyIiwidGVtcGxhdGUiLCJIYW5kbGViYXJzUmVuZGVyZXIiLCJ0ZW1wbGF0ZXMiLCJfaGFuZGxlYmFycyIsIl9oYiIsIl90ZW1wbGF0ZXMiLCJfcmVnaXN0ZXJDdXN0b21IZWxwZXJzIiwicmVnaXN0ZXJIZWxwZXIiLCJjb21waWxlIiwidGVtcGxhdGVOYW1lIiwiYXJnMSIsImFyZzIiLCJmbiIsImludmVyc2UiLCJwaG9uZU51bWJlclN0cmluZyIsImNsZWFuZWQiLCJpbnRsQ29kZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJyb290IiwidiIsIlJlbmRlcmVycyIsIlNPWSIsIkhhbmRsZWJhcnMiLCJMSUJfVkVSU0lPTiIsIkxJVkVfQVBJX0JBU0VfVVJMIiwiQVBJX0JBU0VfVVJMIiwiQ09NUElMRURfVEVNUExBVEVTX1VSTCIsIkFOQUxZVElDU19CQVNFX1VSTCIsIkFOQUxZVElDU19CQVNFX1VSTF9OT19DT09LSUUiLCJUZW1wbGF0ZUxvYWRlciIsInNldEluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJfdGVtcGxhdGVVcmwiLCJ0ZW1wbGF0ZVVybCIsIl9vbkxvYWRlZCIsIl9pbml0IiwiZmV0Y2hUZW1wbGF0ZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNjcmlwdCIsImNyZWF0ZUVsIiwib25sb2FkIiwib25lcnJvciIsImFzeW5jIiwic3JjIiwiY29uc29sZSIsImxvZyIsImluc3RhbmNlIiwiRXZlbnRFbWl0dGVyIiwiX2xpc3RlbmVycyIsImxpc3RlbmVycyIsImtlZXAiLCJTdGF0ZSIsIl9zdGF0ZSIsIm9wdFZhbCIsIl9zZXQiLCJlbWl0Iiwib3B0UHJvcCIsIk1ldGhvZHMiLCJHRVQiLCJQT1NUIiwiUFVUIiwiREVMRVRFIiwiSHR0cFJlcXVlc3RlciIsIm9wdHMiLCJyZXF1ZXN0IiwiZW5jb2RlUGFyYW1zIiwidXJsUGFyYW1zIiwianNvbkJvZHkiLCJyZXF1ZXN0Q29uZmlnIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJyZXFBcmdzIiwiZmV0Y2giLCJuYXZpZ2F0b3IiLCJzZW5kQmVhY29uIiwiaGFzUGFyYW0iLCJzZWFyY2hRdWVyeSIsIkFwaVJlcXVlc3QiLCJfcmVxdWVzdGVyIiwiX2Jhc2VVcmwiLCJiYXNlVXJsIiwiX2VuZHBvaW50IiwiZW5kcG9pbnQiLCJfdmVyc2lvbiIsInZlcnNpb24iLCJiYXNlUGFyYW1zIiwic2FuaXRpemVQYXJhbXMiLCJwb3N0IiwibG9jYXRpb24iLCJoYXMiLCJTZWFyY2hBcGkiLCJqc29uIiwiQW5hbHl0aWNzRXZlbnQiLCJldmVudFR5cGUiLCJ0b1VwcGVyQ2FzZSIsIkFuYWx5dGljc1JlcG9ydGVyIiwiY29yZSIsImJ1c2luZXNzSWQiLCJnbG9iYWxPcHRpb25zIiwiX2J1c2luZXNzSWQiLCJfZ2xvYmFsT3B0aW9ucyIsInNldFF1ZXJ5SWQiLCJhZGRPcHRpb25zIiwiYmVhY29uIiwidG9BcGlFdmVudCIsImlzRW5hYmxlZCIsIk5vb3BBbmFseXRpY3NSZXBvcnRlciIsIk1vZHVsZURhdGEiLCJfaWQiLCJfaGlzdG9yeSIsIl9kYXRhIiwiY2FwdHVyZVByZXZpb3VzIiwic2hpZnQiLCJwcmV2aW91cyIsIl9wcmV2aW91cyIsInBvcCIsIkdsb2JhbFN0b3JhZ2UiLCJfbW9kdWxlRGF0YUNvbnRhaW5lciIsIl9mdXR1cmVMaXN0ZW5lcnMiLCJfaW5pdERhdGFDb250YWluZXIiLCJfYXBwbHlGdXR1cmVMaXN0ZW5lcnMiLCJkYXRhS2V5Iiwic3RhcnRzV2l0aCIsIm1vZHVsZURhdGEiLCJvZmYiLCJmdXR1cmVzIiwiZnV0dXJlIiwiQ29tcG9uZW50Iiwic3lzdGVtQ29uZmlnIiwiY29uc3RydWN0b3IiLCJfY29uZmlnIiwiX3R5cGUiLCJfcGFyZW50Q29udGFpbmVyIiwicGFyZW50Q29udGFpbmVyIiwiX2NoaWxkcmVuIiwic3RhdGUiLCJjb21wb25lbnRNYW5hZ2VyIiwiYW5hbHl0aWNzUmVwb3J0ZXIiLCJfYW5hbHl0aWNzT3B0aW9ucyIsImFuYWx5dGljc09wdGlvbnMiLCJfY29udGFpbmVyIiwiX2NsYXNzTmFtZSIsIl9yZW5kZXIiLCJyZW5kZXIiLCJfcmVuZGVyZXIiLCJyZW5kZXJlciIsIl90ZW1wbGF0ZSIsIl90ZW1wbGF0ZU5hbWUiLCJkZWZhdWx0VGVtcGxhdGVOYW1lIiwiX2lzTW91bnRlZCIsInRyYW5zZm9ybURhdGEiLCJvbkNyZWF0ZSIsIm9uQ3JlYXRlT3ZlcnJpZGUiLCJiaW5kIiwib25Nb3VudCIsIm9uTW91bnRPdmVycmlkZSIsIm9uVXBkYXRlIiwib25VcGRhdGVPdmVycmlkZSIsInVzZXJPbkNyZWF0ZSIsInVzZXJPbk1vdW50IiwidXNlck9uVXBkYXRlIiwic2V0U3RhdGUiLCJ1bk1vdW50IiwibW91bnQiLCJuZXdTdGF0ZSIsImNoaWxkQ29tcG9uZW50IiwiY3JlYXRlIiwiX3BhcmVudE9wdHMiLCJjIiwicmVtb3ZlIiwiY2hpbGQiLCJlbXB0eSIsIm9uVW5Nb3VudCIsImJlZm9yZU1vdW50IiwiYXNKU09OIiwiZG9tQ29tcG9uZW50cyIsInF1ZXJ5QWxsIiwiX2NyZWF0ZVN1YmNvbXBvbmVudCIsImRvbUhvb2tzIiwiX2NyZWF0ZUFuYWx5dGljc0hvb2siLCJiZWZvcmVSZW5kZXIiLCJhZnRlclJlbmRlciIsImRvbUNvbXBvbmVudCIsImRhdGFzZXQiLCJpc0NvbXBvbmVudE1vdW50ZWQiLCJjaGlsZERhdGEiLCJhZGRDaGlsZCIsInJldmVyc2UiLCJpc0FuYWx5dGljc0F0dGFjaGVkIiwiZXZlbnR0eXBlIiwiZXZlbnRsYWJlbCIsImV2ZW50b3B0aW9ucyIsInJlcG9ydCIsIkVycm9yUmVwb3J0ZXIiLCJwcmludFZlcmJvc2UiLCJzZW5kVG9TZXJ2ZXIiLCJlcnIiLCJwcmludEVycm9yIiwidG9Kc29uIiwiQ29uc29sZUVycm9yUmVwb3J0ZXIiLCJQZXJzaXN0ZW50U3RvcmFnZSIsIl9oaXN0b3J5VGltZXIiLCJfdXBkYXRlTGlzdGVuZXIiLCJ1cGRhdGVMaXN0ZW5lciIsIl9yZXNldExpc3RlbmVyIiwicmVzZXRMaXN0ZW5lciIsIm9ucG9wc3RhdGUiLCJfY2FsbExpc3RlbmVyIiwicmVwbGFjZUhpc3RvcnkiLCJuZXdEYXRhIiwiX3VwZGF0ZUhpc3RvcnkiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiaGlzdG9yeSIsInJlcGxhY2VTdGF0ZSIsInB1c2hTdGF0ZSIsImxpc3RlbmVyIiwiYWxsUGFyYW1zIiwiU2VhcmNoQ29uZmlnIiwiZGVmYXVsdEluaXRpYWxTZWFyY2giLCJ2YWxpZGF0ZSIsIkF1dG9Db21wbGV0ZURhdGEiLCJzIiwiciIsIkF1dG9Db21wbGV0ZVJlc3VsdCIsImdldEludmVydGVkIiwiQXV0b0NvbXBsZXRlRGF0YVRyYW5zZm9ybWVyIiwiQXV0b0NvbXBsZXRlQXBpIiwic2VhcmNoUGFyYW1ldGVycyIsInZlcnRpY2FsIiwidW5pdmVyc2FsIiwidW5pdmVyc2FsT3B0aW9ucyIsInZlcnRpY2FsT3B0aW9ucyIsIk1vY2tBdXRvQ29tcGxldGVTZXJ2aWNlIiwiZW1wdHlSZXN1bHRzIiwiZmlsdGVyT3B0aW9ucyIsIm9wdCIsImxvd2VyY2FzZSIsInRvTG93ZXJDYXNlIiwicmFuZG9tU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsIlF1ZXN0aW9uQW5zd2VyQXBpIiwiZW50aXR5SWQiLCJzaXRlIiwicXVlc3Rpb25MYW5ndWFnZSIsIm1vZGUiLCJoZWFkZXJzIiwiTW9ja1F1ZXN0aW9uQW5zd2VyU2VydmljZSIsIkFSQklUUkFSWV9CVVNJTkVTU19JRCIsIk1vY2tTZWFyY2hTZXJ2aWNlIiwiX2dldE1vY2tEYXRhSnNvbiIsInJlc3AiLCJ0ZXh0IiwidXNlTW9ja0RhdGEiLCJkZWxheWVkUmVzcG9uc2UiLCJjb25zdHJ1Y3RWZXJ0aWNhbFJlc3BvbnNlIiwic2VjdGlvbiIsImZpbmQiLCJ2ZXJ0aWNhbE1vZHVsZSIsImZsb29yIiwibW9kaWZ5UmVzdWx0cyIsImdldFJlc3VsdHNGaWx0ZXJlciIsImNvbnN0cnVjdFVuaXZlcnNhbFJlc3BvbnNlIiwiY29uc3VtZXIiLCJtb2RpZnlGbiIsImZpbGxTZWN0aW9uRmllbGRzIiwibWV0YSIsInV1aWQiLCJ1dWlkVjQiLCJmYWlsZWRWZXJ0aWNhbHMiLCJxdWVyeUR1cmF0aW9uTWlsbGlzIiwicmFuZG9tSW50IiwiUkVTSVpFX0RFQk9VTkNFIiwiTU9CSUxFX0JSRUFLUE9JTlQiLCJNT0JJTEVfT1ZFUkZMT1dfQkVIQVZJT1JfT1BUSU9OIiwiQ09MTEFQU0UiLCJJTk5FUlNDUk9MTCIsIlRhYiIsImNvbmZpZ0lkIiwiaXNGaXJzdCIsImlzQWN0aXZlIiwidGFic0NvbmZpZyIsInRhYnMiLCJ0YWIiLCJOYXZpZ2F0aW9uQ29tcG9uZW50Iiwib3ZlcmZsb3dMYWJlbCIsIm92ZXJmbG93SWNvbiIsIl90YWJzQ29uZmlnIiwiX3RhYnMiLCJfdGFiT3JkZXIiLCJnZXREZWZhdWx0VGFiT3JkZXIiLCJnZXRVcmxQYXJhbXMiLCJfbmF2QnJlYWtwb2ludHMiLCJfbW9iaWxlT3ZlcmZsb3dCZWhhdmlvciIsIm1vYmlsZU92ZXJmbG93QmVoYXZpb3IiLCJfYXJpYUxhYmVsIiwiYXJpYUxhYmVsIiwiY2hlY2tPdXRzaWRlQ2xpY2siLCJjaGVja01vYmlsZU92ZXJmbG93QmVoYXZpb3IiLCJzaG91bGRDb2xsYXBzZSIsImJpbmRPdmVyZmxvd0hhbmRsZXJzIiwicmVmaXROYXYiLCJ0b2dnbGVNb3JlRHJvcGRvd24iLCJ1bmJpbmRPdmVyZmxvd0hhbmRsZXJzIiwibW9yZUJ1dHRvbiIsIm1haW5MaW5rcyIsImNvbGxhcHNlZExpbmtzIiwibmF2V2lkdGgiLCJjb250YWlucyIsIm9mZnNldFdpZHRoIiwibnVtQnJlYWtwb2ludHMiLCJtYWluTGlua3NXaWR0aCIsImNoaWxkcmVuIiwibGFzdExpbmsiLCJwcmVwZW5kIiwiZmlyc3RMaW5rIiwiY2xvc2VNb3JlRHJvcGRvd24iLCJ0b2dnbGUiLCJjbG9zZXN0IiwiX2NoZWNrTW9iaWxlT3ZlcmZsb3dCZWhhdmlvclRpbWVyIiwibWVyZ2VUYWJPcmRlciIsImdlbmVyYXRlVGFiVXJsIiwic2hvd0NvbGxhcHNlIiwidW5zaGlmdCIsIm90aGVyVGFiT3JkZXIiLCJ0YWJDb25maWciLCJTZWFyY2hDb21wb25lbnQiLCJfYmFyS2V5IiwiX3ZlcnRpY2FsS2V5IiwiX2Zvcm1FbCIsImZvcm1TZWxlY3RvciIsIl9pbnB1dEVsIiwiaW5wdXRFbCIsImxhYmVsVGV4dCIsInN1Ym1pdFRleHQiLCJzdWJtaXRJY29uIiwicHJvbXB0SGVhZGVyIiwiYXV0b0ZvY3VzIiwiY2xlYXJCdXR0b24iLCJhdXRvY29tcGxldGVPbkxvYWQiLCJyZWRpcmVjdFVybCIsIl9pc1R3aW4iLCJpc1R3aW4iLCJxIiwicGVybWlzc2lvbnMiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsImNvb3JkcyIsIl9zZWFyY2hDb29sZG93biIsInNlYXJjaENvb2xkb3duIiwiX3Byb21wdEZvckxvY2F0aW9uIiwicHJvbXB0Rm9yTG9jYXRpb24iLCJCb29sZWFuIiwiX3Nob3dDbGVhckJ1dHRvbiIsIl9hbGxvd0VtcHR5U2VhcmNoIiwiYWxsb3dFbXB0eVNlYXJjaCIsInNldFF1ZXJ5IiwiaW5pdExvY2F0aW9uUHJvbXB0IiwiZm9jdXNJbnB1dEVsZW1lbnQiLCJpbml0U2VhcmNoIiwiaW5pdEF1dG9Db21wbGV0ZSIsImluaXRDbGVhckJ1dHRvbiIsIl9hdXRvY29tcGxldGUiLCJidXR0b24iLCJpbnRlbnQiLCJmb3JtIiwicHJldmVudERlZmF1bHQiLCJocmVmIiwiYmx1ciIsImlucHV0U2VsZWN0b3IiLCJvblN1Ym1pdCIsInRyaWdnZXIiLCJfdGhyb3R0bGVkIiwiZ2V0QWN0aXZlQ29tcG9uZW50Iiwic2hvd0NsZWFyQnV0dG9uIiwiZm9jdXMiLCJGaWx0ZXJTZWFyY2hDb21wb25lbnQiLCJpbnB1dEtleSIsIl9zdG9yZU9uQ2hhbmdlIiwic3RvcmVPbkNoYW5nZSIsInNlYXJjaFRleHQiLCJfYnVpbGRTZWFyY2hQYXJhbWV0ZXJzIiwiaXNGaWx0ZXJTZWFyY2giLCJvcmlnaW5hbEZpbHRlciIsImZyb21SZXNwb25zZSIsInNldEZpbHRlciIsInNlYXJjaFBhcmFtZXRlckNvbmZpZ3MiLCJzZWN0aW9uZWQiLCJmaWVsZHMiLCJfYnVpbGRGaWVsZHMiLCJmaWVsZENvbmZpZ3MiLCJmYyIsImZldGNoRW50aXRpZXMiLCJLZXlzIiwiQkFDS1NQQUNFIiwiVEFCIiwiRU5URVIiLCJTSElGVCIsIkNUUkwiLCJBTFQiLCJFU0NBUEUiLCJMRUZUIiwiUklHSFQiLCJVUCIsIkRPV04iLCJMRUZUX09TX0tFWSIsIlJJR0hUX09TX0tFWSIsIlNFTEVDVF9LRVkiLCJBdXRvQ29tcGxldGVDb21wb25lbnQiLCJzeXN0ZW1PcHRzIiwiX2F1dG9jb21wbGV0ZUVscyIsImF1dG9Db21wbGV0ZUVscyIsIl9vcmlnaW5hbFF1ZXJ5IiwiX3NlY3Rpb25JbmRleCIsIl9yZXN1bHRJbmRleCIsIl9hdXRvRm9jdXMiLCJfb25TdWJtaXQiLCJfc2VhcmNoUGFyYW1ldGVycyIsImlzUXVlcnlJbnB1dEZvY3VzZWQiLCJoYXNSZXN1bHRzIiwic2VjdGlvbkluZGV4IiwicmVzdWx0SW5kZXgiLCJhY3RpdmVFbGVtZW50IiwicXVlcnlJbnB1dCIsImF0dHJpYnV0ZXMiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsInNwZWxsY2hlY2siLCJjbG9zZSIsInJlc2V0IiwiYXV0b0NvbXBsZXRlIiwiaGFuZGxlTmF2aWdhdGVSZXN1bHRzIiwia2V5Q29kZSIsImhhbmRsZVN1Ym1pdFJlc3VsdCIsImRlbGVnYXRlIiwidXBkYXRlUXVlcnkiLCJoYW5kbGVUeXBpbmciLCJ1cGRhdGVTdGF0ZSIsIm9wdFZhbHVlIiwicXVlcnlFbCIsImlnbm9yZWRLZXlzIiwiYXV0b0NvbXBsZXRlRmlsdGVyIiwiYXV0b0NvbXBsZXRlVmVydGljYWwiLCJhdXRvQ29tcGxldGVVbml2ZXJzYWwiLCJTcGVsbENoZWNrQ29tcG9uZW50IiwiY29ycmVjdGVkUXVlcnlVcmwiLCJfYnVpbGRSZWRpcmVjdFF1ZXJ5VXJsIiwiaGVscFRleHQiLCJfZ2V0SGVscFRleHQiLCJMb2NhdGlvbkJpYXNDb21wb25lbnQiLCJfdXBkYXRlTG9jYXRpb25FbCIsInVwZGF0ZUxvY2F0aW9uRWwiLCJfbG9jYXRpb25EaXNwbGF5TmFtZSIsIl9hY2N1cmFjeSIsIl9hbGxvd1VwZGF0ZSIsIl9kaXNhYmxlTG9jYXRpb25VcGRhdGVJZkdlb2xvY2F0aW9uRGVuaWVkIiwiX2RvU2VhcmNoIiwiY29kZSIsIl9kaXNhYmxlTG9jYXRpb25VcGRhdGUiLCJfZ2V0TG9jYXRpb25EaXNwbGF5TmFtZSIsImFjY3VyYWN5VGV4dCIsIl9nZXRBY2N1cmFjeUhlbHBUZXh0IiwiaXNQcmVjaXNlTG9jYXRpb24iLCJpc1Vua25vd25Mb2NhdGlvbiIsImFsbG93VXBkYXRlIiwiRmFjZXQiLCJhdmFpbGFibGVGaWVsZElkcyIsImZsYXRGaWx0ZXJzIiwiZmxhdE1hcCIsIiRvciIsIkZpbHRlckJveENvbmZpZyIsInNob3dDb3VudCIsInNlYXJjaE9uQ2hhbmdlIiwicmVzZXRGaWx0ZXIiLCJyZXNldEZhY2V0IiwicmVzZXRGaWx0ZXJMYWJlbCIsInJlc2V0RmFjZXRMYWJlbCIsInJlc2V0RmlsdGVycyIsInJlc2V0RmFjZXRzIiwicmVzZXRGaWx0ZXJzTGFiZWwiLCJyZXNldEZhY2V0c0xhYmVsIiwic2hvd01vcmVMaW1pdCIsInNob3dNb3JlTGFiZWwiLCJzaG93TGVzc0xhYmVsIiwic2hvd01vcmUiLCJleHBhbmQiLCJzaG93TnVtYmVyQXBwbGllZCIsImFwcGx5TGFiZWwiLCJhcHBseUJ1dHRvblNlbGVjdG9yIiwiZmlsdGVyQ29uZmlncyIsImlzRHluYW1pYyIsIkZpbHRlckJveENvbXBvbmVudCIsIl9maWx0ZXJDb21wb25lbnRzIiwiX2ZpbHRlcnMiLCJvcHRpb24iLCJzaG93UmVzZXQiLCJyZXNldExhYmVsIiwic2hvd0FwcGx5QnV0dG9uIiwic2hvd0V4cGFuZCIsIm9uQ2hhbmdlIiwib25GaWx0ZXJDaGFuZ2UiLCJnZXRGaWx0ZXIiLCJfc2F2ZUZpbHRlcnNUb1N0b3JhZ2UiLCJfc2VhcmNoIiwiY2xlYXJPcHRpb25zIiwidmFsaWRGaWx0ZXJzIiwiY29tYmluZWRGaWx0ZXIiLCJmcm9tRmlsdGVycyIsInNldEZhY2V0RmlsdGVyIiwiU1VQUE9SVEVEX0NPTlRST0xTIiwiRmlsdGVyT3B0aW9uc0NvbmZpZyIsImNvbnRyb2wiLCJvcHRpb25TZWxlY3RvciIsInByZXZpb3VzT3B0aW9ucyIsInNlbGVjdGVkT3B0aW9ucyIsInNldERlZmF1bHRTZWxlY3RlZFZhbHVlcyIsInJlZHVjZSIsIm51bVNlbGVjdGVkIiwiRmlsdGVyT3B0aW9uc0NvbXBvbmVudCIsInNlbGVjdGVkQ291bnQiLCJnZXRTZWxlY3RlZENvdW50IiwiYWxsU2hvd24iLCJpc1NpbmdsZU9wdGlvbiIsIl91cGRhdGVPcHRpb24iLCJwYXJzZUludCIsImNoZWNrZWQiLCJsZWdlbmQiLCJjbGljayIsInVwZGF0ZUxpc3RlbmVycyIsIl9idWlsZEZpbHRlciIsImVsZW1lbnRzIiwiX2FwcGx5RmlsdGVyIiwiZXF1YWwiLCJncm91cCIsIlJhbmdlRmlsdGVyQ29tcG9uZW50IiwiX2ZpZWxkIiwiX29uQ2hhbmdlIiwibWluVmFsIiwibWF4VmFsIiwiX3JhbmdlIiwiaW5pdGlhbE1pbiIsImluaXRpYWxNYXgiLCJfdGl0bGUiLCJfbWluTGFiZWwiLCJtaW5MYWJlbCIsIl9tYXhMYWJlbCIsIm1heExhYmVsIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsIl91cGRhdGVSYW5nZSIsImluY2x1c2l2ZVJhbmdlIiwiRGF0ZVJhbmdlRmlsdGVyQ29tcG9uZW50IiwiX2lzRXhjbHVzaXZlIiwiaXNFeGNsdXNpdmUiLCJ0b2RheSIsIkRhdGUiLCJ0b2RheVN0cmluZyIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImdldERhdGUiLCJtaW5EYXRlIiwibWF4RGF0ZSIsIl9kYXRlIiwiZGF0ZU1pbiIsImRhdGVNYXgiLCJkYXRlIiwiZXhjbHVzaXZlUmFuZ2UiLCJGYWNldHNDb25maWciLCJmaWVsZENvbnRyb2xzIiwiRmFjZXRzQ29tcG9uZW50IiwiX2FwcGx5QnV0dG9uU2VsZWN0b3IiLCJfZmlsdGVyYm94IiwiZW5hYmxlRHluYW1pY0ZpbHRlcnMiLCJNRVRFUlNfUEVSX01JTEUiLCJERUZBVUxUX0NPTkZJRyIsImdlb0J1dHRvbkljb24iLCJnZW9CdXR0b25UZXh0IiwiZW5hYmxlZFRleHQiLCJsb2FkaW5nVGV4dCIsImVycm9yVGV4dCIsImJ1dHRvblNlbGVjdG9yIiwiR2VvTG9jYXRpb25Db21wb25lbnQiLCJwbGFjZWhvbGRlciIsIl9lbmFibGVkIiwiZ2VvTG9hZGluZyIsImdlb0Vycm9yIiwiZ2VvRW5hYmxlZCIsImdlb1ZhbHVlIiwiZ2VvUGxhY2Vob2xkZXIiLCJfaW5pdEF1dG9Db21wbGV0ZSIsIl90b2dnbGVHZW9GaWx0ZXIiLCJfc2F2ZURhdGFUb1N0b3JhZ2UiLCJFdmVudFR5cGVzIiwiVEhVTUJTX1VQIiwiVEhVTUJTX0RPV04iLCJEaXJlY3RBbnN3ZXJDb21wb25lbnQiLCJmb3JtRWwiLCJfdGh1bWJzVXBTZWxlY3RvciIsInRodW1ic1VwU2VsZWN0b3IiLCJfdGh1bWJzRG93blNlbGVjdG9yIiwidGh1bWJzRG93blNlbGVjdG9yIiwiX3ZpZXdEZXRhaWxzVGV4dCIsInZpZXdEZXRhaWxzVGV4dCIsImhhc1N0YXRlIiwiY2hlY2tlZFZhbHVlIiwicmVwb3J0UXVhbGl0eSIsImV2ZW50T3B0aW9ucyIsInNlYXJjaGVyIiwiY3RhTGFiZWwiLCJpc0dvb2QiLCJSZXN1bHRzSXRlbUNvbXBvbmVudCIsIl92ZXJ0aWNhbENvbmZpZ0lkIiwiX2lzVW5pdmVyc2FsIiwiaXNVbml2ZXJzYWwiLCJMb2NhdGlvblJlc3VsdHNJdGVtQ29tcG9uZW50IiwiRXZlbnRSZXN1bHRzSXRlbUNvbXBvbmVudCIsIlBlb3BsZVJlc3VsdHNJdGVtQ29tcG9uZW50IiwiTWFwUHJvdmlkZXIiLCJfem9vbSIsInpvb20iLCJfZGVmYXVsdFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwiX3Nob3dFbXB0eU1hcCIsInNob3dFbXB0eU1hcCIsIl9tYXAiLCJfaXNMb2FkZWQiLCJfb25QaW5DbGljayIsIm9uUGluQ2xpY2siLCJvbkxvYWRlZCIsIl9waW5Db25maWciLCJwaW4iLCJERUZBVUxUX1BJTl9DT05GSUciLCJfY29sbGFwc2VQaW5zIiwiY29sbGFwc2VQaW5zIiwiaXNMb2FkZWQiLCJtYXBEYXRhIiwibWFya2VycyIsImxvY2F0aW9uVG9JdGVtIiwibSIsImNvbGxhcHNlZE1hcmtlcnMiLCJjb2xsYXBzZWRNYXJrZXIiLCJpY29uIiwiYW5jaG9yIiwic3ZnIiwic2NhbGVkU2l6ZSIsImxhYmVsVHlwZSIsIkdvb2dsZU1hcFByb3ZpZGVyIiwiX3pvb21PZmZzZXQiLCJfY2xpZW50SWQiLCJjbGllbnRJZCIsIl9zaWduYXR1cmUiLCJzaWduYXR1cmUiLCJoYXNWYWxpZENsaWVudENyZWRlbnRpYWxzIiwib25Mb2FkIiwiZ2VuZXJhdGVDcmVkZW50aWFscyIsImdvb2dsZSIsIm1hcHMiLCJNYXAiLCJjZW50ZXIiLCJnZXRDZW50ZXJNYXJrZXIiLCJfY29sbGFwc2VNYXJrZXJzIiwiZ29vZ2xlTWFwTWFya2VyQ29uZmlncyIsIkdvb2dsZU1hcE1hcmtlckNvbmZpZyIsImJvdW5kcyIsIkxhdExuZ0JvdW5kcyIsIm1hcmtlciIsIk1hcmtlciIsImFkZExpc3RlbmVyIiwiZXh0ZW5kIiwiZml0Qm91bmRzIiwibWFwQ2VudGVyIiwic2VyaWFsaXplZE1hcmtlcnMiLCJwaW5Db25maWciLCJwaW5Db25maWdPYmoiLCJQb2ludCIsIngiLCJ5IiwiU2l6ZSIsInciLCJoIiwiTWFwQm94TWFwUHJvdmlkZXIiLCJtYXBib3hnbCIsImFjY2Vzc1Rva2VuIiwiY3NzIiwicmVsIiwibWFwYm94TWFwTWFya2VyQ29uZmlncyIsIk1hcEJveE1hcmtlckNvbmZpZyIsIkxuZ0xhdEJvdW5kcyIsIndyYXBwZXIiLCJMbmdMYXQiLCJzZXRMbmdMYXQiLCJnZXRMbmdMYXQiLCJhZGRUbyIsImdldEVsZW1lbnQiLCJwYWRkaW5nIiwic3RhdGljTWFwUGluIiwiUHJvdmlkZXJUeXBlcyIsIk1hcENvbXBvbmVudCIsIl9tYXBQcm92aWRlciIsIm1hcFByb3ZpZGVyIiwiZ2V0UHJvdmlkZXJJbnN0YW5jZSIsImxvYWRKUyIsImluaXQiLCJSZXN1bHRUeXBlIiwiRVZFTlQiLCJMT0NBVElPTiIsIlBFT1BMRSIsIlJlc3VsdHNDb21wb25lbnQiLCJfaXRlbUNvbmZpZyIsImdsb2JhbCIsInJlbmRlckl0ZW0iLCJpdGVtVGVtcGxhdGUiLCJjb25maWd1cmVJdGVtIiwiX3VuaXZlcnNhbFVybCIsInVuaXZlcnNhbFVybCIsImlzUHJlU2VhcmNoIiwiaXNTZWFyY2hMb2FkaW5nIiwiaXNTZWFyY2hDb21wbGV0ZSIsImluY2x1ZGVNYXAiLCJtYXBDb25maWciLCJzaG93Tm9SZXN1bHRzIiwic2V0SXRlbVJlbmRlciIsInNldEl0ZW1UZW1wbGF0ZSIsImNsYXp6IiwiZ2V0SXRlbUNvbXBvbmVudCIsImNvbXAiLCJuZXdPcHRzIiwiZ2xvYmFsQ29uZmlnIiwiaXRlbUNvbmZpZyIsImhhc0dsb2JhbFJlbmRlciIsImhhc0dsb2JhbFRlbXBsYXRlIiwic2V0UmVuZGVyIiwic2V0VGVtcGxhdGUiLCJBY2NvcmRpb25SZXN1bHRzQ29tcG9uZW50IiwiX3NlbGVjdG9yQmFzZSIsInNlbGVjdG9yQmFzZSIsImNvbGxhcHNlZENsYXNzIiwic2VsZkVsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJhY2NvcmRpb25FbHMiLCJhY2NvcmRpb25FbCIsInRvZ2dsZUVsIiwidG9nZ2xlU2VsZWN0b3IiLCJjb250ZW50RWwiLCJib2R5U2VsZWN0b3IiLCJjaGFuZ2VIZWlnaHQiLCJoYW5kbGVDbGljayIsIndyYXBwZXJFbCIsImlzQ29sbGFwc2VkIiwidGFyZ2V0RWwiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJidWlsZFNlbGVjdG9yIiwiVW5pdmVyc2FsUmVzdWx0c0NvbXBvbmVudCIsIl9saW1pdCIsImNoaWxkT3B0cyIsImdldENoaWxkQ29uZmlnIiwidXNlQWNjb3JkaW9uIiwiZGVmYXVsdENvbmZpZyIsIlBhZ2luYXRpb25Db21wb25lbnQiLCJfZmlyc3RQYWdlQnV0dG9uRW5hYmxlZCIsInNob3dGaXJzdCIsIl9sYXN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJzaG93TGFzdCIsInNob3dDb250cm9scyIsInByZXZpb3VzUGFnZUJ1dHRvbiIsIm5leHRQYWdlQnV0dG9uIiwibWF4UGFnZSIsInRydW5jIiwidXBkYXRlUGFnZSIsImZpcnN0UGFnZUJ1dHRvbiIsImxhc3RQYWdlQnV0dG9uIiwic2Nyb2xsVG9Ub3AiLCJ2ZXJ0aWNhbFBhZ2UiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJwYWdlTnVtYmVyIiwiaXNNb3JlUmVzdWx0cyIsImZpcnN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJsYXN0UGFnZUJ1dHRvbkVuYWJsZWQiLCJzaG93Rmlyc3RQYWdlQnV0dG9uIiwic2hvd1ByZXZpb3VzUGFnZUJ1dHRvbiIsInNob3dOZXh0UGFnZUJ1dHRvbiIsInNob3dMYXN0UGFnZUJ1dHRvbiIsIlF1ZXN0aW9uU3VibWlzc2lvbkNvbXBvbmVudCIsInZhbGlkYXRlQ29uZmlnIiwidHJpZ2dlckVsIiwiYmluZEZvcm1Ub2dnbGUiLCJiaW5kRm9ybUZvY3VzIiwiYmluZEZvcm1TdWJtaXQiLCJnZXRBbmFseXRpY3NFdmVudCIsImZvcm1EYXRhIiwiaW5wdXRGaWVsZHMiLCJvYmoiLCJjaGVja1ZhbGlkaXR5IiwidmFsaWRpdHkiLCJ2YWx1ZU1pc3NpbmciLCJlbWFpbEZvcm1hdEVycm9yVGV4dCIsInByaXZhY3lQb2xpY3lFcnJvclRleHQiLCJhbmFseXRpY3NFdmVudCIsIlNWR0ljb24iLCJwYXRoIiwiY29tcGxleENvbnRlbnRzIiwidmlld0JveCIsImNvbnRlbnRzIiwicGF0aERlZmluaXRpb24iLCJpY29uc0FycmF5IiwidGh1bWJJY29uIiwicmVjZWlwdEljb24iLCJwYW50aGVvbkljb24iLCJtaWNJY29uIiwiZGlyZWN0aW9uc0ljb24iLCJjYWxlbmRhckljb24iLCJjYWxsb3V0SWNvbiIsImluZm9JY29uIiwiYnJpZWZjYXNlSWNvbiIsImthYm9iSWNvbiIsInBlcnNvbkljb24iLCJtYWduaWZ5aW5nR2xhc3NJY29uIiwib2ZmaWNlSWNvbiIsImxpbmtJY29uIiwid2luZG93SWNvbiIsInBob25lSWNvbiIsInRhZ0ljb24iLCJkb2N1bWVudEljb24iLCJjaGV2cm9uSWNvbiIsInN1cHBvcnRJY29uIiwieWV4dEljb24iLCJwaW5JY29uIiwiZ2Vhckljb24iLCJsaWdodEJ1bGJJY29uIiwiSWNvbnMiLCJtYXJrdXAiLCJzdGFySWNvbiIsIkljb25Db21wb25lbnQiLCJpY29uTmFtZSIsImN1c3RvbUljb24iLCJpY29uVXJsIiwiQ09NUE9ORU5UX0NMQVNTX0xJU1QiLCJDT01QT05FTlRfUkVHSVNUUlkiLCJyZWdpc3RyeSIsIkNvbXBvbmVudE1hbmFnZXIiLCJfYWN0aXZlQ29tcG9uZW50cyIsIl9jb3JlIiwiX2FuYWx5dGljc1JlcG9ydGVyIiwicmVwb3J0ZXIiLCJjb21wb25lbnRDbGF6eiIsImNvbXBvbmVudFR5cGUiLCJjb21wb25lbnRDbGFzcyIsImFyZUR1cGxpY2F0ZU5hbWVzQWxsb3dlZCIsInNvbWUiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJUYWJDb25maWciLCJ0YWJDb25maWdzIiwiTmF2aWdhdGlvbkNvbmZpZyIsIkRFRkFVTFRTIiwiQW5zd2VycyIsImNvbXBvbmVudHMiLCJfb25SZWFkeSIsIl9lbGlnaWJsZUZvckFuYWx5dGljcyIsIl9zZXJ2aWNlcyIsIl9hbmFseXRpY3NSZXBvcnRlclNlcnZpY2UiLCJuYXZpZ2F0aW9uIiwib25TdGF0ZUNoYW5nZSIsInNldEFsbCIsIm1vY2siLCJnZXRNb2NrU2VydmljZXMiLCJnZXRTZXJ2aWNlcyIsInN1YnN0ciIsInNldENvcmUiLCJzZXRSZW5kZXJlciIsInNldEFuYWx5dGljc1JlcG9ydGVyIiwiaW5pdFNjcm9sbExpc3RlbmVyIiwiX3NldERlZmF1bHRJbml0aWFsU2VhcmNoIiwib25SZWFkeSIsInVzZVRlbXBsYXRlcyIsInRlbXBsYXRlQnVuZGxlIiwicmVnaXN0ZXIiLCJyZW1vdmVCeU5hbWUiLCJvcHRJbiIsInNldENvbnZlcnNpb25UcmFja2luZ0VuYWJsZWQiLCJzZWFyY2hDb25maWciLCJwcmVwb3B1bGF0ZWRRdWVyeSIsImVycm9yUmVwb3J0ZXJTZXJ2aWNlIiwiZGVidWciLCJzdXBwcmVzc0Vycm9yUmVwb3J0cyIsIkRFQk9VTkNFX1RJTUUiLCJ0aW1lb3V0Iiwic2VuZEV2ZW50IiwiaW5uZXJIZWlnaHQiLCJwYWdlWU9mZnNldCIsIkFOU1dFUlMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUFBOztFQUVBOzs7OztBQUtBLHFCQUFlO0VBQ2JBLEVBQUFBLFVBQVUsRUFBRSxZQURDO0VBRWJDLEVBQUFBLGNBQWMsRUFBRSxnQkFGSDtFQUdiQyxFQUFBQSxlQUFlLEVBQUU7RUFISixDQUFmOztFQ1BBO01BRXFCQyxTQUNuQixrQkFBd0I7RUFBQSxNQUFYQyxJQUFXLHVFQUFKLEVBQUk7O0VBQUE7O0VBQ3RCOzs7OztFQUtBLE9BQUtDLElBQUwsR0FBWUQsSUFBSSxDQUFDRSxHQUFMLElBQVksSUFBeEI7RUFFQTs7Ozs7O0VBS0Es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